/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.scalar.conf,v 1.5 2002/07/18 14:18:52 dts12 Exp $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "@CYACSADM@.h"
#include "cystrings.h"
#include "cycommon.h"

static int cy_oper = 0;

/** Initializes the @CYACSADM@ module */
void
init_@CYACSADM@(void)
{
    oid      @CYACSSERIALHUP@_oid[] =
        { PROD_OID, 4, 2, 0 };
    oid      @CYACSSAVE@_oid[] =
        { PROD_OID, 4, 1, 0 };

    DEBUGMSGTL(("@CYACSADM@", "Initializing\n"));

    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("@CYACSSERIALHUP@",
                               do_@CYACSSERIALHUP@,
                               @CYACSSERIALHUP@_oid,
                               OID_LENGTH(@CYACSSERIALHUP@_oid),
                               HANDLER_CAN_RWRITE));
    netsnmp_register_instance(netsnmp_create_handler_registration
                              ("@CYACSSAVE@",
                               do_@CYACSSAVE@,
                               @CYACSSAVE@_oid,
                               OID_LENGTH(@CYACSSAVE@_oid),
                               HANDLER_CAN_RWRITE));
}

int
do_@CYACSSERIALHUP@(netsnmp_mib_handler *handler,
                  netsnmp_handler_registration *reginfo,
                  netsnmp_agent_request_info *reqinfo,
                  netsnmp_request_info *requests)
{
	int res = 0;
    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&res, sizeof(int));
        break;

    case MODE_SET_RESERVE1:
		if (requests->requestvb->type != ASN_INTEGER) {
			netsnmp_set_request_error(reqinfo, requests,
						  SNMP_ERR_WRONGTYPE);
			break;
		}
		if (*(requests->requestvb->val.integer) > 1) {
			netsnmp_set_request_error(reqinfo, requests,
						  SNMP_ERR_WRONGVALUE);
		}
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	cy_oper = *(requests->requestvb->val.integer);
        break;

    case MODE_SET_COMMIT:
	if (cy_oper) {
		system("signal_ras hup >/dev/null 2>&1");
	}
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
do_@CYACSSAVE@(netsnmp_mib_handler *handler,
             netsnmp_handler_registration *reginfo,
             netsnmp_agent_request_info *reqinfo,
             netsnmp_request_info *requests)
{
	int res = 0;
    /*
     * We are never called for a GETNEXT if it's registered as a
     * "instance", as it's "magically" handled for us.  
     */

    /*
     * a instance handler also only hands us one request at a time, so
     * we don't need to loop over a list of requests; we'll only get one. 
     */

    switch (reqinfo->mode) {

    case MODE_GET:
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 (u_char *)&res, sizeof(int));
        break;

    case MODE_SET_RESERVE1:
		if (requests->requestvb->type != ASN_INTEGER) {
			netsnmp_set_request_error(reqinfo, requests,
						  SNMP_ERR_WRONGTYPE);
			break;
		}
		if (*(requests->requestvb->val.integer) > 1) {
			netsnmp_set_request_error(reqinfo, requests,
						  SNMP_ERR_WRONGVALUE);
		}
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
	cy_oper = *(requests->requestvb->val.integer);
        break;

    case MODE_SET_COMMIT:
	if (cy_oper) {
		system("saveconf >/dev/null 2>&1");
	}
        break;

    case MODE_SET_UNDO:
        break;

    default:
        /*
         * we should never get here, so this is a really bad error 
         */
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
