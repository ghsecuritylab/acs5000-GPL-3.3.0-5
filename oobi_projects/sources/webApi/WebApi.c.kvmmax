/*****************************************************************
 * File: webApi.c
 *
 * Copyright (C) 2003 Cyclades Corporation
 *
 * Maintainer: www.cyclades.com
 *
 * Description: This file contains functions that are used by
 * Art and Logic as well as the CLI.            
 *
 ****************************************************************/

#include <stddef.h>

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>
#include <time.h>
#include <grp.h>
#include <pwd.h>
#include <dirent.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/wait.h>
#include <linux/version.h>
#include <asm/cyc_config.h>
#include <asm/flash.h>
#include <asm/prxk.h>
#include <src/server.h>
#include <src/mysyslog.h>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <sys/ioctl.h>

#include <webApi.h>
#include "WebApi2.h"
#include <SystemData.h> /*[LMT] Security Enhancements*/

#include <src/bootconf.h>
#ifdef UBOOT_PARAM
#include <cyc_env.h>
#endif
#include "userinfo.h"
#include "webpmcomm.h"
#include "webpm.h"

#define MIN(a,b) ((a) < (b)) ? (a) : (b)

#if defined(KVM)
#define MAX_DEV         cy_shm->max_devA
#elif defined(ONS)
#define MAX_DEV			cy_shm->max_devA+AUX_OFFSET
#else
#define MAX_DEV         cy_shm->max_devS
#endif

#ifdef UBOOT_PARAM
char     om_buf[FLASH_BLOCK];

int      speeda[] = {4800, 9600, 19200, 38400, 57600, 115200};

static NAMEVAL_LIST NameValList [NUM_VARIABLES];
#endif

#if defined(KVM) || defined(ONS)
#include "kvmcfg.h"
#define KVMCONFIG_C
#include "kvmconfig.h"
#include "kvmd.h"
#include "kvmforms.h"
#include "kvm_auxport.h"
#include "kvm_cascade.h"
#include <cyc.h>
extern struct cyc_info *cyc;
#undef KVMCONFIG_C


typedef char *error_msgs[];

#define kvmErrMessages_unknown 14
#define kvmErrMessages_max 16
error_msgs kvmErrMessages = {
	"All slots are full.",
	"No port to cycle.",
	"Upload interrupted.",
	"Invalid device",
	"There is already an upload in progress.",
	"File does not exist or is empty.",
	"File could not be opened.",
	"Device connected to the port does not match with the device/model entered.",
	"Microcontroller rebooted does not match with the device/model entered.",
	"Transfer cancelled by the microcontroller.",
	"File is not compatible with the target device.",
	"Version in file is lower than the one in the device.",
	"It was impossible to build a consistent command.",
	"Communication timeout.",
	"Unknown Error",  //14
// Messages related to IP cards
	"Error writing card 1 firmware, aborting.",
	"Error writing card 2 firmware, aborting.",
	"Error writing card 3 firmware, aborting.",
	"Error writing card 4 firmware, aborting."
};

//static error_vector kvmErrVector = {0}; // Initialize everything to NULL
//static error_vector kvmPortVector = {0}; // Initialize everything to NULL
extern struct kvm_conf_def conf_cfg[];
struct _kvm_global kvmgbl;
//int kvmdebug = 0, kvmtrace = 0;
struct _kvm_server kvmserver[MAXKVMPORTS];
static kvm_auxport kvm_auxport_global = NULL;
static kvm_cascade kvm_cascade_global = NULL;
#endif

#ifndef WebPagesDir
#define WebPagesDir "web"
#endif

extern int errno;

struct MachineType mt;
int numPowerSupply = 0;
static char picture_name[64];

static char telnet_cmd[] =
#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
        "telnet stream tcp nowait root /bin/telnetd telnetd -L /bin/login\n";
#else
        "telnet stream  tcp     nowait  root    /usr/sbin/tcpd  /usr/sbin/in.telnetd\n";
#endif

/*[LMT] Security Enhancements*/
static char ftp_cmd[] =
#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
        "ftp    stream  tcp     nowait  root    /bin/ftpd       ftpd\n";
#else
        "ftp stream tcp nowait root /usr/sbin/tcpd /usr/local/sbin/ftpd\n";
#endif

#ifdef ONS
static char tftp_cmd[] =
        "tftp   dgram   udp     wait    root    /usr/sbin/tcpd  in.tftpd\n";
#endif

/*[LMT] Security Enhancements*/
char *fields_web[]={"HTTP_PORT","HTTPS_PORT","HTTPS","HTTP","SECLEVEL","SSLVER"};

//int qDebug;
//int executeFlg;

// Ports Array
static SInt8 *portsArray = NULL;

// Power Management - global var
static int gPmIpduPort = -1;
static int gPmIpduUnitNumber = -1;

#define KVMIP_DEFAULT_VIEWER_PORT "5900+"

/******************************************************/
/* Managing the reading and writing of files routines */
/******************************************************/
static Result RdSwVersionModel (void *, CycParam *, int);
static Result RdWrtHostName (void *, CycParam *, int);
static Result RdWrtIssue (void *, CycParam *, int);
static Result RdWrtResolvConf (void *, CycParam *, int);
static Result RdWrtHostConf (void *, CycParam *, int);
static Result RdWrtGateWay (void *, CycParam *, int);
static Result RdWrtPslave (void *, CycParam *, int);
static Result EnableAllPorts (void *, CycParam *, int); //[RK]Dec/02/05
#ifdef BONDING_FEATURE
static Result RdWrtBonding(void *ptr, CycParam *paramList, int rdWrtFlg);
static Result RdBonding(char *namefile, CycParam *paramList, char *parmname);
static Result WrtBonding(char *namefile, CycParam *paramList, char *parmname);
#endif
static Result RdWrtListEntries (void *, CycParam *, int);
static Result RdWrtVirtualPorts (void *, CycParam *, int);
static Result RdUnitInfo (void *, CycParam *, int);
static Result RdWrtDateTime (void *, CycParam *, int);
static Result RdWrtTimezone(void *ptr, CycParam *paramList, int rdWrtFlg);
static Result RdWrtBootConf (void *, CycParam *, int);
static Result RdTs110Info (void *, CycParam *, int);
static Result GetPcmciaInfo (void *, CycParam *, int);
static Result RdWrtIpSecEntries (void *, CycParam *, int);
static Result RdWrtIpSecRSA (void *, CycParam *, int);
static Result RdWrtSysInfoSnmpdConf (void *, CycParam *, int);
static Result RdWrtConfigSnmpdConf (void *, CycParam *, int);
static Result RdWrtNisConfiguration (void *, CycParam *, int);
static Result RdWrtCommentLineEntry(void *, CycParam *, int);
static Result RdWrtShellVar (void *, CycParam *, int);
static Result RdWrtWebUiShell (void *, CycParam *, int);
static Result RdWrtSshShell (void *, CycParam *, int);
static Result wrPublicKey (void *, CycParam *, int);
static Result RdWrtMenuShInfo (void *, CycParam *, int);
static Result RdWrtLdapInfo (void *, CycParam *, int);
static Result RdWrtKrbInfo (void *, CycParam *, int);
static Result RdWrtRadiusInfo (void *, CycParam *, int);
static Result RdWrtTacplusInfo (void *, CycParam *, int);
static Result RdWrtSmbInfo (void *, CycParam *, int);
//static Result RdWrtAuthInfo (void *, CycParam *, int);
static Result ReadWriteNisAuthType(int *pauthType, int rdWrtFlg);

#if defined(KVM) || defined(ONS)
static Result RdWrtKVMD(void *, CycParam *, int);
static Result RdWrtKVMAccList(void *, CycParam *, int);
static Result RdWrtKVMCyclingList(void *, CycParam *, int);
static Result kvm_auxport_read_write_config (void *ptr, CycParam *paramList, int rdWrtFlg);
static Result kvm_read_numofoutlet (void *ptr, CycParam *paramList, int rdWrtFlg);
static Result kvm_cascade_read_numdevices (void *ptr, CycParam *paramList, int rdWrtFlg);
static Result kvm_cascade_read_write_config (void *ptr, CycParam *paramList, int rdWrtFlg);
/* to be deleted later */
//static Result RdWrtKVM(void *, CycParam *, int);
#endif

// Syslog-ng routines
static Result RdWrtSyslogBufServerEntry (void *, CycParam *, int );
static Result RdWrtSyslogServerEntry (void *, CycParam *, int);
static Result RdWrtNotificationEntry (void *, CycParam *, int);
static void GetNumNotificationEntries (CycCatKeyTable *, CycParam *);

static Result RdWrtSyslogDestEnable (void *, CycParam *, int);
static Result RdWrtSyslogFilterEntry(void *, CycParam *, int );

#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
// IP Chains routines 
static void GetIpChainsNum (CycCatKeyTable *, CycParam *);
static Result RdWrtIpChainsInfo (void *, CycParam *, int);
static Result RdWrtIpChainsRuleInfo (void *, CycParam *, int);
#else
// IP Tables routines
static void GetIpTableChainNum (CycCatKeyTable *, CycParam *, char *);
static Result RdWrtFilterChainInfo (void *, CycParam *, int);
static Result RdWrtFilterChainRuleInfo (void *, CycParam *, int);
static Result RdWrtNatChainInfo (void *, CycParam *, int);
static Result RdWrtNatChainRuleInfo (void *, CycParam *, int);
#endif

// Power Management routines
static Result RdPmNumPorts (void *, CycParam *, int);
static Result RdPmPortInfo (void *, CycParam *, int);
static Result RdPmOutletInfo (void *, CycParam *, int);
static Result WrtPmIpduNumber (void *, CycParam *, int);
static Result RdWrtPmIpduConf (void *, CycParam *, int);
static Result RdPmIpduUnitInfo (void *, CycParam *, int);
static Result RdWrtPmIpduUnitAlarm (void *, CycParam *, int);
static Result RdPmIpduUnit (void *, CycParam *, int);
static Result RdWrtPmIpduUserMgm (void *, CycParam *, int);
static Result RdPmFirmUpgradeVersion (void *, CycParam *, int);
static Result GetNumMultiDev(void *ptr, CycParam *paramList, int rdWrtFlg);
static Result GetMultiDevInfo(void *ptr, CycParam *paramList, int rdWrtFlg);
static Result GetMultiDevOutletInfo(void *ptr, CycParam *paramList, int rdWrtFlg);

#ifdef IPMI
//[RK]Dec/22/04 - WebUI IPMI config
#define IPMI_CONF_FILE	"/etc/IPMIServer.conf"
static Result RdWrtIPMIDeviceInfo (void *, CycParam *, int);
static void *ParseIPMIDeviceEntry (unsigned char *,  CycParam *, void *);
#endif

/******************************************************/
/* Specific parsing of files routines                 */
/******************************************************/
static void *ParseHostEntry (unsigned char *, CycParam *, void *);
static void *ParseUserEntry (unsigned char *,  CycParam *, void *);
static void *ParseIpSecEntry (unsigned char *,  CycParam *, void *);
static void *ParseStRoutesEntry (unsigned char *,  CycParam *, void *);
static void *ParseRoutingTableEntry (unsigned char *,  CycParam *, void *);
static void *ParseRamDiskInfo (unsigned char *,  CycParam *, void *);
static void *ParseActiveSessionEntry (unsigned char *,  CycParam *, void *);
static void *ParseCasSessionEntry (unsigned char *,  CycParam *, void *);
static void *ParseCommunityInfo (unsigned char *,  CycParam *, void *);
static void *ParseSnmpv3Info (unsigned char *,  CycParam *, void *);
static void *ParseSyslogServerEntry (unsigned char *,  CycParam *, void *);

#if defined(KVM) || defined(ONS)
static void *ParseKVMGroupsEntry (unsigned char *,  CycParam *, void *);
#endif

/******************************************************/
/* Specific writing to files routines                 */
/******************************************************/
static Result WriteHostEntry (unsigned char *, CycParam *);
static Result WriteUserEntry (unsigned char *, CycParam *);
static Result WriteIpSecEntry (unsigned char *, CycParam *);
static Result WriteStRoutesEntry (unsigned char *, CycParam *);
static Result WriteRoutingTableEntry (unsigned char *, CycParam *);
#if defined(KVM) || defined(ONS)
static void CreateKVMuCCommand (KVMMicrocode *, unsigned char *,
				unsigned char *, unsigned char *);
static void ControlKVMuC (KVMMicrocode *, unsigned char *, error_vector *, error_vector *);
#endif
/*[LMT] warning: initialization from incompatible pointer type
static Result RemSpecPslaveParam(CycCatKeyTable *pkey);
*/
static Result RemSpecPslaveParam();

static Result WritePhysPortConf (void *, CycParam *, int);

static Result ReadEntries(void *, CycParam *, int);
static int GetNumOfPcmciaSlot(void);
static Result ReadIpSecEntries(void *, CycParam *, int);

// Online Help Config
static Result RdWrtOnlineHelp(void *ptr, CycParam *paramList, int rdWrtFlg);

#if defined(KVM) || defined(ONS)
/* General functions and types to down/upload files using ftp */
typedef enum
{
	DOWNLOAD,
	UPLOAD,
} ftpAction;

typedef enum
{
	NORMAL,
	PASSIVE
} ftpMode;

static Result WriteKVMGroupsEntry (unsigned char *, CycParam *);
/*WebApi.c:1103: warning: `FtpControl' defined but not used*/
static void FtpControl(ftpInfo, ftpAction); 
/*WebApi.c:1123: warning: `CreateFtpControlFile' defined but not used*/
static void CreateFtpControlFile(char *, ftpInfo, ftpAction, ftpMode);
/*WebApi.c:1163: warning: `FtpCall' defined but not used*/
static void FtpCall(char *, char *, char *, char *);
#endif

//static CycYesNoOption ServiceActive(char *, char *, CycYesNoOption , int);

#ifdef RDPenable
static Result RdWrtRDP (void *ptr, CycParam *paramList, int rdWrtFlg);
#endif	//RDPenable

/*[LMT] Security Enhancements*/
#define BUF_FILE 1024
char delim[]={' ','\t','\0'};
static Result RdWrtSecOptVar(void *, CycParam *, int);
static Result RdWrtSecOptProfPorts(void *, CycParam *, int);
int GetProfPortsOpts(CycParam *, char *);
int SetProfPortsOpts(CycParam *, char *);
int CheckLineParam(char *, char *, int);
int GetWebValues(char *, CycParam *);
int SetWebValues(char *, CycParam *);
int GetSshValues(char *, CycParam *);
int SetSshValues(char *, CycParam *);
int SetEchoOpts(int, char *, char *);
int addConfigFiles(char *);
int GetWebPortsServices(short int);
int GetEchoOpts(char *, char *);
int chkComment(char *);
int cp(char *, char *);
int SetIcmpProc(int);
int setProfile(int);

//[LMT] warning: implicit declaration of function `isblank'
int isblank(int c);
// [LMT] warning: implicit declaration of function `CycGetCurrentAdmin'
char *CycGetCurrentAdmin();
int parseIntValue(char *linefromfile);

typedef union _y_types
{
  int *yi;
  char *yc;
  char **ypc;
} y_types;

TranslateOptions IpSecBootActionOptions[] =
{
  {"ignore", kIgnore},
  {"add", kIpSecAdd},
  {"start", kStart}
};

// ENABLE: 0 ==> "NO", 1 ==> "YES"
TranslateOptions EnableOptions[] =
{
  {"NO", kNo},
  {"YES", kYes},
};

TranslateOptions IpSecAuthProtocolOptions[] =
{
  {"esp", kEsp},
  {"ah", kAh},
};

TranslateOptions IpSecAuthMethodOptions[] =
{
  {"rsasig", kRsa},
  {"secret", kIpSecSecret}
};

#define OFF_IpSec(x)  offsetof(IpSecInfo, x)
#define TY_IPSEC_STR  0
#define TY_IPSEC_LIST 1

ParamEntry IpSecParams[] = {
  {"leftid", NULL, 0, TY_IPSEC_STR, OFF_IpSec(leftId), kDomainNameLength},
  {"left", NULL, 0, TY_IPSEC_STR, OFF_IpSec(leftIp), kIpLength},
  {"leftsubnet", NULL, 0, TY_IPSEC_STR, OFF_IpSec(leftSubnet), kSubnetLength},
  {"leftnexthop", NULL, 0, TY_IPSEC_STR, OFF_IpSec(leftNextHop), kIpLength},
  {"leftrsasigkey", NULL, 0, TY_IPSEC_STR, OFF_IpSec(leftRsaKey), kRsaKeyLength},
  {"rightid", NULL, 0, TY_IPSEC_STR, OFF_IpSec(rightId), kDomainNameLength},
  {"right", NULL, 0, TY_IPSEC_STR, OFF_IpSec(rightIp), kIpLength},
  {"rightsubnet", NULL, 0, TY_IPSEC_STR, OFF_IpSec(rightSubnet), kSubnetLength},
  {"rightnexthop", NULL, 0, TY_IPSEC_STR, OFF_IpSec(rightNextHop), kIpLength},
  {"rightrsasigkey", NULL, 0, TY_IPSEC_STR, OFF_IpSec(rightRsaKey), kRsaKeyLength},
  {"auto", &IpSecBootActionOptions, sizeof(IpSecBootActionOptions)/sizeof(TranslateOptions), TY_IPSEC_LIST, OFF_IpSec(bAction),0},
  {"auth", &IpSecAuthProtocolOptions, sizeof(IpSecAuthProtocolOptions)/sizeof(TranslateOptions), TY_IPSEC_LIST, OFF_IpSec(aProtocol),0},
  {"authby", &IpSecAuthMethodOptions, sizeof(IpSecAuthMethodOptions)/sizeof(TranslateOptions), TY_IPSEC_LIST, OFF_IpSec(aMethod),0}
};

TranslateOptions AccessOrderOptions[] =
{
  {"", kAoNone},
  {"hosts", kAoHosts},
  {"bind", kAoDns},
  {"hosts,bind", kAoHostsDns},
  {"bind,hosts", kAoDnsHosts}
};

TranslateOptions OffOnOptions[] =
{
  {"off", kOff},
  {"on", kOn}
};

TranslateOptions NisAuthOptions[] =
{
  {"files nis", kPatLocalNis},
  {"nis files", kPatNisLocal},
  {"nis [ NOTFOUND=return UNAVAIL=continue TRYAGAIN=continue ] files", kPatNisDownLocal},
  {"nis", kPatNis},
  {"files", kPatLocal}
};
TranslateOptions FlashDbOptions[] =
{
  {"LOCAL", kNo},
  {"CF", kYes}
};

TranslateOptions IsdnCallbackOptions[] =
{
  {"off", kNo},
  {"in", kYes}
};

TranslateOptions WirelessModeOptions[] =
{
  {"Ad-Hoc", kNo},
  {"Managed", kYes}
};

#define SIZE_catKeyList sizeof(catKeyList)/sizeof(CycCatKeyTable)
#define SIZE_IpSecParams sizeof(IpSecParams)/sizeof(ParamEntry)
#define SIZE_EnableOptions sizeof(EnableOptions)/sizeof(TranslateOptions)
#define SIZE_NisAuthOptions sizeof(NisAuthOptions)/sizeof(TranslateOptions)
#define SIZE_FlashDbOptions sizeof(FlashDbOptions)/sizeof(TranslateOptions)
#define SIZE_IsdnCallbackOptions sizeof(IsdnCallbackOptions)/sizeof(TranslateOptions)
#define SIZE_WirelessModeOptions sizeof(WirelessModeOptions)/sizeof(TranslateOptions)
#define SIZE_AccessOrderOptions sizeof(AccessOrderOptions)/sizeof(TranslateOptions)
#define SIZE_OffOnOptions sizeof(OffOnOptions)/sizeof(TranslateOptions)

CycCatKeyTable catKeyList[] = 
{
	{kFirmWare, kNumber, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
#ifdef ONS
	{kFirmWare, kNumberS, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kFirmWare, kNumberSA, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
#endif
	{kFirmWare, kSwVersion, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kFirmWare, kModel, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kFirmWare, kPicture, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kHostnameSetting, kHostName, HOSTNAME_FILE, RdWrtHostName, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kIssueSetting, kConsoleBanner, ISSUE_FILE, RdWrtIssue, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kResolvConf, kDnsService, RESOLV_FILE, RdWrtResolvConf, 
	NULL, NULL, NULL, "nameserver", TYPE_IP, 0, NULL, 
	0, 0}, 		
	{kHostConf, kNameServiceAccess, HOST_CONF_FILE, RdWrtHostConf, 
	NULL, NULL, NULL, "multi", TYPE_LIST, 0, &AccessOrderOptions, 
  SIZE_AccessOrderOptions, 0}, 
	{kStRoutes, kIpAddress, ST_ROUTES_FILE, RdWrtGateWay, 
	NULL, NULL, NULL, "route", TYPE_IP, 0, NULL, 
	0, 0}, 
	{kPslave, kIpAddress, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "eth_ip", TYPE_IP, kIpLength, NULL, 
	0, 0},
	{kPslave, k2ndIpAddress, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "eth_ip_alias", TYPE_IP, kIpLength, NULL, 
	0, 0},
	{kPslave, kNetMask, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "eth_mask", TYPE_IPMASK, kIpLength, NULL, 
	0, 0},
	{kPslave, k2ndNetMask, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "eth_mask_alias", TYPE_IPMASK, kIpLength, NULL, 
	0, 0},
	{kPslave, kDhcpClient, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "dhcp_client", TYPE_NUM, kIntLength, NULL,  
	0, 0},
#ifdef BONDING_FEATURE
        {kBonding, kBondingEnable, BONDING_FILE, RdWrtBonding,
        NULL, NULL, "conf", "bond_enabled", TYPE_NUM, kIntLength, NULL,
        0, 0}, //bonding enalble or disable
        {kBonding, kBondingMiimon, BONDING_FILE, RdWrtBonding,
        NULL, NULL, "conf", "bond_miimon", TYPE_NUM, kIntLength, NULL,
        0, 0}, //bonding miimon (interval in which interface is checked for its status)
        {kBonding, kBondingUpdelay, BONDING_FILE, RdWrtBonding,
        NULL, NULL, "conf", "bond_updelay", TYPE_NUM, kIntLength, NULL,
        0, 0}, //bonding updelay (time to wait before reactivating the primary interface, after
                //it has been detected as up again
#endif
	{kPslave, kNumConfGroups, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "group", TYPE_NUM, 0, NULL, 
	0, 0},
	{kPslave, kConfGroup, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "group", TYPE_STRING, kGroupNameLength, NULL, 
	0, 0},
	{kPslave, kCommonConfigFile, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "include", TYPE_STRING, kDirPathLength, NULL, 
	0, 0},
	{kPslave, kMtu, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "eth_mtu", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kClusteringIp, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "nat_clustering_ip", TYPE_IP, kIpLength, NULL, 
	0, 0},
	{kPslave, kSocketPort, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "socket_port", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kPortIpno, PSLAVE_FILE, RdWrtPslave, 	
	NULL, NULL, "all", "ipno", TYPE_IP, kIpLength, NULL, 
	0, 0},
	{kPslave, kSttyCommand, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "sttyCmd", TYPE_STRING, kSttyCommandLength, NULL, 
	0, 0},
	{kPslave, kPppopt, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "pppopt", TYPE_STRING, kInfoLength, NULL, 
	0, 0},
	{kPslave, kTransInterval, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "tx_interval", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kPollInterval, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "poll_interval", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kIdleTimeOut, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "idletimeout", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kLineFeedSuppress, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "lf_suppress", TYPE_NUM, kIntLength, NULL, 	
	0, 0},
	{kPslave, kInputStrAutoAns, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "auto_answer_input", TYPE_STRING, kPasswordLength, NULL, 
	0, 0},
	{kPslave, kOutputStrAutoAns, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "auto_answer_output", TYPE_STRING, kPasswordLength, NULL, 
	0, 0},
	{kPslave, kDtrOffTimeInterval, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "DTR_reset", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kTsHost, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "host", TYPE_IP, kIpLength, NULL, 
	0, 0},
	{kPslave, kIssue, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "issue", TYPE_STRING, kInfoLength, NULL, 
	0, 0},
	{kPslave, kLoginPrompt, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "prompt", TYPE_STRING, kPromptLength, NULL, 
	0, 0},
	{kPslave, kTerminalType, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "term", TYPE_STRING, kTermTypeLength, NULL, 
	0, 0},
	{kPslave, kDefaultUserName, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "userauto", TYPE_STRING, kUserNameLength, NULL, 
	0, 0},
	{kPslave, kTelnetClientMode, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "telnet_client_mode", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kDbMode, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "DB_mode", TYPE_NUM, kIntLength, NULL,  
	0, 0},
	{kPslave, kDbFileSize, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "data_buffering", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kNfsFilePath, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "nfs_data_buffering", TYPE_STRING, kDirPathLength, NULL, 
	0, 0},
	{kPslave, kDbFacilityNum, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "DB_facility", TYPE_NUM, kIntLength, NULL, 	
	0, 0},
	{kPslave, kSyslogBuffSize, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "syslog_buffering", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kSyslogBuffEnable, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "syslog_buffering", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kShowMenu, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "dont_show_DBmenu", TYPE_NUM, kIntLength, NULL,  
	0, 0},
	{kPslave, kAlarm, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "alarm", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kConfFacilityNum, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "facility", TYPE_NUM, kIntLength, NULL, 				
	0, 0},
	{kPslave, kTimeStamp, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "DB_timestamp", TYPE_NUM, kIntLength, NULL, 	
	0, 0},
	{kPslave, kSyslogBuffSess, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "syslog_sess", TYPE_NUM, kIntLength, NULL,   
	0, 0},
	{kPslave, kSniffMode, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "sniff_mode", TYPE_NUM, kIntLength, NULL, 		
	0, 0},
	{kPslave, kAdminUsers, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "admin_users", TYPE_STRING, kListLength, NULL, 
	0, 0},
	{kPslave, kPortUsers, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "users", TYPE_STRING, kListLength, NULL, 
	0, 0},
	{kPslave, kEscapeChar, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "escape_char", TYPE_STRING, kHotKeyLength, NULL, 
	0, 0},
	{kPslave, kMultiSess, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "multiple_sessions", TYPE_LIST, kIntLength, NULL, 
	0, 0},
	{kPslave, kMultiUserNotif, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "multiuser_notif", TYPE_LIST, kIntLength, NULL, 
	0, 0},
	{kPslave, kEmsTranslation, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "translation", TYPE_STRING, kTermTypeLength, NULL,  
	0, 0},
	{kPslave, kEmsWebAccess, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "web_WinEMS", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kEmsXmlMonitor, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "xml_monitor", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	{kPslave, kBiometric, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "biometric", TYPE_NUM, kIntLength, NULL, 
	0, 0},
	//{kPslave, kModbusSmode, PSLAVE_FILE, RdWrtPslave, // Not in version 1
	//NULL, NULL, "all", "modbus_smode", TYPE_STRING, kTermTypeLength, NULL, 
	//0, 0},
	{kPslave, kAuth, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "authtype", TYPE_LIST, kIntLength, NULL, 		
	0, 0},
	{kPslave, kUnitAuth, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "conf", "authtype", TYPE_LIST, kIntLength, NULL, 
	0, 0},
	{kPslave, kBaudRate, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "speed", TYPE_NUM, kIntLength, NULL, 			
	0, 0},   
	{kPslave, kFlow, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "flow", TYPE_LIST, kIntLength, NULL, 		
	0, 0},   
	{kPslave, kBits, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "datasize", TYPE_NUM, kIntLength, NULL, 
	0, 0},   
	{kPslave, kStopBits, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "stopbits", TYPE_NUM, kIntLength, NULL, 
	0, 0},   
	{kPslave, kParity, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "parity", TYPE_LIST, kIntLength, NULL, 
	0, 0},   
	{kPslave, kProtocol, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "protocol", TYPE_LIST, kIntLength, NULL, 
	0, 0},   
	{kPslave, kDcdSensitive, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "dcd", TYPE_NUM, kIntLength, NULL, 		
	0, 0},   
	{kPslave, kWriteLoginRecordsUtmp, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "sysutmp", TYPE_NUM, kIntLength, NULL, 
	0, 0},   
	{kPslave, kWriteLoginRecordsWtmp, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "syswtmp", TYPE_NUM, kIntLength, NULL, 
	0, 0},   
	{kPslave, kInitChat, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "initchat", TYPE_STRING, kInfoLength, NULL, 
	0, 0},   
	{kPslave, kPoolIpno, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "pool_ipno", TYPE_IP, kIpLength, NULL, 
	0, 0},   
	{kPslave, kPoolSocketPort, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "pool_socket_port", TYPE_NUM, kIntLength, NULL, 
	0, 0},   
	{kPslave, kPoolServerFarm, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "pool_alias", TYPE_STRING, kHostNameLength, NULL, 
	0, 0},   
	{kPslave, kBrkSeq, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "break_sequence", TYPE_STRING, kBreakSeqLength, NULL, 
	0, 0},   
	{kPslave, kBrkInterval, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "break_interval", TYPE_NUM, kIntLength, NULL, 
	0, 0},  
/*
	{kPslave, kAuthHost1, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "authhost1", TYPE_IP, kIpLength, NULL, 
	0, 0},  
	{kPslave, kAuthHost2, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "authhost2", TYPE_IP, kIpLength, NULL, 
	0, 0},  
	{kPslave, kAcctHost1, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "accthost1", TYPE_IP, kIpLength, NULL, 
	0, 0},  
	{kPslave, kAcctHost2, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "accthost2", TYPE_IP, kIpLength, NULL, 
	0, 0},  
	{kPslave, kSecret, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "secret", TYPE_STRING, kPasswordLength, NULL, 
	0, 0},  
	{kPslave, kRadTimeOut, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "radtimeout", TYPE_NUM, kIntLength, NULL, 
	0, 0},  
	{kPslave, kRadRetries, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "all", "radretries", TYPE_NUM, kIntLength, NULL, 
	0, 0},  
*/
	//[RK]Dec/02/05 - use this to enable all ports 
	{kPslave, kTty, PSLAVE_FILE, EnableAllPorts, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPslave, kServerFarm, PSLAVE_FILE, RdWrtPslave, 
	NULL, NULL, "s", "alias", TYPE_STRING, kHostNameLength, NULL, 
	0, 0},
	{kPslave, kVirtualPortsInfo, PSLAVE_FILE, RdWrtVirtualPorts, 
	NULL, NULL, "s", "tty", TYPE_STRING, 0 , NULL, 
	0, 0},
	{kHostTable, kNumEntries, HOSTS_FILE, NULL, 
	ParseHostEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kHostTable, kHosts, HOSTS_FILE, RdWrtListEntries, 
	ParseHostEntry, WriteHostEntry, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPortsSpec, kPortBundle, NULL, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPasswd, kNumEntries, PASSWD_FILE, NULL, 
	ParseUserEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPasswd, kUsers, PASSWD_FILE, RdWrtListEntries, 
	ParseUserEntry, WriteUserEntry, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kStRoutes, kNumEntries, ST_ROUTES_FILE, NULL, 
	ParseStRoutesEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kStRoutes, kStRoutesInfo, ST_ROUTES_FILE, RdWrtListEntries, 
	ParseStRoutesEntry, WriteStRoutesEntry, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kRoutingTable, kNumEntries, WEB_TEMP_FILE, NULL, 
	ParseRoutingTableEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kRoutingTable, kRoutingTableEntry, WEB_TEMP_FILE, RdWrtListEntries, 
	ParseRoutingTableEntry, WriteRoutingTableEntry, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kCycDateTime, kMthDayYrHrMinSec, NULL, RdWrtDateTime,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kCycDateTime, kTimezone, NTPCLIENT_SHELL, RdWrtShellVar, 
	NULL, NULL, NULL, "TIMEZONE", TYPE_STRVAR, 0, NULL, 
	0, 0},
	{kCycDateTime, kTzParams, NTPCLIENT_SHELL, RdWrtTimezone, 
	NULL, NULL, NULL, "TZPARAMS", TYPE_STRVAR2, 0, NULL, 
	0, 0},
	{kPcmcia, kNumPcmciaSlots, NULL, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPcmcia, kPcmciaInfo, NULL, GetPcmciaInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPcmcia, kUnitPcmciaInfo, NULL, GetPcmciaInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kBootManagement, kBootConf, NULL, RdWrtBootConf, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kIpSec, kNumIpSec, ETC_DIR, NULL, 
	ParseIpSecEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kIpSec, kIpSecInfo, ETC_DIR, RdWrtIpSecEntries, 
	ParseIpSecEntry, WriteIpSecEntry, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kIpSec, kIpSecPubKey, IPSEC_SECRET_FILE, RdWrtIpSecRSA, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kMacAddress, NULL, RdSwVersionModel, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kUnitVersionInfo, PROC_VERSION_FILE, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kDate, NULL, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kUpTime, NULL, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kPwrSupplyInfo, DEV_LED_FILE, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kInterfacesInfo, WEB_TEMP_FILE, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kCpuInfo, PROC_CPU_FILE, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kMemInfo, PROC_MEM_FILE, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kNumEntries, WEB_TEMP_FILE, NULL, 
	ParseRamDiskInfo, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kUnitInfo, kRamDiskInfo, WEB_TEMP_FILE, RdWrtListEntries, 
	ParseRamDiskInfo, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
        /*[LMT]  Security Enhancements*/
        {kInetd, kTelnetEnable, INETD_FILE, RdWrtCommentLineEntry,
        NULL, NULL, telnet_cmd, "telnet", TYPE_STRLINE, 0, NULL,
        0, 0},
        /*[LMT]  Security Enhancements*/
        {kInetd, kFtpEnable, INETD_FILE, RdWrtCommentLineEntry,
        NULL, NULL, ftp_cmd, "ftp", TYPE_STRLINE, 0, NULL,
        0, 0},
#ifdef ONS
        /*[LMT]  Security Enhancements*/
        {kInetd, kTftpEnable, INETD_FILE, RdWrtCommentLineEntry,
        NULL, NULL, tftp_cmd, "tftp", TYPE_STRLINE, 0, NULL,
        0, 0},
#endif
        /*[LMT]  Security Enhancements*/
        {kSnmpdSettings, kSnmpdEnable, SNMPD_SHELL, RdWrtShellVar,
        NULL, NULL, NULL, "ENABLE", TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
        {kIpSec, kIpSecEnable, IPSEC_SHELL, RdWrtShellVar,
        NULL, NULL, NULL, "ENABLE", TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
        {kPortMap, kRpcEnable, PORTMAP_SHELL, RdWrtShellVar,
        NULL, NULL, NULL, "ENABLE", TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
        {kSecProfiles, kIcmpEnable, SECURITY_SHELL, RdWrtSecOptVar,
        NULL, NULL, NULL, "icmp", TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
        {kSshd, kSshdOpt, SSHD_SHELL, RdWrtSshShell,
        NULL, NULL, NULL, "ENABLE", TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
        {kSecProfiles, kSecOpt, SECURITY_SHELL, RdWrtSecOptProfPorts,
        NULL, NULL, NULL, "profports", TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
        {kWebUI, kWebUIOpt, WEBUI_SHELL, RdWrtWebUiShell,
        NULL, NULL, NULL, NULL, TYPE_LISTVAR, 0, EnableOptions,
        SIZE_EnableOptions, 0},
        /*[LMT]  Security Enhancements*/
	{kPortsSpec, kDeleteEntry, PSLAVE_FILE, RemSpecPslaveParam, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
#if defined(KVM) || defined(ONS)
	{kUnitInfo, kKVMPortStatus, NULL, RdUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kUnitInfo, kKVMBoard, NULL, RdUnitInfo,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kUnitInfo, kFanStatus, NULL, RdUnitInfo,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
#endif
	{kActiveSessions, kNumEntries, WEB_TEMP_FILE, RdWrtListEntries, 
	ParseActiveSessionEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kActiveSessions, kActiveSessionInfo, WEB_TEMP_FILE, RdWrtListEntries, 
	ParseActiveSessionEntry, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kTs110, kDigitalStatus, NULL, RdTs110Info, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kTs110, kAnalogStatus, NULL, RdTs110Info, 
	NULL, NULL, NULL, NULL, TYPE_STRING, kAnalogStatusLength, NULL, 
	0, 0},
	{kSnmpdSettings, kSysContact, SNMPD_FILE, RdWrtSysInfoSnmpdConf, 
	NULL, NULL, NULL, "syscontact", TYPE_STRING, kInfoLength, NULL, 
	0, 0},
	{kSnmpdSettings, kSysLocation, SNMPD_FILE, RdWrtSysInfoSnmpdConf, 
	NULL, NULL, NULL, "syslocation", TYPE_STRING, kInfoLength, NULL, 
	0, 0},
	{kSnmpdSettings, kNumCommunityEntries, SNMPD_FILE, RdWrtConfigSnmpdConf, 
	ParseCommunityInfo, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kSnmpdSettings, kCommunityInfo, SNMPD_FILE, RdWrtConfigSnmpdConf, 
	ParseCommunityInfo, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kSnmpdSettings, kNumSnmpv3Entries, SNMPD_FILE, RdWrtConfigSnmpdConf, 
	ParseSnmpv3Info, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kSnmpdSettings, kSnmpv3Info, SNMPD_FILE, RdWrtConfigSnmpdConf, 
	ParseSnmpv3Info, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kNis, kNisInfo, NULL, RdWrtNisConfiguration, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NisAuthOptions,
  	SIZE_NisAuthOptions, 0},
	{kNis, kNisEnable, NIS_SHELL, RdWrtShellVar, 
	NULL, NULL, NULL, "ENABLE", TYPE_LISTVAR, 0, EnableOptions, 
	SIZE_EnableOptions, 0},
	{kNtp, kNtpEnable, NTPCLIENT_SHELL, RdWrtShellVar, 
	NULL, NULL, NULL, "ENABLE", TYPE_LISTVAR, 0, EnableOptions, 
	SIZE_EnableOptions, 0},
	{kNtp, kNtpServer, NTPCLIENT_SHELL, RdWrtShellVar, 
	NULL, NULL, "-h ", "NTPSERVER", TYPE_STRVAR, 0, NULL, 
	0, 0},
	{kSyslogNg, kNumEntries, SYSLOG_NG_FILE, NULL, 
	ParseSyslogServerEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kSyslogNg, kSyslogServer, SYSLOG_NG_FILE, RdWrtSyslogServerEntry, 
	NULL , NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kSyslogNg, kNumNotificationEntries, SYSLOG_NG_FILE, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kSyslogNg, kNotificationInfo, SYSLOG_NG_FILE, RdWrtNotificationEntry, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kSyslogNg, kNotificationType, NULL, NULL, 	// Do nothing
	NULL, NULL, NULL, NULL, 0, 0, NULL, 
	0, 0},
	{kSyslogNg, kSyslogBufServer, SYSLOG_NG_FILE, RdWrtSyslogBufServerEntry, 
	NULL , NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kSyslogNg, kLogDestEnable, SYSLOG_NG_FILE, RdWrtSyslogDestEnable,
	NULL , NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
	{kSyslogNg, kLogFilterlevel, SYSLOG_NG_FILE, RdWrtSyslogFilterEntry,
	NULL , NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},

#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
	// IP CHAINS
	{kIpChains, kIpChainsNum, WEB_TEMP_FILE, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kIpChains, kIpChainsInfo, NULL, RdWrtIpChainsInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kIpChains, kIpChainsRuleInfo, NULL, RdWrtIpChainsRuleInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
#else
	// IP Tables
	{kIpTables, kIpTablesFilterChainNum, WEB_TEMP_FILE, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kIpTables, kIpTablesFilterChainInfo, NULL, RdWrtFilterChainInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
   {kIpTables, kIpTablesFilterChainRuleInfo, NULL, RdWrtFilterChainRuleInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kIpTables, kIpTablesNatChainNum, WEB_TEMP_FILE, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kIpTables, kIpTablesNatChainInfo, NULL, RdWrtNatChainInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kIpTables, kIpTablesNatChainRuleInfo, NULL, RdWrtNatChainRuleInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
#endif
	{kMenuShCfg, kMenuShInfo, MENUSH_CFG_FILE, RdWrtMenuShInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kMenuShCfg, kNumMenuShOpt, MENUSH_CFG_FILE, RdWrtMenuShInfo, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kMenuShCfg, kMenuShTitle, MENUSH_CFG_FILE, RdWrtMenuShInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kMenuShCfg, kMenuShNum, MENUSH_CFG_FILE, RdWrtMenuShInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kLdapConf, kLdapInfo, LDAP_CONF_FILE, RdWrtLdapInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kKrb5Conf, kKrbInfo, KRB5_CONF_FILE, RdWrtKrbInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kRadiusConf, kRadiusInfo, RADIUS_CONF_FILE, RdWrtRadiusInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kTacplusConf, kTacplusInfo, TACPLUS_CONF_FILE, RdWrtTacplusInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kSmbConf, kSmbInfo, SMB_CONF_FILE, RdWrtSmbInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPslave, kPhysPortsConf, PSLAVE_FILE, WritePhysPortConf, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	
	// Power Management application
	{kPowerMgm, kNumPorts, NULL, RdPmNumPorts, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPowerMgm, kPortInfo, NULL, RdPmPortInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kOutletInfo, NULL, RdPmOutletInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduSerPortNumber, NULL, NULL, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduConfSyslog, NULL, RdWrtPmIpduConf, 
	NULL, NULL, NULL, PMCOMM_SYSLOG, TYPE_NUM, 0, NULL, 
	0, 0},  
	{kPowerMgm, kIpduConfBuzzer, NULL, RdWrtPmIpduConf, 
	NULL, NULL, NULL, PMCOMM_BUZZER, TYPE_NUM, 0, NULL, 
	0, 0},  
	{kPowerMgm, kIpduConfOverCurrent, NULL, RdWrtPmIpduConf, 
	NULL, NULL, NULL, PMCOMM_CURRPROTECTION, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduUnitNumber, NULL, WrtPmIpduNumber, 
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduUnitInfo, NULL, RdPmIpduUnitInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduUnitAlarm, NULL, RdWrtPmIpduUnitAlarm, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduUnitCurrent, NULL, RdPmIpduUnit, 
	NULL, NULL, NULL, PMCOMM_CURRENT, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduUnitTemperature, NULL, RdPmIpduUnit, 
	NULL, NULL, NULL, PMCOMM_TEMPERATURE, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kIpduUserMgm, PSLAVE_FILE, RdWrtPmIpduUserMgm, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kPowerMgm, kFirmUpgradeVersion, NULL, RdPmFirmUpgradeVersion, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0},
	{kLoadKey, kLoadPubKey,NULL, wrPublicKey, 
	NULL, NULL, NULL, NULL, 0, 0, NULL, 
	0, 0},
#if defined(KVM) || defined(ONS) 
	{kKVM, kKVMDConf, NULL, RdWrtKVMD,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
	{kKVM, kKVMAccEntries, NULL, RdWrtKVMAccList,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kKVM, kKVMPermEntries, NULL, RdWrtKVMAccList,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kKVM, kKVMAccList, NULL, RdWrtKVMAccList,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
	{kKVM, kKVMCyclingEntries, NULL, RdWrtKVMCyclingList,
	 NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL, 0, 0},
	{kKVM, kKVMCyclingLists, NULL, RdWrtKVMCyclingList,
	 NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 0, 0},
	{kKVM, kKVMAuxPort, NULL, kvm_auxport_read_write_config,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
	{kKVM, kKVMMaxOutlet, NULL, kvm_read_numofoutlet,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kKVMCascading, kKVMCascNumDevices, NULL, kvm_cascade_read_numdevices,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kKVMCascading, kKVMCascConf, NULL, kvm_cascade_read_write_config,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
#if 0
	{kKVMGroup, kNumEntries, KVMGROUP_FILE, NULL,
	ParseKVMGroupsEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kKVMGroup, kKVMGroups, KVMGROUP_FILE, RdWrtListEntries,
	ParseKVMGroupsEntry, WriteKVMGroupsEntry, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
#else
	{kKVMGroup, kNumEntries, GROUP_FILE, NULL,
	ParseKVMGroupsEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kKVMGroup, kKVMGroups, GROUP_FILE, RdWrtListEntries,
	ParseKVMGroupsEntry, WriteKVMGroupsEntry, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
#endif
#endif /* KVM */

#ifdef IPMI
//[RK]Dec/22/04 - IPMI config
	{kIPMIDevice, kNumEntries, IPMI_CONF_FILE, NULL,
	ParseIPMIDeviceEntry, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},
	{kIPMIDevice, kIPMIDeviceInfo, IPMI_CONF_FILE, RdWrtIPMIDeviceInfo,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
#endif

#ifdef RDPenable
	{kRDPDevices, kRDPDevConf, NULL, RdWrtRDP,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},
#endif	//RDPenable

	//get number of multi outlet device
	{kPowerMgm, kNumMultiDev, NULL, GetNumMultiDev,
	NULL, NULL, NULL, NULL, TYPE_NUM, 0, NULL,
	0, 0},

	//get some further information about the multidevice: alias, serial port and outlets
	{kPowerMgm, kMultiDevInfo, NULL, GetMultiDevInfo,
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},

	//get some further information about one specific multi outlet device 
	{kPowerMgm, kMultiDevOutletInfo, NULL, GetMultiDevOutletInfo, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL,
	0, 0},

	// Online Help configuration
	{kOnlineHelpConf, kOnlineHelp, NULL, RdWrtOnlineHelp, 
	NULL, NULL, NULL, NULL, TYPE_STRING, 0, NULL, 
	0, 0}
};


//========================================================================
//  Start/stop daemons definitions
//========================================================================

typedef struct _FileBuffer {
	short  len;
	short  max;
	char   buf[4];
} FileBuffer;

#define BUF_CUSHION1 124
#define BUF_CUSHION2 300


//========================================================================
// CheckValidity - Check whether there is a match between the Category
// and the Key in catKeyList structure
//========================================================================
void *CheckValidity(CycParam *paramList) 
{
	int i;
	CycCatKeyTable *pList = NULL;

	for (i=0, pList=&catKeyList[0]; i<SIZE_catKeyList; i++, pList++) 
	{
		//dolog("%s:Current index is: %s, cat = %d, key = %d", __func__, pList->name ? pList->name : "null", pList->category, pList->key);
		if ((paramList->category == pList->category) && //Found a category. Now check key. 
		     (paramList->key == pList->key)) {
			dolog("%s:Current index found is: %s", __func__,pList->name);
			return pList;
		}		
	} 
	dolog("%s:Did NOT find a match between category and key",__func__);
	return(NULL);
}

//========================================================================
// CheckGetNumEntries - Check to see if current parameter requires  
// obtaining the number of entries. If so, call function to get it.
//========================================================================
static int CheckGetNumEntries(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	dolog("CheckGetNumEntries()");

	switch (paramList->key)
	{
		case kNumEntries:
			*((int*)paramList->value) = 0; 
			ReadEntries(pCkIndex, paramList, 1);
			return 1;
		case kNumPcmciaSlots:
			*(int *)paramList->value = GetNumOfPcmciaSlot();
			return 1;
		case kNumIpSec:
			*((int*)paramList->value) = 0; 
			ReadIpSecEntries(pCkIndex, paramList, 1);
			return 1;
		case kNumCommunityEntries:
		case kNumSnmpv3Entries:
			*((int*)paramList->value) = 0; 
			RdWrtConfigSnmpdConf(pCkIndex, paramList, 0);	
			return 1;
		case kNumNotificationEntries:
			*((int*)paramList->value) = 0; 
			GetNumNotificationEntries(pCkIndex,paramList);
			return 1;
#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
		case kIpChainsNum:
			*((int*)paramList->value) = 0; 
			GetIpChainsNum(pCkIndex,paramList);
			return 1;
#else
		case kIpTablesFilterChainNum:
			*((int*)paramList->value) = 0; 
			GetIpTableChainNum(pCkIndex,paramList,"filter");
			return 1;
		case kIpTablesNatChainNum:
			*((int*)paramList->value) = 0; 
			GetIpTableChainNum(pCkIndex,paramList,"nat");
			return 1;
#endif
#if defined(KVM) || defined(ONS)
		case kKVMCascNumDevices:
			*((int*)paramList->value) = 0;
			kvm_cascade_read_numdevices (pCkIndex, paramList, 0);
			return 1;
#endif
		default:
			break;
	}
	return 0;
}

//========================================================================
// CycGet - Main API gets the parameters that tells what information
// to read and returns it so that the information can be displayed in web
//========================================================================
Result CycGet(CycParam *paramList, UInt32 collectionSize)
{
	//UInt16 numOfNextParams = 0;
	PortBundle *pPortBundle = NULL;
	CycCatKeyTable *pCatKeyIndex = NULL;
	Result result = kCycSuccess;

	/*warning: unsigned int format, pointer arg (arg 2)
	dolog("\nCycGet() paramList=%x size=%d ",paramList,collectionSize);*/
	dolog("\nCycGet() paramList=%x size=%d ",(UInt32)paramList, (int)collectionSize);

	portsArray = NULL;
	
	while(collectionSize > 0) 
	{
		dolog("\nCycGet() Cat=%d key=%d size=%d ",paramList->category, paramList->key,paramList->collectionSize);
		//check if category/key is valid
		if ((pCatKeyIndex = CheckValidity(paramList)) == NULL) 
		{
			return kInvalidKeyForCategory;
		}

		//check if portSpec/Port pair
		if ((paramList)->category == kPortsSpec)
		{
			if (paramList->key == kPortBundle) {
				// Set up when ports are specified 
				dolog("CycGet(): Ports specified");
				pPortBundle = (PortBundle *)paramList->value;
				portsArray = pPortBundle->ports;
			}
			collectionSize--;
			paramList++;
			continue;
		} 

		// check Power Management
		if ((paramList)->category == kPowerMgm) {
		       if (paramList->key == kIpduSerPortNumber) {
				gPmIpduPort = *(int *) paramList->value;
			} else {
				if ((result=((*(pCatKeyIndex->getParamRoutine)) (pCatKeyIndex, paramList, 0))) != kCycSuccess) {
					gPmIpduPort = gPmIpduUnitNumber = -1;
					return(result);
				}
			}
			collectionSize--;
			paramList++;
			continue;
		}

		if (CheckGetNumEntries(pCatKeyIndex, paramList))
		{
			collectionSize--;
			paramList++;
			if (collectionSize) continue;
			return kCycSuccess;
		}

		//call appropriate routine to parse file and get the value for the parameter
		if (pCatKeyIndex->getParamRoutine != NULL)
		{
			// Fix for bug #2063 - Make sure signal_ras hup is already done executing
			while (shm_get_set_val(0, &cy_shm->st_cy_ras, 0, CY_SEM_CONFIG) == 2) {
				sleep(1);
				continue;
			}
   		
			(*(pCatKeyIndex->getParamRoutine)) (pCatKeyIndex, paramList, 0);
		}
				
		//increment ptr in list and loop
		collectionSize--;
		paramList++;
	}
	portsArray = NULL;
	gPmIpduPort = gPmIpduUnitNumber = -1;
	return result;
}

//========================================================================
// CycCancel - API that cancels any temporary changes made. Reflash 
// config files, overwriting any temporary changes.
//========================================================================
Result CycCancel(void)
{
	rename("/etc/kvm", "/etc/kvm.bak");
	system("restoreconf");
	/* actually, we should do this only if restoreconf was successful: */
	system("rm -rf /etc/kvm.bak"); 
	system("signal_ras hup");
	system("daemon.sh");
	system("killall -hup kvmd");
	system("iptables-restore </etc/network/firewall");

	return (kCycSuccess);
}

//========================================================================
// CycSet - 2nd Main API sets the new value passed in to the appropriate
// file and executes either signal_ras or saveconf
//========================================================================
Result CycSet(CycParam *paramList, UInt32 collectionSize, CycSetAction action)
{
	//int numOfNextParams = 0;
	PortBundle *pPortBundle = NULL;
	CycCatKeyTable *pCatKeyIndex = NULL;
	Result result = kCycSuccess;
	SInt8 spec_deleted=0;
		
	dolog("\nCycSet()");

	portsArray = NULL;
	while(collectionSize > 0) 
	{
		//check if category/key is valid
		if ((pCatKeyIndex = CheckValidity(paramList)) == NULL) 
		{
			return kInvalidKeyForCategory;
		}

		//check if portSpec/Port pair
		if ((paramList)->category == kPortsSpec)
		{
			switch (paramList->key) {
				case kDeleteEntry :
					// to delete specific parameters
					if (!spec_deleted) {
						spec_deleted = 1;
						RemSpecPslaveParam(pCatKeyIndex);
					}
					break;
				case kPortBundle :
					dolog("CycSet(): Ports specified");
					pPortBundle = (PortBundle *)paramList->value;
					portsArray = pPortBundle->ports;
					break;
				default : break;

			}
		} else	{
			//call appropriate routine to parse file and get the value for the parameter
			// check Power Management
			if (((paramList)->category == kPowerMgm) && 
				(paramList->key == kIpduSerPortNumber)) {
				gPmIpduPort = *(int *) paramList->value;
				collectionSize--;
				paramList++;
				continue;
			}
			if (pCatKeyIndex->getParamRoutine)
			{
				// !!! Check validity of value !!! 
				(*(pCatKeyIndex->getParamRoutine)) (pCatKeyIndex, paramList, 1);
			}
		}
		//increment ptr in list and loop
		collectionSize--;
		paramList++;
	}
	
	if (action == kTryForced || action == kSetForced) {
		executeFlg |= EXE_SIGNAL_RAS | EXE_DAEMON_SH | EXE_FIREWALL;
	}

	if (action != kWrite) {
		if (executeFlg & EXE_SIGNAL_RAS)
		{
			dolog("Call signal_ras hup");
			system("signal_ras hup");
			executeFlg &= ~EXE_SIGNAL_RAS;
			usleep(1500000); //mp: for some files to get created
		} 

        if (executeFlg & EXE_SIGHUP_KVM)
        {
            dolog("signal_hup to kvm");
            system("killall -HUP kvmd");
            executeFlg &= ~EXE_SIGHUP_KVM;
        }
	}

	if (executeFlg & EXE_FIREWALL)
	{
#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
		dolog("ipchains-save > /etc/network/firewall");
#else
#ifdef KVM
		system("iptables-save --table filter > /etc/network/firewall");
#else
		system("iptables-save > /etc/network/firewall");
#endif
#endif
        executeFlg &= ~EXE_FIREWALL;
	}

	if (action == kSet || action == kSetForced)
	{
		dolog("Call saveconf");
		system("saveconf");
	} 

	if (action != kWrite) {
		if (executeFlg & EXE_DAEMON_SH)
		{
			dolog("Call daemon.sh");
			system("daemon.sh");
			executeFlg &= ~EXE_DAEMON_SH;
		}
    }

	portsArray = NULL;
	gPmIpduPort = gPmIpduUnitNumber = -1;
	return (result);
}

//========================================================================
// write_file: write the content of a buffer to a file
//========================================================================
static void write_file(FileBuffer *buf, char * fn)
{
	int fd;

	if ((fd = open (fn, O_TRUNC | O_WRONLY)) < 0) {
		dolog("write_file[%s]/open: %s", fn, strerror(errno));
		return;
	}

	if (write(fd, buf->buf, buf->len) != buf->len) {
		dolog("write_file[%s]/write: %s", fn, strerror(errno));
	}

	close(fd);
}

//========================================================================
// read_file: read an entire file into an allocated  FileBuffer struct
//========================================================================
static FileBuffer *read_file(char *fn)
{
	struct stat st;
	int fd;
	FileBuffer *buf;

	// we will first read the file in a buffer
	if (stat(fn, &st)) {
		dolog("read_file[%s]/stat: %s", fn, strerror(errno));
		return(NULL);
	}

	if ((buf = (FileBuffer *)malloc(st.st_size+BUF_CUSHION2)) == NULL) {
		dolog("read_file[%s]/maloc: %s", fn, strerror(errno));
		return(NULL);
	}
	if ((fd = open (fn, O_RDONLY)) < 0) {
		dolog("read_file[%s]/open: %s", fn, strerror(errno));
		free(buf);
		return(NULL);
	}

	if (read(fd, buf->buf, st.st_size) != st.st_size) {
		dolog("read_file[%s]/read: %s", fn, strerror(errno));
		free(buf);
		close(fd);
		return(NULL);
	}

	*(buf->buf+st.st_size) = 0;
	buf->len = st.st_size;
	buf->max = st.st_size + BUF_CUSHION2;
	close(fd);
	return(buf);
}

//========================================================================
// ReadFile: read an entire file into a buffer and then return buffer
//========================================================================
static unsigned char *ReadFile(unsigned char *filename, int write)
{
	FILE *fp;
	int size; 
	unsigned char *buf;
	struct stat st;

	if (stat(filename, &st) != 0) 
	{
		LogError(FILE_STAT_ERROR, filename);
		return (NULL);
	}
	size=st.st_size+1;
	if (write) size*=2;
	buf = (unsigned char *)malloc(size);
	if (buf == NULL) 
	{
		LogError(MALLOC_FAIL, size);
		return (NULL);
	}
	fp = fopen(filename, "r");
	if (fp==NULL) 
	{
		free(buf);
		LogError(FILE_READ_ERROR, filename);
		return (NULL);
	}
	fread(buf, 1, st.st_size+1, fp);
	*(buf+st.st_size)=0;
	fclose(fp);

	return (buf);
}

//========================================================================
// search_var: searches for a string inside the struct FileBuffer. the
//             search is always done in the beginning of the line.
//
//  flgSearch:  0 - look for "Name"
//              1 - look for "#name"
//	2 - look for "<space>Name"
//========================================================================
static char *search_var(FileBuffer *buf, char *Name, int flgSearch)
{
	int i = 0, len = strlen(Name);
	int flag = 0;
	char *p = buf->buf;

	do {
		switch (flag) {
		case 0:	
			if (flgSearch==1) {
				if (*p == '#') {
					i++;
					p++;
				} else {
					flag = 1;
				}
			} else if (flgSearch==2) {
				while (*p && isspace(*p)) {
					i++;
					p++;
				}
			}
			if (!flag) {
				if (!strncmp(Name, p, len)) {
					return(flgSearch ? p-1 : p);
				}
				flag = 1;
				continue;
			}
			break;
		case 1:
			if (*p == '\n' || *p == '\r') {
				flag = 2;
			}
			break;
		case 2:
			if (*p != '\n' && *p != '\r') {
				flag = 0;
				continue;
			}
			break;
		}

		i++;
		p++;
		
	} while (i < buf->len);

	return(NULL);
}

//========================================================================
// search_var_within_section: searches for a string (or the data) within 
// the section passed in. Some files are separated into sections and they 
// are distinguished by indentations. For example:
//
//                           Start of section1
//                               data1 in section1
//                               data2 in section1
//                           Start of section2
//                               data1 in section2
// flgSearch = 0 : end of data is signal by non indented text which is 
//                 the start of another section
// flgSearch = 1 : don't care about where the end of the data is
// SG 10/1504 - Actually this flag is used to allow or not spaces at the 
// beggining
//                                     
//========================================================================
static char *search_var_within_section(char *pos, FileBuffer *buf, char *Name, int flgSearch)
{
	int i = 0, len = strlen(Name);
	int flag = 0;

	i = pos - buf->buf;

	if (i >= buf->len)
		return (NULL);

	// Skip first line which is the indicator of 
	// the beginning of a section
	while(*pos != '\r' && *pos != '\n' && i < buf->len) {
		pos++;
		i++;
	}
	while((*pos == '\r' || *pos == '\n') && i < buf->len) {
		pos++;
		i++;
	}

	do {
		switch (flag) {
		case 0:	
			if (!flgSearch  && !isspace(*pos)) 
			{
				return (NULL);
			} 
			else 
			{
				while (*pos && isspace(*pos)) 
				{
					i++;
					pos++;
				}
			}
			if (!flag) {
				if (!strncmp(Name, pos, len)) {
					return(pos);
				}
				flag = 1;
			}
			break;
		case 1:
			if (*pos == '\n' || *pos == '\r') {
				flag = 2;
			}
			break;
		case 2:
			if (*pos != '\n' && *pos != '\r') {
				flag = 0;
				continue;
			}
			break;
		}

		i++;
		pos++;
		
	} while (i < buf->len);

	return(NULL);
}

//========================================================================
// search_var_within_line: searches for a string (or the data) within 
// the line passed in
//========================================================================
static char *search_var_within_line(char *pos, FileBuffer *buf, char *Name)
{
	int i = 0, len = strlen(Name);
	int flag = 0;

	i = pos - buf->buf;

	if (i >= buf->len)
		return (NULL);

	do {
		switch (flag) {
			case 0:	
				// skip spaces
				if (*pos == '\n' || *pos == '\r') {
					return(NULL);
				}
				while (*pos && isspace(*pos)) 
				{
					i++;
					pos++;
				}
				// @ start of some word or character
				if (!strncmp(Name, pos, len)) {
					return(pos);
				}
				break;
		}

		i++;
		pos++;
		
	} while (i < buf->len);

	return(NULL);
}


//========================================================================
// TransOptGetStr: gets the corresponding string for a value in the
//                 array of TranslateOptions.
//========================================================================
static char *TransOptGetStr(TranslateOptions *Op, int nOp, int value)
{
	TranslateOptions *p = Op;

	for( ; nOp--; p++) {
		if (p->optionEnum == value) {
			return(p->optionName);
		}
	}

	return(Op->optionName);
}

//========================================================================
// TransOptGetVal: gets the corresponding value for a string in the
//                 array of TranslateOptions.
//========================================================================
static int TransOptGetVal(TranslateOptions *Op, int nOp, char *str, int len)
{
	TranslateOptions *p = Op;

	for( ; nOp--; p++) {
		if (!strncmp(p->optionName, str, len)) {
			return(p->optionEnum);
		}
	}

	return(Op->optionEnum);
}

//========================================================================
// get_val_from_param:  gets the value from paramlist in a string format.
//========================================================================
static void get_val_from_param(char *val, CycCatKeyTable *pCkIndex, CycParam *ParamList)
{
	char *p;

	switch (pCkIndex->type) {
	case TYPE_LISTVAR:
		p = TransOptGetStr(pCkIndex->listOptions, pCkIndex->nOptions, *(int *)ParamList->value);
		break;
	case TYPE_STRVAR:
	case TYPE_STRVAR2:
		if (pCkIndex->defaultPrefix) {
			strcpy(val, pCkIndex->defaultPrefix);
			val += strlen(pCkIndex->defaultPrefix);
		}
		p = (char *)ParamList->value;
		break;
	case TYPE_STRLINE:
		p = pCkIndex->defaultPrefix;
		break;
	default:
		sprintf(val, "%d", *(int *)ParamList->value);
		return;
	}
	strcpy(val, p);
}

//========================================================================
// build_default_line:
//     build a default line when a string pCkIndex->Name is not
//     found in the file.
//========================================================================
static void build_default_line(char *line, CycCatKeyTable *pCkIndex, CycParam *ParamList)
{
	char val[BUF_CUSHION1];

	get_val_from_param(val, pCkIndex, ParamList);

	switch (pCkIndex->type) {
	case TYPE_STRVAR2:
		snprintf(line, BUF_CUSHION1, "%s=\"%s\"\n", pCkIndex->name, val);
		break;
	case TYPE_STRVAR:
		if (strchr(val, ' ')) {
			snprintf(line, BUF_CUSHION1, "%s=\"%s\"\n", pCkIndex->name, val);
		} else {
			snprintf(line, BUF_CUSHION1, "%s=%s\n", pCkIndex->name, val);
		}
		break;
	case TYPE_LISTVAR:
		snprintf(line, BUF_CUSHION1, "%s=%s\n", pCkIndex->name, val);
		break;
	case TYPE_STRLINE:
		strcpy(line, val);
		break;
	default:
		*line = 0;
	}
}

//========================================================================
// build_shell_line:
//     build a line when a with the name and value passed in
//========================================================================
static void build_shell_line(char *line, unsigned char *name, unsigned char *val, int flg)
{
	// flg = 0 : <name>="<val>"
	// flg = 1 : <name>=<val>
	// flg = 2 : <name> <val>

	switch (flg)
	{
		case 0:
			sprintf(line, "%s=\"%s\"\n", name, val);
			break;
		case 1:
			sprintf(line, "%s=%s\n", name, val);
			break;
		case 2:
			sprintf(line, "%s %s\n", name, val);
			break;
	}
}

//========================================================================
// delete_chars: delete a character 
//========================================================================
static void delete_chars(char *pos, FileBuffer *buf, int qtd)
{
	int i = pos - buf->buf;
	char *p;

	if (i + qtd > buf->len) {
		qtd = buf->len - i;
	}

	p = pos + qtd;

	qtd = buf->len - (p - buf->buf);
 
	if (qtd > 0) {
		memmove(pos, p, qtd);
	}
}

//========================================================================
// insert_line: Inserts a line in the FileBuffer struct.
//
//    flgIns: 0 - where pos is pointing to
//            1 - Next line after pos
//            2 - In the end of the FileBuffer
//========================================================================
static void insert_line(char *pos, FileBuffer *buf, char *line, int flgIns)
{
	char *p;
	int len = strlen(line);
	int i;

	//dolog("INSERT LINE: %s", line);
	//dolog("LINE LEN: %d", len);
	//dolog("buf->len: %d", buf->len);
	//dolog("buf->max: %d", buf->max);
	
	if (buf->len + len > buf->max) {
		/* we may realocate a bigger buffer */
		dolog("NOT ENOUGH SPACE");
		return;
	}

	if (flgIns == 2) {
		pos = buf->buf + buf->len;
	}

	if (flgIns == 1) {
		i = pos - buf->buf;
		while(*pos != '\r' && *pos != '\n' && i < buf->len) {
			pos++;
			i++;
		}
		while((*pos == '\r' || *pos == '\n') && i < buf->len) {
			pos++;
			i++;
		}
	}
	p = pos + len;
	i = buf->len - (pos - buf->buf); 
	if (i > 0) memmove(p, pos, i);
	memcpy(pos, line, len);
	buf->len += len;
}

//========================================================================
// replace_line: Replace a line in the FileBuffer struct.
//    flgIns: 0 - where pos is pointing to
//            1 - Next line after pos
//    numLines = number of lines you want to replace
// ex)        line1
//            line2
// You want to replace line1 with xxx, then numLines=1, and the result
// is         xxx
//            line2
//========================================================================
static void replace_line(char *pos, FileBuffer *buf, char *line, int numLines, int flgIns)
{
	char *p, *curr;
	int len = strlen(line);
	int i, deleteLen=0;

	if (buf->len + len > buf->max) {
		/* we may realocate a bigger buffer */
		dolog("NOT ENOUGH SPACE");
		return;
	}

	if (flgIns == 1) {
		i = pos - buf->buf;
		while(*pos != '\r' && *pos != '\n' && i < buf->len) {
			pos++;
			i++;
		}
		while((*pos == '\r' || *pos == '\n') && i < buf->len) {
			pos++;
			i++;
		}
	}
	curr = pos;	
	while(numLines--)
	{
		while(*curr != '\r' && *curr != '\n' && i < buf->len) {
			curr++;
			deleteLen++;
		}
		if((*curr == '\r' || *curr == '\n') && i < buf->len) {
			curr++;
			deleteLen++;
		}
	}
	delete_chars(pos, buf, deleteLen);
	//dolog("Pos: [%s]", pos);	
	p = pos + len;
	i = buf->len - (pos - buf->buf); 
	if (i > 0) memmove(p, pos, i);
	memcpy(pos, line, len);
	buf->len += len - deleteLen;
}

//========================================================================
// replace_Value: replace the value of the shell variable in the line
// flgSearch:  0 - replace value for line like: <parameter>="<value>"
//             1 - replace value for line like: <parameter> <value>
//========================================================================
static void replace_Value(char *line, FileBuffer *buf, char *val, int flgSearch)
{
	int len = strlen(val);
	int i, lenf, flag = 0;
	char *pos;

	dolog("replace_Value()");

	if (flgSearch & 3) {
		if ((pos = strchr(line, ' ')) == NULL) {
			/* should we build a default line ? */
			return;
		}
	} else {
		if ((pos = strchr(line, '=')) == NULL) {
			/* should we build a default line ? */
			return;
		}
	}
	
	line = ++pos;
	while (*pos && isblank(*pos)) {line = ++pos;}
	i = pos - buf->buf;

	if (i >= buf->len) {
		return;
	}

	while(i < buf->len && flag != 3) {
		switch (flag) {
		case 0:
			if (*pos == '"') {
				line++;
				flag=2;
			} else {
				flag = 1;
				continue;
			}
			break;
		case 1:
			if (*pos == '\r' || *pos == '\n' ||
				*pos == ' ' || *pos == '\t' || *pos == '#') {
				if(!((flgSearch & 4) && (*pos == ' '))){
					flag = 3;
					continue;
				}
			} 
			break;
/*              case 2:
			if (*pos == '"') {
				flag = 3;
				continue;
			}
			break;
		} */
                case 2:
                        if( (*pos == '"') && (flgSearch == 0) ) {
                                flag = 3;
                                continue;
                        }
                        if ( (*pos == '\r' || *pos == '\n') && (flgSearch == 1) ) {
                          line--;
                          flag = 3;
                          continue;
                        }
                        break;
                }

		pos++;
		i++;
	}

	lenf = pos - line;
	i = buf->len - (pos - buf->buf);

	if (lenf != len && i > 0) {
		memmove(line+len, pos, i);
	}

	memcpy(line, val, len);
	buf->len += len - lenf;
}

//========================================================================
// clearRestOfBuf: clear the rest of the buffer 
// flgSearch:  0 - clear the buffer starting from next line
//             1 - clear the buffer starting at position passed in
//========================================================================
/* WebApi.c:2019: warning: `clearRestOfBuf' defined but not used
static void clearRestOfBuf(char *line, FileBuffer *buf, int flagSearch)
{
	int i;
	char *p, *pos;

	dolog("clearRestOfBuf()");

	pos = line;

	i = pos - buf->buf;
	while(i < buf->len && !flagSearch) {
		if (*pos == '\r' || *pos == '\n' || *pos == ' ' || *pos == '\t') break;
		pos++;
		i++;
	}

	i = buf->len - (pos - buf->buf);
	p = pos + i;
	if (i>0) memmove(pos, p, i);

	buf->len = buf->len - i; 
}*/

//========================================================================
// get_value_from_line: gets the value from line and translates it to the
//                      proper paramlist format.
//========================================================================
static void get_value_from_line(char *line, FileBuffer *buf, CycCatKeyTable *pCkIndex, CycParam *ParamList)
{
	char *pos;
	int i, len, flag = 0;

	if (pCkIndex->type == TYPE_STRLINE) {
		if (*line != '#') {
			*(int *)ParamList->value = kYes;
		}
		return;
	}

	if ((pos = strchr(line, '=')) == NULL) {
		/* It was put 0 in the paramlist already */
		return;
	}
	line = ++pos;
	i = pos - buf->buf;
	
	if (i > buf->len) {
		return;
	}

	while(i < buf->len && flag != 3) {
		switch (flag) {
		case 0:
			if (*pos == '"') {
				line++;
				flag=2;
			} else {
				flag = 1;
				continue;
			}
			break;
		case 1:
			if (*pos == '\r' || *pos == '\n' ||
				*pos == ' ' || *pos == '\t' || *pos == '#') {
				flag = 3;
				continue;
			}
			break;
		case 2:
			if (*pos == '"') {
				flag = 3;
				continue;
			}
			break;
		}
		pos++;
		i++;
	}

	len = pos - line;

	switch (pCkIndex->type) {
	case TYPE_LISTVAR:
		*(int *)ParamList->value = TransOptGetVal(pCkIndex->listOptions, pCkIndex->nOptions, line, len);
		break;
	case TYPE_STRVAR:
	case TYPE_STRVAR2:
		if (pCkIndex->defaultPrefix) {
			if ((i = strlen(pCkIndex->defaultPrefix)) >= len) {
				i = 0;
			}
			strncpy(ParamList->value, line+i, len-i);
		} else {
			strncpy(ParamList->value, line, len);
		}
		*(char *)(ParamList->value+len) = '\0'; //terminates string
		break;
	default:
		*(int *)ParamList->value = atoi(line);
		return;
	}
}

// [GY]=====================================================================
// GetProfPortsOpts:
// Read security.opts configuration file
//
// ACS and ONS
// ssh2sport, telnet2sport, raw2sport, auth2sport: enabled = 1 | disabled = 0 
// **bidirect = 1(enable) or 0(disable) [LMT]
//
// KVM and ONS
// directaccess: enable = 1 | disable = 0
// profile: custom=1 | open=2 | moderate=3 | secured=4 (default==moderate)
//==========================================================================
int GetProfPortsOpts(CycParam *ParamList, char *file_name)
{
        SecOptions *prProfPorts;
        char buf[BUF_FILE];
        char *line;
        FILE *fd;
        unsigned short ctrl=0x0000;
        unsigned short mask=0x007f;
        int len, flg, ena_dis;

#ifdef KVM
        mask = 0x0050;
#else 
#ifndef ONS
        mask = 0x003f;
#endif
#endif

        prProfPorts=(SecOptions *)ParamList->value;

        if( (fd=fopen(file_name, "r")) == NULL ) {
          syslog(LOG_INFO,"Cannot open /etc/security.opts file.\n");
          return (kFileReadError);
        }

        while( fgets(buf, BUF_FILE, fd) ) {
          line=buf;
          flg=0;
          for( len=0; len < strlen(buf); len++ ) {
            if( isspace(*line) ) {
              line++;
              continue;
            }
            if( *line == '#' ) {
              flg=1;
              break;
            }
            else {
              if( isalnum(*line) ) {
                flg=2;
                break;
              }
              else {
                syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
                fclose(fd);
                return (kFileReadError);
              }
            }
          }
          if( flg == 0 || flg == 1 ) {
            continue;
          }

          flg=0;
          if( strstr(buf, "profile") != NULL ) {
              flg=6;
              ctrl=ctrl | 0x0010;
          } else if( strstr(buf, "icmp") != NULL ){
		      flg=7;
          }

#ifndef KVM
          if( strstr(buf, "ssh2sport") != NULL ) {
            flg=1;
            ctrl=ctrl | 0x0001;
          } else if( strstr(buf, "telnet2sport") != NULL ) {
              flg=2;
              ctrl=ctrl | 0x0002;
          } else if( strstr(buf, "raw2sport") != NULL ) {
              flg=3;
              ctrl=ctrl | 0x0004;
          } else if( strstr(buf, "auth2sport") != NULL ) {
              flg=4;
              ctrl=ctrl | 0x0008;
          } else if( strstr(buf, "bidirect") != NULL ){
              flg=5;
		      ctrl=ctrl | 0x0020;
		  } 
#endif

#if defined(ONS) || defined(KVM)
          if( strstr(buf, "directaccess") != NULL ) {
              flg=8;
              ctrl=ctrl | 0x0040;
          }
#endif

          if (flg == 0
#ifdef KVM
              || (flg >=1 && flg <= 5)
#else 
#ifndef ONS
              || (flg == 8)
#endif
#endif
			) {
              syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
              fclose(fd);
              return (kFileReadError);
		  }

          switch( flg ) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 8:
              if( strstr(buf, "enabled") != NULL ) {
                ena_dis=kYes;
              }
              else {
                if( strstr(buf, "disabled") != NULL ) {
                  ena_dis=kNo;
                }
                else {
                  syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
                  fclose(fd);
                  return (kFileReadError);
                }
              }
              switch( flg ) {
                case 1:
                  prProfPorts->ssh2sport=ena_dis;
                  break;
                case 2:
                  prProfPorts->telnet2sport=ena_dis;
                  break;
                case 3:
                  prProfPorts->raw2sport=ena_dis;
                  break;
                case 4:
                  prProfPorts->auth2sport=ena_dis;
                  break;
                case 5:
                  prProfPorts->bidirect=ena_dis;
                  break;
                case 8:
                  prProfPorts->directaccess=ena_dis;
                  break;
                default:
                  syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
                  fclose(fd);
                  return (kFileReadError);
              }
              break;
            case 6:
              if( strstr(buf, "open") != NULL ) {
                prProfPorts->profile=kSecOpen;
              } else if( strstr(buf, "moderate") != NULL ) {
                prProfPorts->profile=kSecModerate;
              } else if( strstr(buf, "secured") != NULL ) {
                prProfPorts->profile=kSecSecured;
              } else if( strstr(buf, "custom") != NULL ) {
                prProfPorts->profile=kSecCustom;
              } else {
                syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
                fclose(fd);
                return (kFileReadError);
              }
              break;
            case 7:
              break;
            default:
              syslog(LOG_INFO,"7 Invalid line in /etc/security.opts file %d.\n", flg);
              fclose(fd);
              return (kFileReadError);
          }
        }
        if( (ctrl & mask) != mask ) {
          syslog(LOG_INFO,"Some configuration parameter in /etc/security.opts file wasn't found.\n");
          fclose(fd);
          return (kFileReadError);
        }
/*
syslog(LOG_INFO,"****READ****prProfPorts->ssh2sport[0/1]=%d\n",prProfPorts->ssh2sport);
syslog(LOG_INFO,"****READ****prProfPorts->telnet2sport[0/1]=%d\n",prProfPorts->telnet2sport);
syslog(LOG_INFO,"****READ****prProfPorts->raw2sport[0/1]=%d\n",prProfPorts->raw2sport);
syslog(LOG_INFO,"****READ****prProfPorts->auth2sport[0/1]=%d\n",prProfPorts->auth2sport);
syslog(LOG_INFO,"****READ****prProfPorts->profile=%d\n",prProfPorts->profile);
syslog(LOG_INFO,"****READ****prProfPorts->bidirect[0/1]=%d\n",prProfPorts->bidirect);
syslog(LOG_INFO,"****READ****prProfPorts->directaccess[0/1]=%d\n",prProfPorts->directaccess);
*/
        fclose(fd);
        return (kCycSuccess);
}

//[LMT]========================================================================
// CheckLineParam:
//  Verify if between field and his value has only tabs or spaces
//========================================================================
int CheckLineParam(char *ln, char *prm, int len)
{
        short int flag = 0;

        for(ln+=len; ln < prm; ln++) {
                if((*ln != '\t') && (*ln != ' '))
                {
                        flag=1;
                        break;
                }
        }

        return flag;
}

//[LMT]========================================================================
// chkComment:
//  Verify if line is commented
//========================================================================
int chkComment(char *ln)
{
int len;

        for (len=0;len < strlen(ln); len++) {
                if((*ln == '\t') && (*ln == ' '))
                        continue;

                if(*ln == '#'){
                        return 0;
                }else
                        return -1;
                                      ln++;
        }

        return (kCycSuccess);
}

/*[GB]*********************************************************************************************
 parseintvalue - just parses a configline in the format parametername=value, reading only the value
 part, changing it to integer and returning it

 linefromfile - string in the format parametername = value (if there are spaces or not it wont
 matter

 returns the integer value that corresponds to the parameter, or -1 in case of error
**************************************************************************************************/
static int parseintvalue(char *linefromfile)
{
        //used to scan the limits for the integer value into the string
        char *p = linefromfile, *pf;

        //loof for the first digit
        while(((*p) > 0x39 || (*p) < 0x30) && (*p)) p++;
        if(!*p) return -1; //end of line and no number found

        pf = p; //ok, now look for the first non number to get the end of the value
        while(((*pf) <= 0x39 && (*pf) >= 0x30) && (*pf)) pf++;
        *pf = '\0'; //mark here as the final of the string

        return atoi( p );
}

//[LMT]========================================================================
// cp:
//  Used to copy a files
//========================================================================
#define BUFF_SIZE 512
#define INPUT_MODE  (O_RDONLY)
#define OUTPUT_MODE (O_WRONLY | O_CREAT)

int cp(char *from, char *to)
{
   int nbytes,
       status = -1,
       fd1 = 0,
       fd2 = 0;
   static char buffer[BUFF_SIZE];

   if (((fd1 = open(from,INPUT_MODE)) >= 0) &&
      ((fd2 = open(to,OUTPUT_MODE,S_IWRITE)) >= 0))
   {
      status = 0;
      while ((nbytes = read(fd1,buffer,BUFF_SIZE)) > 0)
         if (write(fd2,buffer,nbytes) != nbytes)
         {
            /* Write error */
            status = -1;
            break;       /* Write error */
         }

      /* Was there a read error? */
      if (nbytes == -1)
         status = -1;
   }

   if (fd1 >= 0)
      close(fd1);

   if (fd2 >= 0)
      close(fd2);

   return status;
}

//[LMT]========================================================================
// addConfigFiles:
//      Add path file on /etc/config_files
// Parameter: path file to add in /etc/config_files
// Return: Did not add path file = 0
//         Add path file = 1
//========================================================================
int addConfigFiles(char *path_file)
{
char buf[BUFF_SIZE];
FILE *fd;
struct stat finfo;
unsigned int flgExist = 0;

        //Copy default file if it does not exist
        if(stat("/etc/config_files", &finfo))
                cp("/etc/config_files.save","/etc/config_files");

        //Open /etc/config_files to looking for path file
        if( (fd=fopen("/etc/config_files", "a+")) == NULL ) {
                syslog(LOG_INFO,"Cannot open /etc/config_files file.\n");
                return (kFileReadError);
        }

        while(fgets(buf, BUF_FILE, fd)) {
                if(!strcmp(buf, path_file)) {
                        flgExist = 1; //Path file was found
                        break;
                }
        }

        //Write if path file was not found
        if(!flgExist) {
                fprintf(fd,"%s\n",path_file);
                fclose(fd);
                return 1;
        }

        fclose(fd);

        return 0;
}

//========================================================================
// RdWrtSecOptVar:
//  Reading and writing variables in a security options file. The
//  parameter ptr->name has the name of the shell variable.
//========================================================================
static Result RdWrtSecOptVar(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
        CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
        struct stat finfo;

        dolog("RdWrtSecOptVar()");

        //Write value of icmp inside of config file
        if(rdWrtFlg){
                //Verify if /etc/security.opts exists
                if(stat(pCkIndex->fileName, &finfo)) {
                        cp("/etc/security.opts.save",pCkIndex->fileName);

                        //Add path file in /etc/config_files
                        addConfigFiles("/etc/security.opts");
                }

                SetEchoOpts(*(int *)ParamList->value, pCkIndex->fileName, pCkIndex->name);
        }else{
                *(int *)ParamList->value = GetEchoOpts(pCkIndex->fileName, pCkIndex->name);
        }

        if((rdWrtFlg) && (!strncmp(pCkIndex->name,"icmp",4)))
                return (SetIcmpProc(!(*(int *)ParamList->value)));

        return (kCycSuccess);
}

//[LMT]===================================================================
// RdWrtSecOptProfPorts:
//  Reading and writing variables in a security options file. The
//  parameter ptr->name has the name of the shell variable.
//========================================================================
int flgFirst = 0; //Used to control and certificate it will run once.
static Result RdWrtSecOptProfPorts(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
        CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
        struct stat finfo;
        SecOptions *prProfPorts;

        prProfPorts = (SecOptions *)ParamList->value;

        dolog("RdWrtSecOptProfPorts()");

        //Write value of icmp inside of config file
        if(!rdWrtFlg){
                if(stat(pCkIndex->fileName, &finfo)){
                        prProfPorts->profile = 0;
#ifdef KVM
                        prProfPorts->ssh2sport = 0;
                        prProfPorts->telnet2sport = 0;
                        prProfPorts->raw2sport = 0;
                        prProfPorts->bidirect = 0;
                        prProfPorts->auth2sport = 0;
#else 
                        prProfPorts->ssh2sport = 1;
                        prProfPorts->telnet2sport = 1;
                        prProfPorts->raw2sport = 1;
                        prProfPorts->bidirect = 1;
                        prProfPorts->auth2sport = 0;
#endif
                        prProfPorts->directaccess = 0;
                }else
                        GetProfPortsOpts(ParamList, pCkIndex->fileName);
        }else{
                //Verify if /etc/security.opts exists
                if(stat(pCkIndex->fileName, &finfo)) {
                        cp("/etc/security.opts.save",pCkIndex->fileName);

                        //Add path file in /etc/config_files
                        addConfigFiles("/etc/security.opts");
                }

                SetProfPortsOpts(ParamList, pCkIndex->fileName);

                if(!flgFirst){
                        flgFirst++;
                        //Set profile
                        if(prProfPorts->profile != kSecCustom){
                                setProfile(prProfPorts->profile);
                        }
                }
                flgFirst = 0;
        }

        return (kCycSuccess);
}

//[LMT]========================================================================
// GetWebPortsServices:
// Read web ports from /etc/services. Receive 0 to HTTP and 1 to HTTPS  and
// return the port number defined or -1 if does not find.
//========================================================================
int GetWebPortsServices(short int httpService)
{
   FILE *fd;
   char *line, *param, buf[BUF_FILE],*httpSrv;
   int port;

        //Open /etc/services file and get icmp status
        if((fd = fopen("/etc/services", "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open /etc/services file.\n");
                return (-1);
        }

        if(!httpService) {
                httpSrv="www";
        }else
                httpSrv="https";

        while(fgets(buf, BUF_FILE, fd)) {
                if((line = strstr(buf, httpSrv)) != NULL) {
                        //Check if there is only space or tabs
                        param = buf;
                        if(param < line) {
                                if(CheckLineParam(param,line,0))
                                        continue;
                        }
                        //Get the port number
                        if((line=strtok(buf, "/")) != NULL){
                                        port=parseintvalue(line);
                        }
                }
        }

        fclose(fd);
        return port;
}

//[LMT]========================================================================
// SetWebValues:
// Set web parameter inside /etc/webui.conf
//========================================================================
#define nParam 6
int SetWebValues(char *file_name, CycParam *ParamList)
{
    FILE *fr, *fw;
    char buf[BUF_FILE], buf_tmp[BUF_FILE], *line;
    short int flgEOF=0;
    unsigned char wcontrol = 0x0, mask = 0x1;
    HttpOptions *prWeb;

        //The struct web was set by user
        prWeb = (HttpOptions *)ParamList->value;

        //Open /etc/webui.conf
        if((fr = fopen(file_name, "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", file_name);
                return (kFileReadError);
        }

        //Open temp file
        if((fw = fopen("/etc/daemon.d/.webui.conf_tmp", "w")) == NULL) {
                syslog(LOG_INFO,"Cannot open /etc/.webui.conf_tmp file.\n");
                return (kFileReadError);
        }

        //REad line of webui.conf
        while(fgets(buf, BUF_FILE, fr)) {
                strncpy(buf_tmp,buf,BUF_FILE-1);
                if((line = strstr(buf, "# do not touch the code below...")) != NULL)
                        flgEOF=1;

                if(!flgEOF){
                        //Check if line is commented
                        if(!chkComment(buf)) {
                                fprintf(fw,"%s",buf);
                                continue;
                        }

                        /*Check it is a valide variable
                        "HTTP_PORT","HTTPS_PORT","HTTPS","HTTP","SECLEVEL","SSLVER" */
                        if(!strcmp(strtok(buf,"="),fields_web[0])) {
                                fprintf(fw,"HTTP_PORT=\"-p %d\"\n",prWeb->http_port);
                                wcontrol = wcontrol | 0x1;
                        }else if(!strcmp(strtok(buf,"="),fields_web[1])) {
                                fprintf(fw,"HTTPS_PORT=\"-P %d\"\n",prWeb->https_port);
                                wcontrol = wcontrol | 0x2;
                        }else if(!strcmp(strtok(buf,"="),fields_web[2])) {
                                if(!prWeb->https){
                                        fprintf(fw,"HTTPS=NO\n");
                                }else
                                        fprintf(fw,"HTTPS=YES\n");
                                wcontrol = wcontrol | 0x4;
                        }else if(!strcmp(strtok(buf,"="),fields_web[3])) {
                                if(!prWeb->http){
                                        fprintf(fw,"HTTP=NO\n");
                                }else
                                        fprintf(fw,"HTTP=YES\n");
                                wcontrol = wcontrol | 0x8;
                        }else if(!strcmp(strtok(buf,"="),fields_web[4])) {
                                if(prWeb->redirect == 1){
                                        fprintf(fw,"SECLEVEL=\"-s 1\"\n");
                                }

                                wcontrol = wcontrol | 0x10;
                        }else if(!strcmp(strtok(buf,"="),fields_web[5])) {
                                //Comment line if not SSL V3
                        /*      if(!prWeb->ssl_version)
                                        fprintf(fw,"#SSLVER=\"-v 3\"\n");
                                else
                                        fprintf(fw,"SSLVER=\"-v 3\"\n"); */
                                wcontrol = wcontrol | 0x20;
                        }else
                                fprintf(fw,"%s",buf_tmp);

                }else{
                        //If some variable hadn't been wrote, now it will be wrote at the end of file
                        if(wcontrol < 0x2F) {
                                for(flgEOF=0; flgEOF < nParam; flgEOF++) {
                                        if( (wcontrol & mask) == 0 ) {
                                                switch ( mask ) {
                                                        case 0x1:
                                                                fprintf(fw,"HTTP_PORT=\"-p %d\"\n",prWeb->http_port);
                                                                break;
                                                        case 0x2:
                                                                fprintf(fw,"HTTPS_PORT=\"-P %d\"\n",prWeb->https_port);
                                                                break;
                                                        case 0x4:
                                                                if(!prWeb->https){
                                                                        fprintf(fw,"HTTPS=NO\n");
                                                                }else
                                                                        fprintf(fw,"HTTPS=YES\n");
                                                                break;
                                                        case 0x8:
                                                                if(!prWeb->http){
                                                                        fprintf(fw,"HTTP=NO\n");
                                                                }else
                                                                        fprintf(fw,"HTTP=YES\n");
                                                                break;
                                                        case 0x10:
                                                                if(prWeb->redirect == 1){
                                                                        fprintf(fw,"SECLEVEL=\"-s 1\"\n");
                                                                }
                                                                break;
                                                        case 0x20:
                                                                //Comment line if not SSL V3
                                                                /*if(!prWeb->ssl_version)
                                                                        fprintf(fw,"#SSLVER=\"-v 3\"\n");
                                                                else
                                                                        fprintf(fw,"SSLVER=\"-v 3\"\n");*/
                                                                break;
                                                        default:
                                                                break;
                                                }
                                        }
                                        mask = mask << 1;
                                }
                        }
                        fprintf(fw,"%s",buf_tmp);
                }
        }

        fclose(fr);
        fclose(fw);

        //Rename tem file to /etc/webui.conf
        rename("/etc/daemon.d/.webui.conf_tmp", file_name);

        executeFlg |= EXE_DAEMON_SH;

/*syslog(LOG_INFO,"****BEGIN WRITE(SetWebValues)****\n");
syslog(LOG_INFO,"****WRITE(file_name=[%s])****\n",file_name);
syslog(LOG_INFO,"****WRITE(prWeb->http_port=[%d])****\n",prWeb->http_port);
syslog(LOG_INFO,"****WRITE(prWeb->https_port=[%d])****\n",prWeb->https_port);
syslog(LOG_INFO,"****WRITE(prWeb->http=[%d])****\n",prWeb->http);
syslog(LOG_INFO,"****WRITE(prWeb->https=[%d])****\n",prWeb->https);
syslog(LOG_INFO,"****WRITE(prWeb->redirect=[%d])****\n",prWeb->redirect);
syslog(LOG_INFO,"****WRITE(prWeb->ssl_version=[%d])****\n",prWeb->ssl_version);
syslog(LOG_INFO,"****END WRITE(SetWebValues)****\n");*/

        return (kCycSuccess);
}

//[LMT]========================================================================
// SetSshValues:
// Set ssh parameter inside /etc/webui.conf and configuration file sshd
//========================================================================
int SetSshValues(char *file_name, CycParam *ParamList)
{
    FILE *fr, *fw;
    char buf[BUF_FILE],
         buf_tmp[BUF_FILE],
         file_name_cfg[BUF_FILE],
         file_name_tmp[BUF_FILE+4];
    char *line, *param;
    unsigned char wcontrol = 0x0, mask = 0x1;
    int nfield, flgSSHenable;
    SshdOptions *pSSH;
    #define nparam 3

syslog(LOG_INFO,"Set ssh %s file.\n", file_name);
        //The struct web was set by user
        pSSH = (SshdOptions *)ParamList->value;

        //Open /etc/sshd.conf
        if((fr = fopen(file_name, "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", file_name);
                return (kFileReadError);
        }

        //Open temp file
        if((fw = fopen("/etc/.sshd.conf_tmp", "w")) == NULL) {
                syslog(LOG_INFO,"Cannot open /etc/.sshd.conf_tmp file.\n");
                return (kFileReadError);
        }

        //REad line of webui.conf
        while(fgets(buf, BUF_FILE, fr)) {
                strncpy(buf_tmp,buf,BUF_FILE-1);

                //Check if line is commented
                if(!chkComment(buf)) {
                        fprintf(fw,"%s",buf);
                        continue;
                }

                if((line = strtok(buf,"=")) != NULL){
                        param = strtok(NULL, "=");
                }else
                        continue;

                /*Check it is a valide variable "ENABLE"*/
                if(!strncmp(line,"ENABLE",6)) {
                        if((!pSSH->sshv1) && (!pSSH->sshv2)){
                                fprintf(fw,"ENABLE=NO\n");
                                flgSSHenable = 0;
                                pSSH->sshv1 = 0;
                                pSSH->sshv2 = 0;
                        }else{
                                fprintf(fw,"ENABLE=YES\n");
                                flgSSHenable = 1;
                        }
                }else if(!strncmp(line,"ConfigFiles",11)) {
                        fprintf(fw,"%s",buf_tmp);
                        strncpy(buf, param, BUF_FILE-1);

                        param = buf;

                        if(((line = strchr(buf, ' ')) != NULL) ||
                          ((line = strchr(buf, '\t')) != NULL) ||
                          ((line = strchr(buf, '\n')) != NULL) ||
                          ((line = strchr(buf, '\r')) != NULL))
                                buf[line-param] = '\0';

                        strncpy(file_name_cfg, param, BUF_FILE-1);
                }else{
                        fprintf(fw,"%s",buf_tmp);
                }
        }

        fclose(fr);
        fclose(fw);

        //Rename tem file to /etc/sshd.conf
		rename("/etc/.sshd.conf_tmp", file_name);

		strncpy(file_name_tmp, file_name_cfg, BUF_FILE);
		strncat (file_name_tmp, ".tmp", 4);
        //Open configuration file of sshd
        if((fr = fopen(file_name_cfg, "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", file_name_cfg);
                return (kFileReadError);
        }

        //Open temp file
        if((fw = fopen(file_name_tmp, "w")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", file_name_tmp);
                return (kFileReadError);
        }

        //REad line of sshd_config
        while(fgets(buf, BUF_FILE, fr)) {
                strncpy(buf_tmp,buf,BUF_FILE-1);

                //Check if line is commented
                if(!chkComment(buf)) {
                        fprintf(fw,"%s",buf);
                        continue;
                }

                //"Protocol 2,1" "#Port 22" e "#PermitRootLogin yes"
                if(!strncmp(line, "Port", 4)) {
                        fprintf(fw, "Port %d\n",pSSH->port);
                        wcontrol = wcontrol | 0x1;
                }else if (!strncmp(line, "Protocol", 8)) {
                        if(flgSSHenable) {
                                if((pSSH->sshv1) && (pSSH->sshv2)) {
                                        fprintf(fw, "Protocol 2,1\n");
                                }else if((pSSH->sshv1) && (!pSSH->sshv2)) {
                                        fprintf(fw, "Protocol 1\n");
                                }else if((!pSSH->sshv1) && (pSSH->sshv2)) {
                                        fprintf(fw, "Protocol 2\n");
                                }
                        }else{
                                fprintf(fw,"%s",buf);
                        }
                        wcontrol = wcontrol | 0x2;
                }else if (!strncmp(line, "PermitRootLogin", 15)) {
                        if(!pSSH->rootAccess) {
                                fprintf(fw, "PermitRootLogin no\n");
                        }else
                                fprintf(fw, "PermitRootLogin yes\n");
                        wcontrol = wcontrol | 0x4;
                }else
                        fprintf(fw,"%s",buf);

        }

        fclose(fr);

        //If some variable hadn't been wrote, now it will be wrote at the end of file
        if (wcontrol < 0x7) {
                for(nfield=0; nfield < nparam; nfield++){
                        if( (wcontrol & mask) == 0 ) {
                                switch (mask) {
                                        case 0x1:
                                                fprintf(fw, "Port %d\n",pSSH->port);
                                                break;
                                        case 0x2:
                                                if(flgSSHenable) {
                                                        if((pSSH->sshv1) && (pSSH->sshv2)) {
                                                                fprintf(fw, "Protocol 2,1\n");
                                                        }else if((pSSH->sshv1) && (!pSSH->sshv2)) {
                                                                fprintf(fw, "Protocol 1\n");
                                                        }else if((!pSSH->sshv1) && (pSSH->sshv2)) {
                                                                fprintf(fw, "Protocol 2\n");
                                                        }
                                                }else{
                                                        fprintf(fw,"%s",buf);
                                                }
                                                break;
                                        case 0x4:
                                                if(!pSSH->rootAccess) {
                                                        fprintf(fw, "PermitRootLogin no\n");
                                                }else
                                                        fprintf(fw, "PermitRootLogin yes\n");
                                                break;
                                        default:
                                                syslog(LOG_INFO,"Fail on function's control SetSshValues()\n");
                                                break;
                                }
                        }
                        mask = mask << 1;
                }
        }

        fclose(fw);

        //Rename tem file to /etc/sshd.conf
{ int ret2 = rename(file_name_tmp, file_name_cfg);
syslog(LOG_INFO, "rename ret %d :: %d :: %s\r", ret2, errno, file_name_tmp);
}

        //Restart SSH service using daemon.sh
        executeFlg |= EXE_DAEMON_SH;
/*
syslog(LOG_INFO,"****BEGIN WRITE(SetSshValues)****\n");
syslog(LOG_INFO,"****WRITE(pSSH->port=[%d])****\n",pSSH->port);
syslog(LOG_INFO,"****WRITE(pSSH->sshv1=[%d])****\n",pSSH->sshv1);
syslog(LOG_INFO,"****WRITE(pSSH->sshv2=[%d])****\n",pSSH->sshv2);
syslog(LOG_INFO,"****WRITE(pSSH->rootAccess=[%d])****\n",pSSH->rootAccess);
syslog(LOG_INFO,"****END WRITE(SetSshValues)****\n");
*/
        return (kCycSuccess);
}
                                  
//[LMT]========================================================================
// GetSshValues:
// Read ssh parameter inside /etc/sshd.conf and configuration file of sshd that was set
// into sshd.conf ConfigFiles
//========================================================================
int GetSshValues(char *file_name, CycParam *ParamList)
{
        FILE *fd;
        char *line, *param, buf[BUF_FILE];
        struct stat finfo;
        SshdOptions *pSSH;
        int flgSSHenable;

        //Open /etc/security.opts file and get icmp status
        if((fd = fopen(file_name, "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", file_name);
                return (kFileReadError);
        }

        pSSH = (SshdOptions *)ParamList->value;

        while(fgets(buf, BUF_FILE, fd)) {
                //Check if line is not commented
                if(chkComment(buf)) {
                        //Parse of data
                        if((param = strtok(buf,"="))!=NULL) {
                                line = strtok(NULL,"=");
                        }else
                                continue;

                        if(!strcmp(param,"ENABLE")) {
                                if(!strncmp(line, "NO",2)) {
                                        pSSH->sshv1 = 0;
                                        pSSH->sshv2 = 0;
                                        flgSSHenable = 0;
                                }
                                else if(!strncmp(line, "YES",3)) {
                                        /*Set all variables to default
                                        values because normally /etc/sshd_config */
                                        pSSH->sshv1 = 1;
                                        pSSH->sshv2 = 1;
                                        pSSH->port = 22;
                                        pSSH->rootAccess = 1;
                                        flgSSHenable = 1;
                                }
                        }else if(!strcmp(param, "ConfigFiles")) {
                                strncpy(buf, line, BUF_FILE-1);

                                line = buf;

                              if(((param=strchr(buf, ' ')) != NULL) ||
                                ((param=strchr(buf, '\t')) != NULL) ||
                                ((param=strchr(buf, '\n')) != NULL) ||
                                ((param=strchr(buf, '\r')) != NULL)) {
                                  buf[param-line] = '\0';
                              }

                                break;
                        }
                }
        }

        fclose(fd);

        //Verify if sshd config file exists
        if(stat(line, &finfo)){
                return kFileStatError;
        }

        //Open sshd config file
        if((fd = fopen(line, "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", line);
                return (kFileReadError);
        }

        while(fgets(buf, BUF_FILE, fd)) {
                //If comments...
                if(!chkComment(buf))
                        continue;
                //get values
                if((line = strtok(buf, delim)) != NULL)
                        param = strtok(NULL, delim);
                else
                        continue;

                //"Protocol 2,1" "#Port 22" e "#PermitRootLogin yes"
                if(!strncmp(line, "Port", 4)) {
                        if((pSSH->port = parseintvalue(param)) == -1)
                                pSSH->port = 22; //default value
                }else if (!strncmp(line, "Protocol", 8)) {
                        if(flgSSHenable){
                                if(!strncmp(param, "2,1", 3)) {
                                        pSSH->sshv1 = 1;
                                        pSSH->sshv2 = 1;
                                }else if(!strncmp(param, "1", 1)) {
                                        pSSH->sshv1 = 1;
                                        pSSH->sshv2 = 0;
                                }else if(!strncmp(param, "2", 1)) {
                                        pSSH->sshv1 = 0;
                                        pSSH->sshv2 = 1;
                                }
                        }
                }else if (!strncmp(line, "PermitRootLogin", 15)) {
                        if(!strncmp(param, "yes", 3)) {
                                pSSH->rootAccess = 1;
                        }else if(!strncmp(param, "no", 2)){
                                pSSH->rootAccess = 0;
                        }
                }
        }

        fclose(fd);

/*syslog(LOG_INFO,"****BEGIN READ(GetSshValues)****\n");
syslog(LOG_INFO,"****READ(pSSH->port=[%d])****\n",pSSH->port);
syslog(LOG_INFO,"****READ(pSSH->sshv1=[%d])****\n",pSSH->sshv1);
syslog(LOG_INFO,"****READ(pSSH->sshv2=[%d])****\n",pSSH->sshv2);
syslog(LOG_INFO,"****READ(pSSH->rootAccess=[%d])****\n",pSSH->rootAccess);
syslog(LOG_INFO,"****END READ(GetSshValues)****\n");*/

        return kCycSuccess;
}

//[LMT]========================================================================
// GetWebValues:
// Read web parameter inside /etc/webui.conf
//========================================================================
int GetWebValues(char *file_name, CycParam *ParamList)
{
        char buf[BUF_FILE];
        char *line, *param;
        FILE *fd;
        HttpOptions *prWeb;
        short int flgEOF=0;
        int val;

        prWeb = (HttpOptions *)ParamList->value;

        //Open /etc/security.opts file and get icmp status
        if((fd = fopen(file_name, "r")) == NULL) {
                syslog(LOG_INFO,"Cannot open %s file.\n", file_name);
                return (kFileReadError);
        }

        while(fgets(buf, BUF_FILE, fd)) {
                if((line = strstr(buf, "# Do not touch the code below neither this line")) != NULL)
                        flgEOF = 1;
                //Determine the end of config file
                if(!flgEOF) {
                        //Check if line is commented
                        if(chkComment(buf)) {
                                //Parse of data
                                if((param = strtok(buf,"="))!=NULL) {
                                        line = strtok(NULL,"=");
                                }else
                                        continue;

                                /*Check it is a valide variable
                                "HTTP_PORT","HTTPS_PORT","HTTPS","HTTP","SECLEVEL","SSLVER" */
                                if(!strcmp(param,fields_web[0])) {
                                        //HTTP_PORTS="-p <number>"
										line+=4;
                                        if((prWeb->http_port = parseintvalue(line)) == -1){
                                            if((val=GetWebPortsServices(0)) > -1){
                                                    prWeb->http_port = val;
                                            }else
                                                    prWeb->http_port = 80;
                                        }
                                }else if(!strcmp(param,fields_web[1])) {
                                        //HTTPS_PORT="-p <number>"
										line+=4;
                                        if((prWeb->https_port = parseintvalue(line)) == -1){
                                            if((val=GetWebPortsServices(1)) > -1){
                                                    prWeb->https_port = val;
                                            }else
                                                    prWeb->https_port = 443;
                                        }
                                }else if(!strcmp(param,fields_web[2])) {
                                        //HTTPS
                                        if(!strncmp(line, "YES",3)) {
                                                prWeb->https = 1;
                                        }
                                        else if(!strncmp(line, "NO",2)) {
                                                prWeb->https = 0;
                                        }
                                }else if(!strcmp(param,fields_web[3])) {
                                        //HTTP
                                        if(!strncmp(line, "YES",3)) {
                                                prWeb->http = 1;
                                        }
                                        else if(!strncmp(line, "NO",2)) {
                                                prWeb->http = 0;
                                        }
                                }else if(!strcmp(param,fields_web[4])) {
                                        //Redirect if value is 1
                                        if((param = strstr(line, "-s")) != NULL) {
                                            param+=2;
                                            if(parseintvalue(param) == 1) {
                                                prWeb->redirect = 1;
                                            }else
                                                prWeb->redirect = 0;
                                        }
                                }else if(!strcmp(param,fields_web[5])) {
                                        //SSL version -v 3 or -v 2(default)
                                        if((param = strstr(line, "-v")) != NULL) {
                                           param+=2;
                                           if(parseintvalue(param) == 3)
                                                prWeb->ssl_version = 3;
                                           else
                                                prWeb->ssl_version = 0;
                                        }
                                }
                        } //End if(chkComment(buf))
                }else
                        break; //FORCE END OF FILE

        }

        //Set default values if variables were not correctly configured
        if(prWeb->http_port <=0)
                prWeb->http_port = 80;

        if(prWeb->https_port <=0)
                prWeb->https_port = 443;

        fclose(fd);

/*syslog(LOG_INFO,"****BEGIN READ(GetWebValues)****\n");
syslog(LOG_INFO,"****READ(prWeb->http_port=[%d])****\n",prWeb->http_port);
syslog(LOG_INFO,"****READ(prWeb->https_port=[%d])****\n",prWeb->https_port);
syslog(LOG_INFO,"****READ(prWeb->http=[%d])****\n",prWeb->http);
syslog(LOG_INFO,"****READ(prWeb->https=[%d])****\n",prWeb->https);
syslog(LOG_INFO,"****READ(prWeb->redirect=[%d])****\n",prWeb->redirect);
syslog(LOG_INFO,"****READ(prWeb->ssl_version=[%d])****\n",prWeb->ssl_version);
syslog(LOG_INFO,"****END READ(GetWebValues)****\n");*/

 
        return (kCycSuccess);
}

// [GY]=====================================================================
// SetProfPortsOpts:
// Set security.opts configuration file
//
// ACS and ONS
// ssh2sport, telnet2sport, raw2sport, auth2sport: enabled = 1 | disabled = 0
// **bidirect = 1(enable) or 0(disable) [LMT]
//
// KVM and ONS
// directaccess: enable = 1 | disable = 0
// profile: custom=1 | open=2 | moderate=3 | secured=4 (default==moderate)
//==========================================================================

#define SecOptParam 6
int SetProfPortsOpts(CycParam *ParamList, char *file_name)
{

        SecOptions *prProfPorts;
        char buf[BUF_FILE];
        char *line;
        static char *value[]={"disabled", "enabled"};
        FILE *fd, *fd_tmp;
        unsigned short ctrl=0x0, mask=0x007f, msk=0x0001;
        int len, flg;

#ifdef KVM
        mask = 0x0050;
#else
#ifndef ONS
        mask = 0x003f;
#endif
#endif

        if( (fd = fopen(file_name, "r")) == NULL ) {
          syslog(LOG_INFO,"Cannot open /etc/security.opts file.\n");
          return (kFileReadError);
        }

        if( (fd_tmp = fopen("/etc/.security.opts.tmp", "w")) == NULL ) {
          syslog(LOG_INFO,"Cannot open /etc/.security.opts.tmp.\n");
          fclose(fd);
          return (kFileWriteError);
        }

        prProfPorts = (SecOptions *)ParamList->value;

        while( fgets(buf, BUF_FILE, fd) )
        {
          line=buf;
          flg=0;
          for( len=0; len < strlen(buf); len++ ) {
            if( isspace(*line) ) {
              line++;
              continue;
            }
            if( *line == '#' ) {
              flg=1;
              break;
            }
            else {
              if( isalnum(*line) ) {
                flg=2;
                break;
              }
              else {
                syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
                fclose(fd);
                fclose(fd_tmp);
                return (kFileReadError);
              }
            }
          }

//        if( flg == 0 )
//          continue;
          if( flg == 0 || flg == 1 ) {
            fprintf(fd_tmp, "%s", buf);
            continue;
          }

          flg=0;
          if( strstr(buf, "profile") != NULL ) {
              flg=6;
              ctrl=ctrl | 0x0010;
          } else if( strstr(buf, "icmp") != NULL ){
              flg=7;
          }

#ifndef KVM
          if( strstr(buf, "ssh2sport") != NULL ) {
            flg=1;
            ctrl=ctrl | 0x0001;
          } else if( strstr(buf, "telnet2sport") != NULL ) {
            flg=2;
            ctrl=ctrl | 0x0002;
          } else if( strstr(buf, "raw2sport") != NULL ) {
            flg=3;
            ctrl=ctrl | 0x0004;
          } else if( strstr(buf, "auth2sport") != NULL ) {
            flg=4;
            ctrl=ctrl | 0x0008;
          } else if( strstr(buf, "bidirect") != NULL ) {
            flg=5;
		    ctrl=ctrl | 0x0020;
          }
#endif

#if defined(ONS) || defined(KVM)
          if( strstr(buf, "directaccess") != NULL ) {
              flg=8;
              ctrl=ctrl | 0x0040;
          }
#endif

          if (flg == 0
#ifdef KVM
              || (flg >=1 && flg <= 5)
#else
#ifndef ONS
              || (flg == 8)
#endif
#endif
            ) {
              syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
              fclose(fd);
              fclose(fd_tmp);
              return (kFileReadError);
		  }

          switch( flg ) {
            case 1:
              fprintf(fd_tmp, "%s  %s\n", "ssh2sport", value[prProfPorts->ssh2sport]);
              break;
            case 2:
              fprintf(fd_tmp, "%s  %s\n", "telnet2sport", value[prProfPorts->telnet2sport]);
              break;
            case 3:
              fprintf(fd_tmp, "%s  %s\n", "raw2sport", value[prProfPorts->raw2sport]);
              break;
            case 4:
              fprintf(fd_tmp, "%s  %s\n", "auth2sport", value[prProfPorts->auth2sport]);
              break;
	        case 5:
              fprintf(fd_tmp, "%s  %s\n", "bidirect", value[prProfPorts->bidirect]);
	          break;
            case 6:
              switch( prProfPorts->profile ) {
                case kSecOpen:
                  fprintf(fd_tmp, "%s  %s\n", "profile", "open");
                  break;
                case kSecModerate:
                  fprintf(fd_tmp, "%s  %s\n", "profile", "moderate");
                  break;
                case kSecSecured:
                  fprintf(fd_tmp, "%s  %s\n", "profile", "secured");
                  break;
                case kSecCustom:
                  fprintf(fd_tmp, "%s  %s\n", "profile", "custom");
                  break;
                default:
                  syslog(LOG_INFO,"Invalid value for profile in /etc/security.opts file.\n");
                  fclose(fd);
                  fclose(fd_tmp);
                  return (kFileReadError);
              }
              break;
            case 7:
              fprintf(fd_tmp, "%s", buf);
              break;
	        case 8:
              fprintf(fd_tmp, "%s  %s\n", "directaccess", value[prProfPorts->directaccess]);
	          break;

            default:
              syslog(LOG_INFO,"Invalid line in /etc/security.opts file: %s\n", buf);
              fclose(fd);
              fclose(fd_tmp);
              return (kFileReadError);
          }
        }

        if( (ctrl & mask) != mask ) {
        syslog(LOG_INFO,"Some configuration parameter in /etc/security.opts file wasn't found.\n");
          for(len=0; len<SecOptParam; len++) {
            if( (mask & msk) && (ctrl & msk) == 0 ) {
              switch( msk ) {
                case 0x0001:
                  fprintf(fd_tmp, "%s  %s\n", "ssh2sport", value[prProfPorts->ssh2sport]);
                  break;
                case 0x0002:
                  fprintf(fd_tmp, "%s  %s\n", "telnet2sport", value[prProfPorts->telnet2sport]);
                  break;
                case 0x0004:
                  fprintf(fd_tmp, "%s  %s\n", "raw2sport", value[prProfPorts->raw2sport]);
                  break;
                case 0x0008:
                  fprintf(fd_tmp, "%s  %s\n", "auth2sport", value[prProfPorts->auth2sport]);
                  break;
                case 0x0010:
                  switch( prProfPorts->profile ) {
                    case kSecOpen:
                      fprintf(fd_tmp, "%s  %s\n", "profile", "open");
                      break;
                    case kSecModerate:
                      fprintf(fd_tmp, "%s  %s\n", "profile", "moderate");
                      break;
                    case kSecSecured:
                      fprintf(fd_tmp, "%s  %s\n", "profile", "secured");
                      break;
                    case kSecCustom:
                      fprintf(fd_tmp, "%s  %s\n", "profile", "custom");
                      break;
                    default:
                      syslog(LOG_INFO,"Invalid value for profile in SecOptions.\n");
                      fclose(fd);
                      fclose(fd_tmp);
                      return (kFileReadError);
                  }
                  break;
                case 0x0020:
                  fprintf(fd_tmp, "%s  %s\n", "bidirect", value[prProfPorts->bidirect]);
                  break;
	            case 0x0040:
                  fprintf(fd_tmp, "%s  %s\n", "directaccess", value[prProfPorts->directaccess]);
	              break;
                default:
                  syslog(LOG_INFO,"Invalid index for parameter.\n");
                  fclose(fd);
                  fclose(fd_tmp);
                  return (kFileReadError);
              }
            }
            msk = msk << 1;
          }
        }

        fclose(fd_tmp);
        fclose(fd);

        rename("/etc/.security.opts.tmp", file_name);

/*
syslog(LOG_INFO,"****WRITE****prProfPorts->ssh2sport[0/1]=%d\n",prProfPorts->ssh2sport);
syslog(LOG_INFO,"****WRITE****prProfPorts->telnet2sport[0/1]=%d\n",prProfPorts->telnet2sport);
syslog(LOG_INFO,"****WRITE****prProfPorts->raw2sport[0/1]=%d\n",prProfPorts->raw2sport);
syslog(LOG_INFO,"****WRITE****prProfPorts->auth2sport[0/1]=%d\n",prProfPorts->auth2sport);
syslog(LOG_INFO,"****WRITE****prProfPorts->bidirect[0/1]=%d\n",prProfPorts->bidirect);
syslog(LOG_INFO,"****WRITE****prProfPorts->profile=%d\n",prProfPorts->profile);
syslog(LOG_INFO,"****WRITE****prProfPorts->directaccess[0/1]=%d\n",prProfPorts->directaccess);
*/
        return (kCycSuccess);
}

// [LMT]=====================================================================
// setProfile:
// Set all variables defined to profile: open, moderate, secured.
//==========================================================================
int setProfile(int profile)
{
    CycCatKeyTable mytableline;
    CycParam myparam;
    SecProfile  mysecprofile;

    switch (profile) {
            case kSecOpen:
                mysecprofile.telnet = kYes;
                mysecprofile.snmp = kYes;
                mysecprofile.rpc = kYes;
                mysecprofile.ftp = kNo;
#ifdef ONS
                mysecprofile.tftp = kNo;
#endif
                mysecprofile.ipsec = kNo;
                mysecprofile.icmp = kYes;

                mysecprofile.ssh.sshv1 = kYes;
                mysecprofile.ssh.sshv2 = kYes;
                mysecprofile.ssh.port = 22;
                mysecprofile.ssh.rootAccess = kYes;

                mysecprofile.webUI.http = kYes;
                mysecprofile.webUI.https = kYes;
                mysecprofile.webUI.http_port = 80;
                mysecprofile.webUI.https_port = 443;
                mysecprofile.webUI.redirect = kNo;
                mysecprofile.webUI.ssl_version = kSslVdefault;

                mysecprofile.options.profile = kSecOpen;

#ifdef KVM
                mysecprofile.options.ssh2sport = kNo;
                mysecprofile.options.telnet2sport = kNo;
                mysecprofile.options.raw2sport = kNo;
                mysecprofile.options.auth2sport = kNo;
                mysecprofile.options.bidirect = kNo;

                mysecprofile.options.directaccess = kYes;
#else //!KVM
                mysecprofile.options.ssh2sport = kYes;
                mysecprofile.options.telnet2sport = kYes;
                mysecprofile.options.raw2sport = kYes;
                mysecprofile.options.auth2sport = kNo;
                mysecprofile.options.bidirect = kYes;
#ifdef ONS
                mysecprofile.options.directaccess = kYes;
#else  //!ONS
                mysecprofile.options.directaccess = kNo;
#endif //ONS
#endif //KVM
                break;
            case kSecModerate:
                mysecprofile.telnet = kNo;
                mysecprofile.snmp = kNo;
                mysecprofile.rpc = kNo;
                mysecprofile.ftp = kNo;
#ifdef ONS
                mysecprofile.tftp = kNo;
#endif
                mysecprofile.ipsec = kNo;
                mysecprofile.icmp = kYes;

                mysecprofile.ssh.sshv1 = kYes;
                mysecprofile.ssh.sshv2 = kYes;
                mysecprofile.ssh.port = 22;
                mysecprofile.ssh.rootAccess = kYes;

                mysecprofile.webUI.http = kYes;
                mysecprofile.webUI.https = kYes;
                mysecprofile.webUI.http_port = 80;
                mysecprofile.webUI.https_port = 443;
                mysecprofile.webUI.redirect = kYes;
                mysecprofile.webUI.ssl_version = kSslVdefault;

                mysecprofile.options.profile = kSecModerate;
#ifdef KVM
                mysecprofile.options.ssh2sport = kNo;
                mysecprofile.options.telnet2sport = kNo;
                mysecprofile.options.raw2sport = kNo;
                mysecprofile.options.auth2sport = kNo;
                mysecprofile.options.bidirect = kNo;

                mysecprofile.options.directaccess = kNo;
#else //!KVM
                mysecprofile.options.ssh2sport = kYes;
                mysecprofile.options.telnet2sport = kYes;
                mysecprofile.options.raw2sport = kYes;
                mysecprofile.options.auth2sport = kNo;
                mysecprofile.options.bidirect = kYes;
#ifdef ONS
                mysecprofile.options.directaccess = kNo;
#else //!ONS
                mysecprofile.options.directaccess = kNo;
#endif //ONS
#endif //KVM
                break;
            case kSecSecured:
                mysecprofile.telnet = kNo;
                mysecprofile.snmp = kNo;
                mysecprofile.rpc = kNo;
                mysecprofile.ftp = kNo;
#ifdef ONS
                mysecprofile.tftp = kNo;
#endif
                mysecprofile.ipsec = kNo;
                mysecprofile.icmp = kNo;

                mysecprofile.ssh.sshv1 = kNo;
                mysecprofile.ssh.sshv2 = kYes;
                mysecprofile.ssh.port = 22;
                mysecprofile.ssh.rootAccess = kNo;

                mysecprofile.webUI.http = kNo;
                mysecprofile.webUI.https = kYes;
                mysecprofile.webUI.http_port = 80;
                mysecprofile.webUI.https_port = 443;
                mysecprofile.webUI.redirect = kNo;
                mysecprofile.webUI.ssl_version = kSslV3;

                mysecprofile.options.profile = kSecSecured;
#ifdef KVM
                mysecprofile.options.ssh2sport = kNo;
                mysecprofile.options.telnet2sport = kNo;
                mysecprofile.options.raw2sport = kNo;
                mysecprofile.options.auth2sport = kNo;
                mysecprofile.options.bidirect = kNo;

                mysecprofile.options.directaccess = kNo;
#else //!KVM
                mysecprofile.options.ssh2sport = kYes;
                mysecprofile.options.telnet2sport = kNo;
                mysecprofile.options.raw2sport = kNo;
                mysecprofile.options.auth2sport = kYes;
                mysecprofile.options.bidirect = kNo;
#ifdef ONS
                mysecprofile.options.directaccess = kNo;
#else //!ONS
                mysecprofile.options.directaccess = kNo;
#endif //ONS
#endif //KVM
                break;
            default:
                syslog(LOG_INFO,"None profile was choosed!\n");
                return (kCannotSet);
                break;
    }

//syslog(LOG_INFO,"SNMP - ENVIRONMENT\n");
    //SNMP
    mytableline.category = kSnmpdSettings;
    mytableline.key = kSnmpdEnable;
    mytableline.fileName = SNMPD_SHELL;
    mytableline.getParamRoutine = RdWrtShellVar;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = "ENABLE";
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kSnmpdSettings;
    myparam.key = kSnmpdEnable;
    myparam.value = &mysecprofile.snmp;
    myparam.collectionSize = 0;
    myparam.pSize = 4;

    RdWrtShellVar(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"FTP - ENVIRONMENT\n");
    //FTP
    mytableline.category = kInetd;
    mytableline.key = kFtpEnable;
    mytableline.fileName = INETD_FILE;
    mytableline.getParamRoutine = RdWrtCommentLineEntry;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = ftp_cmd;
    mytableline.name = "ftp";
    mytableline.type = TYPE_STRLINE;
    mytableline.size = 0;
    mytableline.listOptions = NULL;
    mytableline.nOptions = 0;
    mytableline.flag = 0;

    myparam.category = kInetd;
    myparam.key = kFtpEnable;
    myparam.value = &mysecprofile.ftp;
    myparam.collectionSize = 0;
    myparam.pSize = 4;

    RdWrtCommentLineEntry(&mytableline, &myparam, 1);

#ifdef ONS
    //TFTP
    mytableline.category = kInetd;
    mytableline.key = kTftpEnable;
    mytableline.fileName = INETD_FILE;
    mytableline.getParamRoutine = RdWrtCommentLineEntry;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = tftp_cmd;
    mytableline.name = "tftp";
    mytableline.type = TYPE_STRLINE;
    mytableline.size = 0;
    mytableline.listOptions = NULL;
    mytableline.nOptions = 0;
    mytableline.flag = 0;

    myparam.category = kInetd;
    myparam.key = kTftpEnable;
    myparam.value = &mysecprofile.tftp;
    myparam.collectionSize = 0;
    myparam.pSize = 5;

    RdWrtCommentLineEntry(&mytableline, &myparam, 1);
#endif

//syslog(LOG_INFO,"TELNET - ENVIRONMENT\n");
    //TELNET
    mytableline.category = kInetd;
    mytableline.key = kTelnetEnable;
    mytableline.fileName = INETD_FILE;
    mytableline.getParamRoutine = RdWrtCommentLineEntry;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = telnet_cmd;
    mytableline.name = "telnet";
    mytableline.type = TYPE_STRLINE;
    mytableline.size = 0;
    mytableline.listOptions = NULL;
    mytableline.nOptions = 0;
    mytableline.flag = 0;

    myparam.category = kInetd;
    myparam.key = kTelnetEnable;
    myparam.value = &mysecprofile.telnet;
    myparam.collectionSize = 0;
    myparam.pSize = 4;

    RdWrtCommentLineEntry(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"IPSEC - ENVIRONMENT\n");
    //IPSEC
    mytableline.category = kIpSec;
    mytableline.key = kIpSecEnable;
    mytableline.fileName = IPSEC_SHELL;
    mytableline.getParamRoutine = RdWrtShellVar;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = "ENABLE";
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kIpSec;
    myparam.key = kIpSecEnable;
    myparam.value = &mysecprofile.ipsec;
    myparam.collectionSize = 0;
    myparam.pSize = 4;

    RdWrtShellVar(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"RPC - ENVIRONMENT\n");
    //RPC
    mytableline.category = kPortMap;
    mytableline.key = kRpcEnable;
    mytableline.fileName = PORTMAP_SHELL;
    mytableline.getParamRoutine = RdWrtShellVar;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = "ENABLE";
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kPortMap;
    myparam.key = kRpcEnable;
    myparam.value = &mysecprofile.rpc;
    myparam.collectionSize = 0;
    myparam.pSize = 4;

    RdWrtShellVar(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"ICMP - ENVIRONMENT\n");
    //ICMP
    mytableline.category = kSecProfiles;
    mytableline.key = kIcmpEnable;
    mytableline.fileName = SECURITY_SHELL;
    mytableline.getParamRoutine = RdWrtSecOptVar;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = "icmp";
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kSecProfiles;
    myparam.key = kIcmpEnable;
    myparam.value = &mysecprofile.icmp;
    myparam.collectionSize = 0;
    myparam.pSize = 4;

    RdWrtSecOptVar(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"WEBUI - ENVIRONMENT\n");
    //WEBUI
    mytableline.category = kWebUI;
    mytableline.key = kWebUIOpt;
    mytableline.fileName = WEBUI_SHELL;
    mytableline.getParamRoutine = RdWrtWebUiShell;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = NULL;
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kWebUI;
    myparam.key = kWebUIOpt;
    myparam.value = &mysecprofile.webUI;
    myparam.collectionSize = 1;
    myparam.pSize = sizeof(mysecprofile);

    RdWrtWebUiShell(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"SSH - ENVIRONMENT\n");
    //SSH
    mytableline.category = kSshd;
    mytableline.key = kSshdOpt;
    mytableline.fileName = SSHD_SHELL;
    mytableline.getParamRoutine = RdWrtSshShell;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = "ENABLE";
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kSshd;
    myparam.key = kSshdOpt;
    myparam.value = &mysecprofile.ssh;
    myparam.collectionSize = 1;
    myparam.pSize = sizeof(mysecprofile);

    RdWrtSshShell(&mytableline, &myparam, 1);

//syslog(LOG_INFO,"SEC PROFILES OPTIONS - ENVIRONMENT\n");
    //SEC PROFILES OPTIONS
    mytableline.category = kSecProfiles;
    mytableline.key = kSecOpt;
    mytableline.fileName = SECURITY_SHELL;
    mytableline.getParamRoutine = RdWrtSecOptProfPorts;
    mytableline.parser = NULL;
    mytableline.write = NULL;
    mytableline.defaultPrefix = NULL;
    mytableline.name = "profports";
    mytableline.type = TYPE_LISTVAR;
    mytableline.size = 0;
    mytableline.listOptions = EnableOptions;
    mytableline.nOptions = SIZE_EnableOptions;
    mytableline.flag = 0;

    myparam.category = kSecProfiles;
    myparam.key = kSecOpt;
    myparam.value = &mysecprofile.options;
    myparam.collectionSize = 1;
    myparam.pSize = sizeof(mysecprofile);

    RdWrtSecOptProfPorts(&mytableline, &myparam, 1);

        return (kCycSuccess);
}

//[LMT]========================================================================
// GetEchoOpts:
// Get parameter icmp inside /etc/security.opts to enable or disable
//========================================================================

int GetEchoOpts(char * file_name, char * field)
{
        char buf[BUF_FILE];
        char *line, *param;
        FILE *fd;

        //Open /etc/security.opts file and get icmp status
        if((fd = fopen(file_name, "r")) == NULL)
                return kYes;

        while(fgets(buf, BUF_FILE, fd))
        {
                if((line = strstr(buf, field)) != NULL)
                {
                        param = buf;
                        if(param < line)
                        {
                                if(CheckLineParam(param,line,0)) {
                                        continue;
                                }
                        }

                        if((param = strstr(buf, "enable")) != NULL)
                        {
                                if(!CheckLineParam(line,param,strlen(field)))
                                        return kYes;
                                break;
                        }
                        else if((param = strstr(buf, "disable")) != NULL)
                        {
                                if(!CheckLineParam(line,param,strlen(field)))
                                        return kNo;
                                break;
                        }
                }
        }

        return (kCycSuccess);
}

//[LMT]========================================================================
// SetEchoOpts:
// Set parameter icmp inside /etc/security.opts to enable or disable
//YES = 0
//NO = 1
//========================================================================
int SetEchoOpts(int YesNo, char * file_name, char * field)
{
  char buf[BUF_FILE];
  char *line, *param, value[10];
  FILE *fd, *fd_tmp;
  short int flgWrite = 0;

        //Open /etc/security.opts file and get icmp status
        if((fd = fopen(file_name, "r")) == NULL)
        {
                syslog(LOG_INFO,"Cannot open /etc/security.opts file.\n");
                return (kFileReadError);
        }

        //Use temp file to apply the new value
        if((fd_tmp = fopen("/etc/.security.opts.tmp", "w")) == NULL)
        {
                syslog(LOG_INFO,"Cannot open .security.opts.tmp\n");
                return (kFileWriteError);
        }

        //Translate current value to disabled or enabled
        if(YesNo)
        {
                strncpy(value, "enabled", 7);
                value[7]='\0';
        }else {
                strncpy(value, "disabled", 8);
                value[8]='\0';
        }

        //Replace the value found inside opts file with value was choosed by user
        while(fgets(buf, BUF_FILE, fd))
        {
                if((line = strstr(buf, field)) != NULL)
                {

                        param = buf;
                        if(param < line)
                        {
                                if(CheckLineParam(param,line,0)) {
                                        fprintf(fd_tmp, "%s", buf);
                                        continue;
                                }
                        }

                        fprintf(fd_tmp, "%s                    %s\n",field, value);
                        flgWrite = 1;
                }
                else
                        fprintf(fd_tmp, "%s", buf);
        }

        //If the variable hadn't been wrote, so now it will be wrote at the end of file
        if(!flgWrite)
                fprintf(fd_tmp, "%s                    %s\n",field, value);

        fclose(fd_tmp); //.security.opts.tmp
        fclose(fd); //security.opts

        rename("/etc/.security.opts.tmp", file_name);

        return (kCycSuccess);
}

//[LMT]========================================================================
// SetIcmpProc:
//      Set to 0/1 the icmp_echo_ignore_all inside /proc.
//========================================================================
int SetIcmpProc(int YesNo)
{
   FILE *fd_tmp;

        //Set icmp echo of /proc -> /proc/sys/net/ipv4/icmp_echo_ignore_all
        if((fd_tmp = fopen("/proc/sys/net/ipv4/icmp_echo_ignore_all", "w")) == NULL)
        {
                syslog(LOG_INFO,"Cannot open /proc/sys/net/ipv4/icmp_echo_ignore_all file.\n");
                return (kFileWriteError);
        }else {
                fprintf(fd_tmp,"%d",YesNo);
                fclose(fd_tmp);
        }
        return kCycSuccess;
}

//========================================================================
// get_value_from_config_line: gets the value from line 
// flgSearch: 0 = <param>="<value>"
//            1 = <param>=<value>
//            2 = <param> <value>
//           |4 means accept spaces: <param>=this is a value
//========================================================================
static void get_value_from_config_line(char *line, FileBuffer *buf, char **value, int *valueLen, int flgSearch) {
	char *pos, *ori_line;
	int i, len, flag = 0;

	ori_line = line;

	dolog("get_value_from_config_line()");

	if ((flgSearch & 3) == 2) {
		if ((pos = strchr(line, ' ')) == NULL) {
			/* It was put 0 in the paramlist already */
			return;
		}
	} else {
		if ((pos = strchr(line, '=')) == NULL) {
			/* It was put 0 in the paramlist already */
			return;
		}
	}

	line = ++pos;
	while (*pos && isblank(*pos)) pos++;
	line = pos;
	i = pos - buf->buf;

	if (i > buf->len) {
		return;
	}

	while(i < buf->len && flag != 3) {
		switch (flag) {
		case 0:
			if (((flgSearch & 3) == 0) && (*pos == '"')) {
				line++;
				flag=2;
			} else {
				flag = 1;
				continue;
			}
			break;
		case 1:
			if (*pos == '\r' || *pos == '\n' ||
				*pos == ' ' || *pos == '\t' || *pos == '#') {
				if(!((flgSearch & 4) && (*pos == ' '))){
					flag = 3;
					continue;
				}
			}
			break;
		case 2:
			if (*pos == '"') {
				flag = 3;
				continue;
			}
			break;
		}
		pos++;
		i++;
	}

	len = pos - line;
	*value = line;
	*valueLen = len;
}

//========================================================================
// GetNumOfPcmciaSlot - Returns the number of Pcmcia slot
//========================================================================
static int GetNumOfPcmciaSlot(void)
{
	unsigned char buffer[64];
	unsigned char *s, *t;
	unsigned int version;
	int numSlots=0;
	FILE *fp;

	system("what /proc/flash/boot_ori > /tmp/webtemp");
	if ((fp = fopen("/tmp/webtemp", "ro")) != NULL) 
	{
		while (fgets(buffer, sizeof(buffer), fp)) 
		{
			if ((s = strstr(buffer, "Original Boot ")) != NULL) 
			{
				s += 14;
				for (t = s; *t && *t != '.'; t ++);
				if (*t) *t++ = 0;
				version = atol(s) * 10000;
				s = t;
				for (t = s; *t && *t != '.'; t ++);
				if (*t) *t++ = 0;
				version += atol(s) * 100;
				s = t;
				for (t = s; *t && !isspace(*t); t ++);
				if (*t) *t++ = 0;
				version += atol(s);
				s = t;
				numSlots = 2;
				if (version < 20001) 
				{
					numSlots = 1;
				}
				if (version == 20001 && (strstr(s, "Jun") == NULL)) 
				{
					numSlots = 1;
				}
			}
		}
		system("rm -f /tmp/webtemp");
	}
	fclose(fp);
	return (numSlots);
}

//========================================================================
// ReadIpSecEntries - Returns the number of Ipsec connections
//========================================================================
static Result ReadIpSecEntries(void *ptr, CycParam *paramList, int returnEntriesFlg)
{
	// returnEntriesFlg=1 -> read and get number of entries only
	// returnEntriesFlg=0 -> read and parse the entries and return the entries

	DIR *etcDir;
	struct dirent * entry;
	unsigned char currFile[50];
	void *p = NULL;
	char *pf;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	if (!returnEntriesFlg)
	{
		p = paramList->value;
	}

	// Opening the directory
	if ((etcDir = opendir(pCkIndex->fileName)) == NULL)
	{
		LogError(DIR_OPEN_ERROR, pCkIndex->fileName);		
		return (kFileOpenError);
	}

	while ((entry = readdir(etcDir))) 
	{
		//dolog("ReadIpSecEntries(): Beginning of readdir while loop");
		// If the length of the current filename is less 
		// than 11, that means it cannot be <file>.connection file
		// because the word connection contains 10 characters.
		if (strlen (entry->d_name) < 11) 
		{
			continue;
		}
		if ((pf=strrchr( entry->d_name, '.')) == NULL) {
			continue;
		}
		if (strcmp(pf,".connection")) {
			continue;
		}
		dolog("Connection file found: %s\n", entry->d_name);
		// Set up file and call parser inside file
		sprintf(currFile, "%s%s", pCkIndex->fileName, entry->d_name);
		dolog("ReadIpSecEntries(): currFile passed in: %s", currFile);
		p = (*(pCkIndex->parser))(currFile, paramList, p);
	}
	return (kCycSuccess);
}

//========================================================================
// ParseHostEntry - Parse a host entry. The syntax of a host entry 
// line is: <ip address> <host name> 
//========================================================================
static void * ParseHostEntry (unsigned char *s, CycParam *paramList, void *ph)
{
	Hosts * pHost = (Hosts *)ph;
	Hosts host;	
	unsigned char *p, *q;

	memset(&host, 0, sizeof(host));

	p = s;
	q = (unsigned char *)host.hostIp;
	while(*p && !isspace(*p) &&
		(q < (unsigned char *)host.hostIp + kIpLength - 1)) *q++ = *p++;
	*q = 0;
	while(*p && isspace(*p)) p++;

	q = (unsigned char *)host.hostName;
	while(*p && !isspace(*p) &&
		(q < (unsigned char *)host.hostName + kHostNameLength - 1)) *q++ = *p++;
	*q = 0;
	while(*p && isspace(*p)) p++;

	q = (unsigned char *)host.hostAlias;
	while(*p &&
	(q < (unsigned char *)host.hostAlias + kHostNameLength - 1)) *q++ = *p++;
	*q = 0;

	dolog("Host IP: '%s'", host.hostIp);
	dolog("Host name: '%s'", host.hostName);
	dolog("Host alias: '%s'", host.hostAlias);

	if (pHost != NULL) {
		dolog("Set current pHost to the host gotten and increment pHost");
		// !!! error check to see if param value has exceeded space allocated
		if (((Hosts *)paramList->value + paramList->collectionSize) == pHost) {
			dolog("Error: Exceeded number of possible entries. Should exit.");
		}
		*pHost++ = host;
	} else {
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pHost);
}

//========================================================================
// ParseUserEntry - Parse a user entry. The syntax of a user entry 
// line is: <userName>:<?>:<userId>:<groupID>:<comments>:<dir>:<shell>
//========================================================================
static void *ParseUserEntry (unsigned char *s, CycParam *paramList, void *p)
{
	unsigned char *t, *ch = ":";
	Users *pUser = (Users *)p;
	Users user = {0};
	struct group *webGroup = NULL;
	struct group *bioGroup = NULL;
	int i;

	dolog("ParseUserEntry()");

	t = s;
	while (isspace(*s)) s++;
	while (*s && strncmp(s, ch, strlen(ch))) s++;
	if (*s) 
	{
		*s=0;
		s+=strlen(ch);
	}
	strncpy(user.userName, t, kUserNameLength-1);
	if (!strcmp(user.userName,"rpc") ||
	    !strcmp(user.userName,"nobody") ||
	    !strcmp(user.userName,"sshd") ||
	    (!strcmp(user.userName,"root") && !paramList->flag)) {
		return pUser;
	}

	t = s;
	while (*s && strncmp(s, ch, strlen(ch))) s++;
	if (*s) 
	{
		*s=0;
		s+=strlen(ch);
	}
	t=s;
	while (*s && strncmp(s, ch, strlen(ch))) s++;
	if (*s) 
	{
		*s=0;
		s+=strlen(ch);
	}
	//strcpy(user.userId, t);
	t=s;
	while (*s && strncmp(s, ch, strlen(ch))) s++;
  if (*s)
  {
    *s=0;
    s+=strlen(ch);
  }
  //strcpy(user.grpId, t);
	t=s;
	  while (*s && strncmp(s, ch, strlen(ch))) s++;
  if (*s)
  {
    *s=0;
    s+=strlen(ch);
  }
  strncpy(user.comments, t,kCommentLength-1);

	t=s;
	while (*s && strncmp(s, ch, strlen(ch))) s++;
  if (*s)
  {
    *s=0;
    s+=strlen(ch);
  }
  strncpy(user.homeDir, t,kDirPathLength-1);
	t=s;
	while (*s && strncmp(s, ch, strlen(ch))) s++;
  if (*s)
  {
    *s=0;
    s+=strlen(ch);
  }
  strncpy(user.shell, t,kDirPathLength-1);

	user.groupAdminReg = kRegularUser;
	user.groupBio = kUserNone;

	webGroup = getgrnam(ADMIN_GROUP);
	if ((webGroup = getgrnam(ADMIN_GROUP)) == NULL)
	{
		dolog("Group: %s not found", ADMIN_GROUP);
	} 

	for(i=0; webGroup->gr_mem[i]; i++) {
		if (!strcmp(webGroup->gr_mem[i], user.userName))
			user.groupAdminReg = kAdminUser;
	}

	bioGroup = getgrnam("biouser");
	if ((bioGroup = getgrnam("biouser")) != NULL)
	{
		for(i=0; bioGroup->gr_mem[i];i++) {
			if (!strcmp(bioGroup->gr_mem[i], user.userName))
				user.groupBio = kBioUser;
		}
	} else {
		dolog("Group: %s not found", "bddiouser");
	} 

	dolog("Username: [%s]", user.userName);
	dolog("Comment: [%s]", user.comments);
	dolog("homeDir: %s", user.homeDir);
	dolog("shell: %s", user.shell);

	if (pUser != NULL) {
		if (((Users *)paramList->value + paramList->collectionSize) == pUser)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
		}
		*pUser++ = user;
  	} else {
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	dolog("Exiting ParseUserEntry");
	return (pUser);
}

//========================================================================
// ParseIpSecEntryLine - Parse each line in a Ipsec connection
//========================================================================
int ParseIpSecEntryLine (unsigned char *s, IpSecInfo *ptrIpSec, int *connNameFound)
{
	int i, size;
	unsigned char *t, *v, *w;
	//struct StrList *sList; 

	dolog("ParseIPsecEntryLine()");


	// s => beginning of the splitted string
	// w => beginning of the current line
	// t => beginning of the parameter name
	// v => end of the parameter name and the beginning of the value
	// u => end of the splitted string

	w = s;
	while (*w) 
	{
		//dolog("parseIpsecEntryLine(): begin of while loop. W: %s", w);
		t = w;
		while (*w && *w != '\n') w++;
		if (*w) *w++ = 0;
			
		while (*t && isspace(*t)) t++;
		if (!*t || *t == '#') 
		{
			//dolog("ParseIpSecEntryLine(): t == #");
			continue;
		}

		if (!(*connNameFound)) 
		{
			//dolog("ParseIpSecEntryLine(): no connection name found yet");
			v = t;
			while (*v && !isspace(*v)) v++;
			if (v - t == 4 && strncmp(t, "conn", 4) == 0) 
			{
				// conn parameter - get the value of this parameter 
				while (*v && isspace(*v)) v++;
				*connNameFound = 1;
				strncpy(ptrIpSec->oldConnectionName, v,kFileNameLength-1);
				strncpy(ptrIpSec->connectionName, v,kFileNameLength-1);
				dolog("Connection Name: %s", ptrIpSec->connectionName);
			} else if (v - t == 6 && strncmp(t, "config", 6) == 0) {
				// !! Find out what happens when I return 2.
				//dolog("param starts with config");
				return 0;
			} else {
				dolog("Error - Split does not start with conn or config");
				return 0;
			}
			return 0;
		}


		v = t; // should be line after connection name line
		while (*v && !isspace(*v) && *v!='=') v++;	// read until = sign

		// Seek a parameter with the same name 
		for (i = 0; i < SIZE_IpSecParams; i++) 
		{
			size = strlen((IpSecParams+i)->paramName);

			if ((v - t == size) && (strncmp(t, (IpSecParams+i)->paramName, size) == 0)) 
			{
				//dolog("Current Parameter found: %s", t);

				while (*v && (isspace(*v) || *v == '=')) v++;

				dolog("Current Parameter value found: %s", v);

				if ((IpSecParams+i)->type == TY_IPSEC_STR) {
					strcpy((char *)ptrIpSec+(IpSecParams+i)->off, v);
				}

				if ((IpSecParams+i)->type == TY_IPSEC_LIST) {
					*(int *)((char *)ptrIpSec + (IpSecParams+i)->off) =
						TransOptGetVal((IpSecParams+i)->listOptions,
						(IpSecParams+i)->nOptions, v, strlen(v));
				}
				break;
			}
		}
	} // end of big while loop

	return 1;
}

//========================================================================
// ParseIpSecEntry - Parse an Ipsec entry. The syntax of an Ipsec entry 
// line is: conn <connectionName>
//               <paramName>=<paramValue>
//========================================================================
static void *ParseIpSecEntry(unsigned char *filename, CycParam *paramList, void *p)
{
	struct stat st;
	FILE *fp;
	unsigned char *buf, *t, *s, *v;
	char desc[50];
	int connNameFound = 0, foundSecret = 0;
	IpSecInfo ipSec={0};
	IpSecInfo *pIpSec; 

	dolog("ParseIpSecEntry()");

	pIpSec = (IpSecInfo *)p;

	if ((buf = ReadFile(filename, 0)) == NULL) 
	{
		LogError(FILE_READ_ERROR, filename);	
		return(0);
	}

	t=buf;

	if (!t) return (0);

	while (*t) {
		// Gets one line, which could be an entry.
		s = t;
		while (*t && *t != '\n') t++;
		if (*t) *t++=0;

		// Skips the blank lines
		if (*s == 0) continue;

		ParseIpSecEntryLine(s, &ipSec, &connNameFound);		
	}

		if(pIpSec != NULL && connNameFound == 1)
		{
			dolog("ParseIpSecEntry(): Getting secret");
			// Obtain secret section
			if (stat(IPSEC_SECRET_FILE, &st)) return 0;
			buf= (unsigned char *)malloc(st.st_size+1);
			if (!buf) return 0;
			fp = fopen (IPSEC_SECRET_FILE, "r");
			if (!fp)
			{
				free(buf);
				return 0;
			}
			fread(buf, 1, st.st_size, fp);
			*(buf+st.st_size) = 0;
			fclose(fp);


			t = buf;
			sprintf(desc, "#%s", ipSec.connectionName);

			while (*t) 
			{
				//dolog("Beginning of while *w loop");
				//dolog("w: [%s]", w);
				// Gets one line, which could be an entry.
				s = t;
				while (*t && *t != '\n') t++;
				if (*t) *t++=0;

				// Skips the blank lines
				if (*s == 0) continue;	
				//dolog("a: [%s]", a);

				if (!strncmp(s, desc,  strlen(desc)) && !foundSecret) {
					foundSecret = 1;
					//dolog("ParseIpSecEntry(): Inside found secret.");
					continue;
				}
				if (foundSecret)
				{
					dolog("ParseIpSecEntry(): Found secret. Current line: %s", s);
					while (*s)
					{
						if (!strncmp(s, "PSK", 3))
						{
							//dolog("ParseIpSecEntry(): Found PSK.");
							s += 5;
							v = s;
							while (*v != '"') v++;
							*v = 0;
							strncpy(ipSec.secret, s, kPasswordLength-1);
							dolog("Connection secret: %s", ipSec.secret);
						}
						s++;
					}
					break;
				}
			}
			*pIpSec++ = ipSec;
		}
		else if (pIpSec == NULL && connNameFound == 1)
		{
			(*(int *)paramList->value)++;
		}

	free(buf);
	return (pIpSec); // !! Remember to return this and send it back into this function as the void *p
}

//========================================================================
// ParseStRoutesEntry - Parse a route entry. The syntax of a host entry 
// line is:
//  net <Destination ip> mask <Destination mask> gw <gateway IP>
//   or
//  net <Destination ip> mask <Destination mask> dev <interface>
//========================================================================
static void * ParseStRoutesEntry (unsigned char *s, CycParam *paramList, void *p)
{
	StRoutesInfo *pRoutes = (StRoutesInfo *)p;
	StRoutesInfo route = {0};	
	unsigned char *word=NULL, gw=0, metric=0, net=0;
	int i, numPossibleParams = 10;

	dolog("ParseStRoutesEntry()");
	
	for (i=1; i<=numPossibleParams; i++) 
	{
		dolog("ParseStRoutesEntry(%d): line[%s]", i, s);
		while (isspace(*s)) s++;
		word=s;
		while (*s && !isspace(*s)) s++;
		if (*s) *s++=0;

		switch (i) 
		{
			case 3:
				if (!strcmp(word,"default")) 
				{
					route.routeType = kRtDefault;
					dolog("ParseStRoutesEntry(): Destination Ip: %s", word);
					strcpy(route.destinationIp, word);
					i = 6;
				}
				else if (!strcmp(word, "-net"))
				{	
					route.routeType = kRtNetwork;
					net = 1;
				}
				else
					route.routeType = kRtHost;
				break;
			case 4:
				dolog("ParseStRoutesEntry(): Destination Ip: %s", word);
				strcpy(route.destinationIp, word);
				if (!net)
					i = 6;
				break;
			case 6:
				dolog("ParseStRoutesEntry(): dest mask: %s", word);
				strcpy(route.destinationMask, word);
				break;
			case 7:
				if (strcmp(word,"gw") == 0) 
				{
					gw = 1;
				} 
				break;
			case 8:
				if (gw) 
				{
					dolog("ParseStRoutesEntry(): Gateway: %s", word);
					strcpy(route.gateWay, word);
					route.goTo = kRgtGateway;
				} 
				else 
				{
					dolog("ParseStRoutesEntry(): interface: %s", word);
					strcpy(route.routeInterface, word);
					route.goTo = kRgtInterface;
				}
				break;
			case 9:
				if (!strcmp(word, "metric"))
				{
					metric = 1;
				}
				break;
			case 10:
				if (metric)
				{
					dolog("ParseStRoutesEntry(): metric: %s", word);
					strcpy(route.metric, word);
				}
				break;
		} // end of switch loop
	}

	if (pRoutes != NULL)
	{
		dolog("Set current pHost to the host gotten and increment pHost");
		// !!! error check to see if param value has exceeded space allocated
		if (((StRoutesInfo *)paramList->value + paramList->collectionSize) == pRoutes)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
		}
		*pRoutes++ = route;
	}
	else
	{
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pRoutes);
}

//========================================================================
// ParseRoutingTableEntry - Parse a route entry. 
// The syntax of a routing table entry is:
// <Destination ip> <Gateway> <Genmask> <Flags> <MSS> <Window> <irtt> 
// <Interface>  
//========================================================================
static void * ParseRoutingTableEntry (unsigned char *s, CycParam *paramList, void *p)
{
	RoutingTableInfo *pRoutes = (RoutingTableInfo *)p;
	RoutingTableInfo route = {{0}};	
	unsigned char *word=NULL;
	int i, numPossibleParams = 11;

	dolog("ParseRoutingTableEntry()");
	
	for (i=1; i<=numPossibleParams; i++) 
	{
		while (isspace(*s)) s++;
		word=s;
		while (*s && !isspace(*s)) s++;
		if (*s) *s++=0;
		if (i == 1 && (!strcmp(word, "Kernel") || !strcmp(word, "Destination")))
		{
			return (pRoutes);
		}
		switch (i) 
		{
			case 1:
				if (!strncmp(word, "0.0.0.0", 7))
					strcpy(route.destinationIp, "default");
				else
					strcpy(route.destinationIp, word);
				dolog("ParseStRoutesEntry(): case 1: DestinationIp: %s", route.destinationIp);
				break;
			case 2:
				dolog("ParseStRoutesEntry(): case 2: Gateway: %s", word);
				strcpy(route.gateWay, word);
				break;
			case 3:
				dolog("ParseStRoutesEntry(): case 3: genMask: %s", word);
				strcpy(route.genMask, word);
				break;
			case 4:
				dolog("ParseStRoutesEntry(): case 4: Flag: %s", word);
				strcpy(route.flags, word);
				break;
			case 5:
				dolog("ParseStRoutesEntry(): case 5: metric: %s", word);
				strcpy(route.metric, word);
				break;
			case 8:
				dolog("ParseStRoutesEntry(): case 8: Iface: %s", word);
				strcpy(route.routeInterface, word);
				break;
			case 9:
				dolog("ParseStRoutesEntry(): case 9: MSS: %s", word);
				strcpy(route.mss, word);
				break;
			case 10:
				dolog("ParseStRoutesEntry(): case 10: Win: %s", word);
				strcpy(route.window, word);
				break;
			case 11:
				dolog("ParseStRoutesEntry(): case 11: Irtt: %s", word);
				strcpy(route.irtt, word);
				break;
			default:
				break;
		} // end of switch loop
	}

	if (pRoutes != NULL)
	{
		dolog("Set current pHost to the host gotten and increment pHost");
		// !!! error check to see if param value has exceeded space allocated
		if (((RoutingTableInfo *)paramList->value + paramList->collectionSize) == pRoutes)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
			//pRoutes = NULL;
			//return (pRoutes);
		}
		*pRoutes++ = route;
	}
	else
	{
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pRoutes);
}

//========================================================================
// ParseRamDiskInfo - Parse to get ram disk info
// The syntax of a routing table entry is:
// <Filesystem> <1k-blocks> <Used> <Available> <Use %> <Mounted on> 
//========================================================================
static void * ParseRamDiskInfo(unsigned char *s, CycParam *paramList, void *p)
{
	RamDiskInfo *pRamDisk = (RamDiskInfo *)p;
	RamDiskInfo ram = {{0}};	
	unsigned char *word=NULL;
	int i, numPossibleParams = 6;

	dolog("ParseRamDiskInfo()");
	
	for (i=1; i<=numPossibleParams; i++) 
	{
		while (isspace(*s)) s++;
		word=s;
		while (*s && !isspace(*s)) s++;
		if (*s) *s++=0;
		if (i == 1 && (!strcmp(word, "Filesystem")))
		{
			return (pRamDisk);
		}
		switch (i) 
		{
			case 1:
				strcpy(ram.fsName, word);
				dolog("ParseRamDiskInfo(): case 1: Word: %s", word);
				break;
			case 2:
				dolog("ParseRamDiskInfo(): case 2: Word: %s", word);
				strcpy(ram.blocks, word);
				break;
			case 3:
				dolog("ParseRamDiskInfo(): case 3: Word: %s", word);
				strcpy(ram.used, word);
				break;
			case 4:
				dolog("ParseRamDiskInfo(): case 4: Word: %s", word);
				strcpy(ram.avail, word);
				break;
			case 5:
				dolog("ParseRamDiskInfo(): case 5: Word: %s", word);
				strcpy(ram.usage, word);
				break;
			case 6:
				dolog("ParseRamDiskInfo(): case 6: Word: %s", word);
				strcpy(ram.mountedOn, word);
				break;
		} // end of switch loop
	}

	if (pRamDisk != NULL)
	{
		dolog("Set current pRamDisk to the ram gotten and increment pRamDisk");
		// !!! error check to see if param value has exceeded space allocated
		if (((RamDiskInfo *)paramList->value + paramList->collectionSize) == pRamDisk)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
			pRamDisk = NULL;
			return (pRamDisk);
		}
		*pRamDisk++ = ram;
	}
	else
	{
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pRamDisk);
}

//========================================================================
// ParseActiveSessionEntry - Parse an active session entry.
// The syntax of an active session entry is:
// <User> <TTY> <From> <Login> <Idle> <JCpu> <PCpu> <What> 
//========================================================================
static void * ParseActiveSessionEntry (unsigned char *s, CycParam *paramList, void *p)
{
	ActiveSessionInfo *pActiveSession = (ActiveSessionInfo *)p;
	ActiveSessionInfo actSession;
	unsigned char *word=NULL;
	int i, numPossibleParams = 8;

	dolog("ParseActiveSessionEntry()");
	
	memset(&actSession, 0, sizeof(ActiveSessionInfo));

	// Skip first two lines
	if (strstr(s, "USER") != NULL || strstr(s, "load") != NULL)
	{
		dolog("Skip Line");
		return (pActiveSession);
	}
	for (i=1; i<=numPossibleParams; i++) 
	{
		while (isspace(*s)) s++;
		word=s;
		while (*s && !isspace(*s)) s++;
		if (*s) *s++=0;
		dolog("Word: %s", word);
		switch (i) 
		{
			case 1:
				strcpy(actSession.user, word);
				dolog("ParseActiveSesionEntry(): case 1: Word: [%s]", word);
				break;
			case 2:
				dolog("ParseActiveSessionEntry(): case 2: Word: [%s]", word);
				strcpy(actSession.tty, word);
				break;
			case 3:
				dolog("ParseActiveSessionEntry(): case 3: Word: [%s]", word);
				strcpy(actSession.fromIp, word);
				break;
			case 4:
				dolog("ParseActiveSessionEntry(): case 4: Word: [%s]", word);
				strcpy(actSession.loginTime, word);
				break;
			case 5:
				dolog("ParseActiveSessionEntry(): case 5: Word: [%s]", word);
				strcpy(actSession.idle, word);
				break;
			case 6:
				dolog("ParseActiveSessionEntry(): case 6: Word: [%s]", word);
				strcpy(actSession.jcpu, word);
				break;
			case 7:
				dolog("ParseActiveSessionEntry(): case 7: Word: [%s]", word);
				strcpy(actSession.pcpu, word);
				break;
			case 8:
				dolog("ParseActiveSessionEntry(): case 8: Word: [%s]", word);
				strcpy(actSession.what, word);
				break;
		} // end of switch loop
	}

	if (pActiveSession != NULL)
	{
		dolog("Set current pHost to the host gotten and increment pHost");
		// !!! error check to see if param value has exceeded space allocated
		if (((ActiveSessionInfo *)paramList->value + paramList->collectionSize) == pActiveSession)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
			pActiveSession = NULL;
			return (pActiveSession);
		}
		*pActiveSession++ = actSession;
	}
	else
	{
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pActiveSession);
}

//========================================================================
// ParseCasSessionEntry - Parse an active CAS session entry.
// The syntax of an active CAS session entry is:
// <User> <TTY> <From> <Login> <Pid>/<Command>
//========================================================================
static void * ParseCasSessionEntry (unsigned char *s, CycParam *paramList, void *p)
{
	ActiveSessionInfo *pActiveSession = (ActiveSessionInfo *)p;
	ActiveSessionInfo actSession;
	unsigned char *word=NULL, *ptr=NULL;
	int i, numPossibleParams = 5;

	dolog("ParseCasSessionEntry()");
	
	memset(&actSession, 0, sizeof(ActiveSessionInfo));
	if (strstr(s, "CAS") != NULL || strstr(s, "USER") != NULL)
	{
		dolog("Skip Line");
		return (pActiveSession);
	}
	for (i=1; i<=numPossibleParams; i++) 
	{
		while (isspace(*s)) s++;
		word=s;
		if (i!=5) {
			while (*s && !isspace(*s)) s++;
			if (*s) *s++=0;
		}
		dolog("Word: %s", word);
		switch (i) 
		{
			case 1:
				strcpy(actSession.user, word);
				dolog("ParseActiveSesionEntry(): case 1: Word: [%s]", word);
				break;
			case 2:
				dolog("ParseActiveSessionEntry(): case 2: Word: [%s]", word);
				strcpy(actSession.tty, word);
				break;
			case 3:
				dolog("ParseActiveSessionEntry(): case 3: Word: [%s]", word);
				strcpy(actSession.fromIp, word);
				break;
			case 4:
				dolog("ParseActiveSessionEntry(): case 4: Word: [%s]", word);
				strcpy(actSession.loginTime, word);
				break;
			case 5:
				dolog("ParseActiveSessionEntry(): case 5: Word: [%s]", word);
				ptr = strchr(word, '/');
				if (*ptr) *ptr++ = 0x00;
				strcpy(actSession.pid, word);
				strcpy(actSession.what, ptr);
				break;
		} // end of switch loop
	}

	if (pActiveSession != NULL)
	{
		dolog("Set current pHost to the host gotten and increment pHost");
		// !!! error check to see if param value has exceeded space allocated
		if (((ActiveSessionInfo *)paramList->value + paramList->collectionSize) == pActiveSession)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
			pActiveSession = NULL;
			return (pActiveSession);
		}
		*pActiveSession++ = actSession;
	}
	else
	{
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pActiveSession);
}

static void *ParseKVMSessionEntry (unsigned char *s, CycParam *paramList, void *ptr)
{
	ActiveSessionInfo *pActiveSession = (ActiveSessionInfo *)ptr;
	ActiveSessionInfo actSession;
	unsigned char *p, *q, buf[256];

	dolog("ParseKVMSessionEntry() line=%s", s);
	
	memset(&actSession, 0, sizeof(ActiveSessionInfo));
	if (strstr(s, "KVM") != NULL || strstr(s, "USER") != NULL){
		dolog("ParseKVMSessionEntry: Skip Line");
		return (pActiveSession);
	}

	p = s;

	q = buf;
	while(*p && !isspace(*p)) *(q++) = *(p++);
	*q = 0;
	strcpy(actSession.user, buf);
	dolog("ParseKVMSessionEntry(): user=%s", buf);
	while(*p && isspace(*p)) p++;

	q = buf;
	while(*p && !isspace(*p)) *(q++) = *(p++);
	*q = 0;
	strcpy(actSession.tty, buf);
	while(*p && isspace(*p)) p++;

	q = buf;
	while(*p && !isspace(*p)) *(q++) = *(p++);
	*q = 0;
	strcpy(actSession.fromIp, buf);
	while(*p && isspace(*p)) p++;

	q = buf;
	while(*p && !isspace(*p)) *(q++) = *(p++);
	*q = 0;
	strcpy(actSession.loginTime, buf);

	if (pActiveSession != NULL)
	{
		dolog("Set current pHost to the host gotten and increment pHost");
		// !!! error check to see if param value has exceeded space allocated
		if (((ActiveSessionInfo *)paramList->value + paramList->collectionSize) == pActiveSession)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
			pActiveSession = NULL;
			return (pActiveSession);
		}
		*pActiveSession++ = actSession;
	}
	else
	{
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (pActiveSession);
}

//========================================================================
// ParseCommunityInfo - Parse a community entry in snmpd.conf
// The syntax of a community entry is:
// <rwcommunity or rocommunity> <community name> <source> <oid> 
//========================================================================
static void *ParseCommunityInfo(unsigned char *s, CycParam *paramList, void *p)
{
	CommunityInfo *pCommunity = (CommunityInfo *)p;
	CommunityInfo community = {{0}};	
	unsigned char *word=NULL;
	unsigned char *rwcommunity = "rwcommunity";
	unsigned char *rocommunity = "rocommunity";
	int i, numPossibleParams = 4;

	dolog("ParseCommunityInfo()");
	
	for (i=1; i<=numPossibleParams; i++) 
	{
		while (isspace(*s)) s++;
		word=s;
		while (*s && !isspace(*s)) s++;
		if (*s) *s++=0;
		//dolog("Word: %s", word);

		switch (i) 
		{
			case 1:
				//dolog("ParseCommunityInfo(): case 1: Word: %s", word);
				if (!strncmp(word, rwcommunity, strlen(rwcommunity)))
				{
					community.permission = kReadWrite;
				}
				else if (!strncmp(word, rocommunity, strlen(rocommunity)))
				{
					community.permission = kReadOnly;
				}
				break;
			case 2:
				//dolog("ParseCommunityInfo(): case 2: Word: %s", word);
				strncpy(community.communityName, word,kCommunityLength-1);
				break;
			case 3:
				//dolog("ParseCommunityInfo(): case 3: Word: %s", word);
				strncpy(community.source, word,kCommunitySourceLength-1);
				break;
			case 4:
				//dolog("ParseCommunityInfo(): case 4: Word: %s", word);
				strncpy(community.oid, word,kOidLength-1);
				break;
		} // end of switch loop
	}

	*pCommunity++ = community;
	return (pCommunity);
}

//========================================================================
// GetSnmpv3UserPasswd - Returns the snmpV3user password in 
// /etc/snmp/snmpd.local.conf.
// The format of this file is:
// createUser <user name> MD5 <password> DES 
//========================================================================
static unsigned char *GetSnmpv3UserPasswd(char *userName)
{
	unsigned char *buf, *t, *s, *name, *passwd=NULL;

	dolog("GetSnmpv3UserPasswd()\n");
	// Read the file snmpd.local.conf and writes it to the buffer
	if ((buf = ReadFile(SNMPD_LOCAL_FILE, 0)) == NULL) 
	{
		LogError(FILE_READ_ERROR, SNMPD_LOCAL_FILE);	
		return(NULL);
	}
	
	t = s = buf;
	
	while (*s)
  {
    while (*s && *s!='\n') s++;
    if (*s) *s++=0;		
		while (*t && !isspace(*t)) t++; // createUser
		while (*t && isspace(*t)) t++;
		name = t;
		while (*t && !isspace(*t)) t++; // user name
		if (*t) *t++=0;
		if (strcmp(name, userName))
		{
			t=s;
			continue;
		}
		while (*t && isspace(*t)) t++;
		if (strncmp(t, "MD5", 3))
		{
			t=s;
			continue;
		}
		while (*t && !isspace(*t)) t++; // MD5
		while (*t && isspace(*t)) t++;
		passwd = t;
		while (*t && !isspace(*t)) t++; // user name
		if (*t) *t++=0;
		//dolog("Passwd found: %s\n", passwd);	
		break;
	}

	free(buf);
	return (passwd);
}

//========================================================================
// ParseSnmpv3Info - Parse an user entry in snmpd.conf
// The syntax of an user  entry is:
// <rwuser or rouser> <user name> <auth option> <oid> 
//========================================================================
static void * ParseSnmpv3Info(unsigned char *s, CycParam *paramList, void *p)
{
	Snmpv3Info *pUser = (Snmpv3Info *)p;
	Snmpv3Info user = {{0}};	
	unsigned char *word=NULL, *passwd=NULL;
	unsigned char *rwuser = "rwuser";
	unsigned char *rouser = "rouser";
	int i, numPossibleParams = 4;

	dolog("ParseSnmpv3Info()");
	
	for (i=1; i<=numPossibleParams; i++) 
	{
		if (*s==0) continue;
		while (isspace(*s)) s++;
		word=s;
		while (*s && !isspace(*s)) s++;
		if (*s) *s++=0;
		//dolog("Word: %s", word);

		switch (i) 
		{
			case 1:
				//dolog("ParseSnmpv3Info(): case 1: Word: %s", word);
				if (!strncmp(word, rwuser, strlen(rwuser)))
				{
					user.permission = kReadWrite;
				}
				else if (!strncmp(word, rouser, strlen(rouser)))
				{
					user.permission = kReadOnly;
				}
				break;
			case 2:
				//dolog("ParseSnmpv3Info(): case 2: Word: %s", word);
				strncpy(user.userName, word, kUserNameLength-1);
				break;
			case 3:
				//dolog("ParseSnmpv3Info(): case 3: Word: %s", word);
				if (*word == '.')
					strncpy(user.oid, word,kOidLength-1);
				break;
			case 4:
				//dolog("ParseSnmpv3Info(): case 4: Word: %s", word);
				strncpy(user.oid, word, kOidLength-1);
				break;
		} // end of switch loop
	}

	if ((passwd = GetSnmpv3UserPasswd(user.userName)) != NULL)
		strncpy(user.password, passwd, kPasswordLength-1); 

	*pUser++ = user;
	return (pUser);
}
			
//========================================================================
// ParseMenuOpt - Parse /bin/menush.cfg for options
// The syntax of an option entry is:
// MENU_OPT<opt number>="<option name>%<option command>"
//========================================================================
static void ParseMenuOpt (FileBuffer *buf, MenuShOpt **opt, int currentOpt)
{
	char temp[12]={0};
	char optLine[BUF_CUSHION1]={0};
	char *line, *a, *shellValue;
	int len;
	
	MenuShOpt *currOpt = *opt;

	sprintf(temp, "MENU_OPT%d", currentOpt+1);
	if ((line = search_var(buf, temp, 0)) != NULL) 
	{
		get_value_from_config_line(line, buf, &shellValue, &len, 0);
		strncpy(optLine, shellValue, len);
		if ((a = strchr(optLine,'%')) != NULL)
		{
			*a=0;
			strncpy(currOpt->title, optLine,(kTitleLength-1));
			dolog("Menu option title%d: [%s]", currentOpt, currOpt->title);
			a++;	
			strncpy(currOpt->command, a, (kTitleLength-1));
			dolog("Menu option command%d: [%s]", currentOpt, currOpt->command);
		}
	}
}

//========================================================================
// WriteHostEntry - Manages the writing of a host entry. The syntax of 
// a host entry line is: <ip address> <host name> 
//========================================================================
static Result WriteHostEntry (unsigned char *filename, CycParam *paramList)
{
	FILE *fp;
	int i;
	Hosts *pHost = (Hosts *)paramList->value;
	
	dolog("WriteHostEntry()");

	if (!pHost) {
		syslog(LOG_ERR, "paramList is null");
		return(kFileWriteError);
	}
 	if ((fp = fopen (filename, "w")) == NULL) {
		LogError(FILE_WRITE_ERROR, filename);
		return (kFileWriteError);
	}

	for(i = 0; i < paramList->collectionSize; i++, pHost++) {
		fprintf (fp, "%s\t%s", pHost->hostIp, pHost->hostName);
		if(pHost->hostAlias[0] != 0)
			fprintf(fp, "\t%s", pHost->hostAlias);
		fprintf(fp, "\n");
	}

	fclose(fp);
	return (kCycSuccess);
}

//========================================================================
// Handles the characters "# ( ) ' " ; < > ` \"
//========================================================================

static char mustBeEscaped[] = "#()'\";<>`\\?*&";
static char escapedName[128];

static char *EscapeUserPasswd(char *str)
{
	int i = 0;

	for ( ; *str; ) {
		if (strchr(mustBeEscaped, *str)) {
			escapedName[i++] = '\\';
		}
		escapedName[i++] = *str++;
	}

	escapedName[i] = 0;
	return(escapedName);
}

//========================================================================
// WriteUserEntry - Write a Users entry. 
//========================================================================
static Result WriteUserEntry (unsigned char *filename, CycParam *paramList)
{
	char buffer[256] = {0};
	Users *pUser;
	int size, i;
	FILE *fp;

  dolog("WriteUserEntry()");

  pUser = (Users *)paramList->value;
	
	for (i=0; i<paramList->collectionSize; i++, pUser++)
	{
		if (pUser->action == kDelete)
		{
			sprintf(buffer, "deluser %s 2>%s",
				EscapeUserPasswd(pUser->userName), WEB_TEMP_FILE);
			system(buffer);
			sprintf(buffer, "rm -rf %s",  pUser->homeDir);
			system(buffer);
			if ((fp = fopen(WEB_TEMP_FILE, "r")) == NULL) 
			{
				LogError(FILE_READ_ERROR, WEB_TEMP_FILE);
				return (kFileReadError);
			}
			buffer[fread(buffer, 1, 127, fp)]=0;
			fclose(fp);
			system("rm -f /tmp/webtemp");
			if (!(*buffer)) 
			{
				strcpy(pUser->sysMsg, buffer);
			}
			/* warning: implicit declaration of function `CycGetCurrentAdmin'
                         syslog(LOG_INFO, "%s: User [%s] deleted by user [%s]", 
                                TAG_CONFIG, pUser->userName, CycGetCurrentAdmin());*/
			syslog(LOG_INFO, "%s: User [%s] deleted by user [%s]", TAG_CONFIG, pUser->userName, (char *)CycGetCurrentAdmin());

			/* Deleting the access list file for this user, if exists */
			sprintf(buffer, "/etc/kvm/kvm.%s", pUser->userName);
			if (unlink(buffer) == 0)
				syslog(LOG_INFO, "%s - access list for user %s has been deleted",
					TAG_CONFIG, pUser->userName);
		}
		if (pUser->action == kAdd)
		{
			if (*(pUser->passWord))
			{
				if (strcmp(pUser->passWord, pUser->passWord2))
				{
					dolog("Passwords do not match");
					strcpy(pUser->sysMsg, "Passwords do not match.");
					return (kPasswordNotMatch);
				}
				strcpy(buffer, "adduser -P ");
				strcat(buffer, EscapeUserPasswd(pUser->passWord));
			}
			else 
			{
				strcpy(buffer, "adduser ");
			}

			/*if (*(pUser->homeDir))
			{
				strcat(buffer, " -h ");
				strcat(buffer, pUser->homeDir);
			}*/

			if (*(pUser->shell))
			{
				//[RK]Jan/10 - put the shell between quotation marks 
				strcat(buffer, " -s \"");
				strcat(buffer, pUser->shell);
				strcat(buffer, "\"");
			}

			if (pUser->groupAdminReg == kAdminUser) // If group is kAdmin
			{
				strcat(buffer, " -G "ADMIN_GROUP);
				if (pUser->groupBio == kBioUser)
					strcat(buffer, ",biouser");
			} else {
				if (pUser->groupBio == kBioUser)
					strcat(buffer, " -G biouser");
			}

			if (*(pUser->comments))
			{
				strcat(buffer, " -c "); 
				size = strlen(buffer);
				buffer[size] = '"';
				buffer[size+1] = 0x00;
				strcat(buffer, pUser->comments);
				buffer[size=strlen(buffer)] = '"';
				buffer[size+1] = 0x00;
			}
			strcat(buffer, " ");

			//[LMT] It does not create if user is admin because group admin already exists.
			//if(! strcmp( pUser->userName, ADMIN_GROUP ))
			//	strcat(buffer, "-g "ADMIN_GROUP" ");	

			strcat(buffer, EscapeUserPasswd(pUser->userName));
			strcat(buffer, " < /dev/null >/tmp/webtemp2 2>/tmp/webtemp2");
			dolog("Buffer1: %s", buffer);
			system(buffer);
			if ((fp = fopen("/tmp/webtemp2", "r")) == NULL) 
			{
				LogError(FILE_READ_ERROR, "/tmp/webtemp2");
				return (kFileReadError);
			}
			buffer[fread(buffer, 1, 256, fp)]=0;
			fclose(fp);
			dolog("Buffer2: %s", buffer);
			system("rm -f /tmp/webtemp2");
			// !! buffer contains error message. Return error code depending on error message

			if (*buffer) 
			{
				if (strstr(buffer, "login already in use") == NULL)
				{
					strcpy(pUser->sysMsg, buffer);
					dolog("User was unsuccessfully added.");
					LogError("User, %s, was unsuccessfully added.", pUser->userName);
					return(kAddUserFailed);
				}
			}
			dolog("User was successfully added");
			sprintf(buffer, "User, %s, was successfully added.", pUser->userName);
			strcpy(pUser->sysMsg, buffer);
			syslog(LOG_INFO, "%s: User [%s] added by user [%s]", TAG_CONFIG, 
				pUser->userName, (char *)CycGetCurrentAdmin());	
		}
		
		if (pUser->action == kEdit)
		{
			if (strcmp(pUser->passWord, pUser->passWord2) != 0) 
			{
				LogError("Passwords for user, %s, did not match.", pUser->userName);
				return(kPasswordNotMatch);
			} 
			fp = fopen("/tmp/webtemp", "w");
			fprintf(fp, "%s\n%s\n", pUser->passWord, pUser->passWord2);
			fclose(fp);
			chmod("/tmp/webtemp", 0600);
			sprintf(buffer, "passwd -p %s</tmp/webtemp >/tmp/webtemp2 2>/tmp/webtemp2", EscapeUserPasswd(pUser->userName));
			system(buffer);
			system("rm -f /tmp/webtemp");
			if ((fp = fopen("/tmp/webtemp2", "r")) != NULL) 
			{
				buffer[fread(buffer, 1, 256, fp)]=0;
				fclose(fp);
			}
			system("rm -f /tmp/webtemp2");

			if (*buffer) 
			{
				LogError("Change password for user, %s, was unsuccessful.", pUser->userName);
				strcpy(pUser->sysMsg, buffer);
				return(kChangePasswordFailed);
			}
			sprintf(buffer, "Change password for user, %s, was successful.", pUser->userName);
			strcpy(pUser->sysMsg, buffer);
			syslog(LOG_INFO, "%s: Password changed for user [%s] by user [%s]", 
				TAG_CONFIG, pUser->userName, (char *)CycGetCurrentAdmin()); 
		}
	}
	return (kCycSuccess);
}

//========================================================================
// WriteIpSecSecret - Write the secret for each connection into
// /etc/ipsec.secret.
//========================================================================
static Result WriteIpSecSecret(CycParam *paramList)
{
	FILE *fp, *fpt;
	int collectionSize;
	struct stat st;

	IpSecInfo *pIpSec = (IpSecInfo *)paramList->value;
	collectionSize = paramList->collectionSize;

	dolog("WriteIpSecSecret()");

	if (! stat(IPSEC_SECRET_FILE, &st)) {
		unsigned char *buf= (unsigned char *)malloc(st.st_size+1);
		unsigned char *s = buf;
		if (buf) {
			memset(buf, 0, st.st_size+1);
			fp = fopen (IPSEC_SECRET_FILE, "r");
			fpt = fopen (IPSEC_SECRET_FILE".tmp", "w");
			if (fp && fpt) {
				chmod(IPSEC_SECRET_FILE".tmp", 0600);
				while(fgets(s, st.st_size, fp)) {
// Copy everything but PSK to ipsec.secrets temp file to preserv RSA.
					if ((*s != '#') && !strstr(s, "PSK")) {
						fprintf(fpt, "%s", s);
					}
				}
			}
			fclose(fp);
			fclose(fpt);
			free(buf);
			unlink (IPSEC_SECRET_FILE);
			if (! stat(IPSEC_SECRET_FILE".tmp", &st)) {
				rename(IPSEC_SECRET_FILE".tmp", IPSEC_SECRET_FILE);
			}
		}
	}

	if ((fp = fopen(IPSEC_SECRET_FILE, "a")) == NULL)
	{
		LogError(FILE_WRITE_ERROR, IPSEC_SECRET_FILE);
		return (kFileWriteError);
	}

        //[LMT] CyBts BUG 4481	
	chmod(IPSEC_SECRET_FILE, 0600);

 	for (; collectionSize--; pIpSec++)
	{
		if (pIpSec->action != kDelete && pIpSec->aMethod == kIpSecSecret)
		{
			fprintf(fp, "#%s\n", pIpSec->connectionName);
			fprintf(fp, "%s %s: PSK \"%s\"\n", pIpSec->leftId, pIpSec->rightId, pIpSec->secret);
		}
	}

	fclose(fp);
	return(kCycSuccess);	
}

//========================================================================
// WriteIpSecEntry - Write a Ipsec connection entry. 
//========================================================================
static Result WriteIpSecEntry (unsigned char *filename, CycParam *paramList)
{
	FILE *fp;
	IpSecInfo *pIpSec;
	char fileName[50];
	char fileName2[50];
	int collectionSize;
	int i;
		
	dolog("WriteIpSecEntry()");
	
	pIpSec = (IpSecInfo *)paramList->value;
	collectionSize = paramList->collectionSize;

	for (; collectionSize--; pIpSec++)
	{
		if (*(pIpSec->connectionName)) 
		{
			if (pIpSec->action == 0) {
				continue;
			}

			sprintf(fileName, "%s%s.connection", filename, pIpSec->connectionName);
			dolog("WriteIpSecEntry(): File to modify: %s", fileName);
			if (pIpSec->action == kDelete)
			{
				remove(fileName);
				continue;
			}
			if (pIpSec->action == kEdit && strcmp(pIpSec->oldConnectionName, pIpSec->connectionName))
			{
				sprintf(fileName2, "%s%s.connection", filename, pIpSec->oldConnectionName);
				remove(fileName2);
			}
			if ((fp = fopen(fileName, "w")) == NULL)
			{
				LogError(FILE_WRITE_ERROR, fileName);
				return (kFileWriteError);
			}
			fprintf(fp, "conn %s\n", pIpSec->connectionName);
		}
		else 
		{
			LogError("No Ipsec connection name defined.");
			return (kMissingConnectionName);
		}

		for (i = 0; i < SIZE_IpSecParams; i++) {
			if ((IpSecParams+i)->type == TY_IPSEC_STR) {
				if (*((char *)pIpSec+(IpSecParams+i)->off)) {
					fprintf(fp, "\t%s=%s\n",
						(IpSecParams+i)->paramName,
						(char *)pIpSec+(IpSecParams+i)->off);
				}
			}

			if ((IpSecParams+i)->type == TY_IPSEC_LIST) {
				fprintf(fp, "\t%s=%s\n",
					(IpSecParams+i)->paramName,
					TransOptGetStr(
						(IpSecParams+i)->listOptions,
						(IpSecParams+i)->nOptions,
						*(int *)((char *)pIpSec + (IpSecParams+i)->off)));
			}
		}

		fclose(fp);
	}

	return(kCycSuccess);
}

//========================================================================
// WriteStRoutesEntry - Write a static route entry. 
//========================================================================
static Result WriteStRoutesEntry (unsigned char *filename, CycParam *paramList)
{
	FILE *fp;
	StRoutesInfo *pRoutes = (StRoutesInfo *)paramList->value;
	int i;
	
	executeFlg |= EXE_SIGNAL_RAS;

  dolog("WriteStRoutesEntry()");

  if ((fp = fopen (filename, "w")) == NULL)
	{
		LogError(FILE_WRITE_ERROR, filename);
		return (kFileWriteError);
	}

	for (i=0; i<paramList->collectionSize; i++)
	{
		fprintf(fp, "/sbin/route add ");
		
		switch (pRoutes->routeType)
		{
			case kRtDefault:
				fprintf(fp,"default ");
				break;
			case kRtNetwork:
				fprintf (fp, "-net %s ", pRoutes->destinationIp);
				if (!*(pRoutes->destinationMask)) 
				{
					sprintf(pRoutes->sysMsg, "No netmask configured.");
					return(0);
				}
				fprintf (fp, "netmask %s ", pRoutes->destinationMask);
				break;
			case kRtHost:
				fprintf (fp, "-host %s ", pRoutes->destinationIp);
				break;
		}
		if (pRoutes->goTo == kRgtGateway)
		{
			fprintf(fp, "gw %s ", pRoutes->gateWay);
		}
		else 
		{
			fprintf(fp, "dev %s ", pRoutes->routeInterface);
		}
		if (*(pRoutes->metric))
		{
			fprintf (fp, "metric %s", pRoutes->metric);
		}
		fprintf (fp, "\n"); 
		pRoutes++;
	}

	fclose(fp);
	return (kCycSuccess);
}

//========================================================================
// WriteRoutingTableEntry - Write a Users entry. 
//========================================================================
static Result WriteRoutingTableEntry (unsigned char *filename, CycParam *paramList)
{
	FILE *fp;
  unsigned char buffer[256];
	RoutingTableEntry *pRoutes = (RoutingTableEntry *)paramList->value;

  dolog("WriteRoutingTableEntry()");

  strcpy(buffer, "route add ");
	if (!*(pRoutes->destinationIp) && !*(pRoutes->hostIp))
		strcat(buffer, "default ");
	else if (*(pRoutes->destinationIp) && !*(pRoutes->hostIp))
	{
		sprintf(buffer+strlen(buffer), "-net %s ", pRoutes->destinationIp);
		if (!*(pRoutes->destinationMask)) 
		{
			dolog("Return error: No Mask");
		}
		else
			sprintf(buffer+strlen(buffer), "netmask %s ", pRoutes->destinationMask);
	}
	else if (*(pRoutes->hostIp) && !*(pRoutes->destinationIp))
	{
		sprintf(buffer+strlen(buffer), "-host %s ", pRoutes->hostIp);
	}
	else 
		dolog("Return sys ERROR. a field missing.");
	if (*(pRoutes->gateWay))
	{
		sprintf(buffer+strlen(buffer), "gw %s ", pRoutes->gateWay);
	} 
	else if (*(pRoutes->routeInterface))
	{
		sprintf(buffer+strlen(buffer), "dev %s ", pRoutes->routeInterface);
	}

	dolog("Buffer: %s", buffer);

  strcat(buffer, ">/tmp/webtemp2 2>/tmp/webtemp2");
  system(buffer);

  if ((fp = fopen("/tmp/webtemp2", "r")) != NULL) 
	{
    buffer[fread(buffer, 1, 255, fp)]=0;
    fclose(fp);
  }
  system("rm -f /tmp/webtemp2");
  if (!(*buffer)) 
	{
		dolog("Route was successfully added");
		return (kCycSuccess); 
	}
	else
	{
		strcpy(pRoutes->sysMsg, buffer);
		dolog("Route was unsuccessfully added");
		return (kAddRouteFailed);
	}
}

//========================================================================
// WriteCommunityInfo - Write a snmpd community configuration 
//========================================================================
static void WriteCommunityInfo(FILE *fp, CycParam *paramList, CommunityInfo *p)
{
	if (p->permission)
		fprintf(fp, "%s ", "rwcommunity");
	else
		fprintf(fp, "%s ", "rocommunity");

	if (*(p->communityName))
	{
		fprintf (fp, "%s ", p->communityName);
	} 
	if (*(p->source))
	{
		fprintf (fp, "%s ", p->source);
	}
	if (*(p->oid))
	{
		fprintf (fp, "%s", p->oid);
	}
	fprintf (fp, "\n"); 

	return; 
}

//========================================================================
// WriteSnmpv3Info - Write a snmpV3 user configuration 
//========================================================================
static void WriteSnmpv3Info(FILE *fp, FILE *fp2, CycParam *paramList, Snmpv3Info *pUser)
{
	if (pUser->permission)
		fprintf(fp, "%s ", "rwuser");
	else
		fprintf(fp, "%s ", "rouser");

	if (*(pUser->userName))
	{
		fprintf (fp, "%s ", pUser->userName);
		fprintf(fp2, "createUser %s MD5 %s DES\n", pUser->userName, pUser->password);
	} 
	if (*(pUser->oid))
	{
		fprintf (fp, "%s", pUser->oid);
	}
	fprintf (fp, "\n"); 
}

//========================================================================
// ReadEntries - Depending on the flag, obtain the number of entries 
// for hosts, routes, ipsec, or parse and return the value of the entries
//========================================================================
static Result ReadEntries(void *ptr, CycParam *paramList, int returnEntriesFlg)
{
	// returnEntriesFlg=1 -> read and get number of entries only
	// returnEntriesFlg=0 -> read and parse the entries and return the entries

	unsigned char *buf, *t, *s, *r;
	void *p = NULL;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	struct stat statinfo;
	int session_type = 0; //0=login, 1=CAS, 2=KVM

	dolog("ReadEntries()");

	if (!returnEntriesFlg)
	{		
		dolog("Get param requested");
		p = paramList->value;
	}			

	if (pCkIndex->category == kRoutingTable)
		system("netstat -rn -ee > /tmp/webtemp");
	else if (pCkIndex->category == kActiveSessions) 
		system("w > /tmp/webtemp");
	else if (pCkIndex->category == kUnitInfo)
		system("df > /tmp/webtemp");

	if ((buf = ReadFile(pCkIndex->fileName, 0)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	t=buf;

	if (!t) return(0);		
	
	while (*t) {
		// Gets one line, which could be an entry. 
		s = t;
		while (*t && *t != '\n') t++;
		if (*t) *t++=0;

		// Skips the blank lines 
		r = s;
		while (isspace(*r)) r++;
		if (*s == 0 || *r == 0) continue;

		if (pCkIndex->category == kActiveSessions && strstr(s, "CAS") != NULL)
			session_type = 1;
		if (pCkIndex->category == kActiveSessions && strstr(s, "KVM") != NULL)
			session_type = 2;

		if (session_type == 1) {
			if ((p = (*(ParseCasSessionEntry))(s, paramList, p)) != NULL) continue;
		}else if (session_type == 2) {
			if ((p = (*(ParseKVMSessionEntry))(s, paramList, p)) != NULL) continue;
		} else {

			// Parse and separate <first param> <2nd param>
			// Parses the line and gets the values for each parameter 
			if ((p = (*(pCkIndex->parser))(s, paramList, p)) != NULL) 
			{
				continue;
			}
                        dolog("ReadEntries(): After parsing. T: %s, S: %s", t, s);
		}
	}

	if (!stat("/tmp/webtemp", &statinfo)) // check if /tmp/webtemp is there
	{
		system("rm -f /tmp/webtemp");
	}

	free(buf);
	return (kCycSuccess); 
}

//========================================================================
// ReadWriteIdeConfig - Write Pcmcia IDE compact flash config
// [rdWrtFlg = 1 => write, rdWrtFlg = 0 => read]
// In this file, the format of information is:
// *,*,*,1) (delimiter that I use to check if set 1 info is here)
//   info...(1st set of information)
//   ;;
// *,*,*)   (delimiter that I use to check if set 2 info is here)
//   info...(2nd set of info)
//   ;;
// esac
// For reading, I make sure certain information is in the file. If it
// is all there, then I say compact flash config is enabled.  
//========================================================================
static Result ReadWriteIdeConfig(int rdWrtFlg, PcmciaFlashConfig *flash, PcmciaInfo *pInfo, int slot)	
{
	FileBuffer *buf;
	char *line, *line2;
	char val[BUF_CUSHION2]={0};
	int flgIns, len;
	int allParamFound=0;
	char *shellValue;
	char *mountPt = "/mnt/ide";

	dolog("ReadWriteIdeConfig()");

	if (rdWrtFlg && pInfo->pcmciaType.flash.both != 3 &&
		 (slot+1 != pInfo->pcmciaType.flash.both)) return(kCycSuccess);

  if ((buf = read_file(IDE_OPTS_FILE)) == NULL) 
	{
		LogError(FILE_READ_ERROR, IDE_OPTS_FILE);	
    return(kFileReadError);
  }

	// Check if there is a 'esac' anywhere in the file. 
	if ((line = search_var(buf, "esac", 0)) == NULL) {
		{
			line = buf->buf;
			flgIns=2;
			insert_line(line, buf, "esac\n", flgIns);
		}
	} else {
		if (!rdWrtFlg) allParamFound++;
	}
	
	// see if there is entry "*,(slot #),*,1)" or "#*,(slot #),*,1)"
	sprintf(val, "*,%d,*,1)", slot);

	if ((line = search_var(buf, val, 0)) == NULL) {
		line = search_var(buf, val, 1);
	}	

	if (line == NULL) 
	{
		if (rdWrtFlg) {
			flgIns = 1;
			if ((line = search_var(buf, "case", 0)) == NULL) {
				line = buf->buf;
				flgIns = 2;
				sprintf(val, "case \"$ADDRESS\" in\n    *,%d,*,1)\n    #INFO=\"IDE HDA%d setup\"\n    DO_FSTAB=\"y\"\n    DO_MOUNT=\"y\"\n    FSTYPE=\"ext2\"\n    MOUNTPT=\"%s\"\n    [ -d $MOUNTPT ] || mkdir $MOUNTPT\n    ;;\n", slot, slot+1, mountPt);
			} else {	
				sprintf(val, "*,%d,*,1)\n    #INFO=\"IDE HDA%d setup\"\n    DO_FSTAB=\"y\"\n    DO_MOUNT=\"y\"\n    FSTYPE=\"ext2\"\n    MOUNTPT=\"%s\"\n    [ -d $MOUNTPT ] || mkdir $MOUNTPT\n    ;;\n", slot, slot+1, mountPt);
			}
			if (pInfo->pcmciaType.flash.enable[slot] == kYes)
				insert_line(line, buf, val, flgIns);
		}
	} 
	else // if entry is found, either comment it or uncomment it
	{
		if (rdWrtFlg) 
		{
			if (pInfo->pcmciaType.flash.enable[slot] == kNo) {
				if (*line != '#') {
					insert_line(line, buf, "#", 0);
					write_file(buf, IDE_OPTS_FILE);
					free(buf);
					return(kCycSuccess);
				}
			} else {
				if (*line == '#') {
					delete_chars(line, buf, 1);
				}
			}
		} 
		if (!rdWrtFlg && *line != '#') allParamFound++;
		if ((line2 = search_var_within_section(line, buf, ";;", 0)) != NULL)
		{
			if (!rdWrtFlg) {
				allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    ;;\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "[ -d $MOUNTPT ] || mkdir $MOUNTPT", 0)) != NULL)
		{
			if (!rdWrtFlg) {
				allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    [ -d $MOUNTPT ] || mkdir $MOUNTPT\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "MOUNTPT", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, mountPt, 0);
			}
			else
			{
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("MOUNTPT: %s, len: %d", shellValue, len);
				if (!strncmp(shellValue, mountPt, len))
					allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    MOUNTPT=\"%s\"\n", mountPt);
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "FSTYPE", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, "ext2", 0);
			}
			else
			{
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("FSTYPE: %s, len: %d", shellValue, len);
				if (!strncmp(shellValue, "ext2", len))
					allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    FSTYPE=\"ext2\"\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "DO_MOUNT", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, "y", 0);
			}	
			else
			{
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("DO_MOUNT: %s, Len: %d", shellValue, len);
				if (!strncmp(shellValue, "y", len))
					allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    DO_MOUNT=\"y\"\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "DO_FSTAB", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, "y", 0);
			}	
			else
			{
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				if (!strncmp(shellValue, "y", len))
					allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    DO_FSTAB=\"y\"\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		/*if ((line2 = search_var_within_section(line, buf, "DO_FSCK", 0)) != NULL)
		{
				if (rdWrtFlg)
				{
					replace_Value(line2, buf, "y", 0);
				}
				else
				{
					get_value_from_config_line(line2, buf, &shellValue, &len, 0);
					//dolog("DO_FSCK: %s, len: %d", shellValue, len);
					if (!strncmp(shellValue, "y", len))
						allParamFound++;
				}
			} else {
				if (rdWrtFlg) {
					flgIns = 1;
					sprintf(val, "    DO_FSCK=\"y\"\n");
					insert_line(line, buf, val, flgIns);
				}
		  }*/
	}
		
	if ((line = search_var(buf, "*,*,*)", 0)) == NULL)
	{
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "esac", 0)) == NULL) {
					line = buf->buf;
					flgIns=2;
			}
			sprintf(val, "*,*,*)\n    PARTS=\"1\"\n    NO_CHECK=\"n\"\n    NO_FUSER=\"n\"\n    ;;\n");
			insert_line(line, buf, val, flgIns);
		}
	}
	else
	{
		if (!rdWrtFlg) allParamFound++;
		if ((line2 = search_var_within_section(line, buf, ";;", 0)) != NULL)
		{
			if (!rdWrtFlg) {
				allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    ;;\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "NO_FUSER", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, "n", 0);
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    NO_FUSER=\"n\"\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "NO_CHECK", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, "n", 0);
			}	
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    NO_CHECK=\"n\"\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "PARTS", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, "1", 0);
			}
			else
			{
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("PARTS: %s, len: %d", shellValue, len);
				if (!strncmp(shellValue, "1", len))
					allParamFound++;
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    PARTS=\"1\"\n");
				insert_line(line, buf, val, flgIns);
			}
		}
	}


	if (rdWrtFlg) {
		write_file(buf, IDE_OPTS_FILE);
	}

	if (!rdWrtFlg && (allParamFound == 11)) {
			flash->enable[slot] = kYes;	
	}
	
  free(buf);
  return(kCycSuccess);
}

//========================================================================
// ReadWriteDbIdeConfig - Read file to see if compact flash is enabled 
// for data buffering. Write to file to enable/disable db in flash 
//========================================================================
static Result ReadWriteDbIdeConfig(int rdWrtFlg, PcmciaFlashConfig *flash, int enableDb)	
{
	FileBuffer *buf;
	char *line;
	char val[BUF_CUSHION1], temp[5];
	int flgIns, len;
	char *shellValue;

	dolog("ReadWriteDbIdeConfig()");

  if ((buf = read_file(CYBUFFERING_SHELL)) == NULL) 
	{
		LogError(FILE_READ_ERROR, CYBUFFERING_SHELL);	
    return(kFileReadError);
  }

	if ((line = search_var(buf, "FS_LOC", 0)) == NULL) {
    if (rdWrtFlg) {
      flgIns = 0;
      if ((line = search_var(buf, "DPARM", 0)) == NULL) {
        line = buf->buf;
        flgIns=1;
      }
			build_shell_line(val, "FS_LOC", TransOptGetStr(FlashDbOptions, SIZE_FlashDbOptions, enableDb), 1);
      insert_line(line, buf, val, flgIns);
    }
		else {
			flash->dataBuf = kNo;
		}
  } else {
    if (rdWrtFlg) {
      replace_Value(line, buf, TransOptGetStr(FlashDbOptions, SIZE_FlashDbOptions, enableDb), 0);
    } else {
			get_value_from_config_line(line, buf, &shellValue, &len, 1);
			strncpy(temp, shellValue, len);
			flash->dataBuf=TransOptGetVal(FlashDbOptions, SIZE_FlashDbOptions, temp, strlen(temp));
    }
  }

  if (rdWrtFlg) {
    write_file(buf, CYBUFFERING_SHELL);
  }
  free(buf);
  return(kCycSuccess);
}

//========================================================================
// ReadWriteFlashConfig - Read/Write Pcmcia flash configuration
//========================================================================
static Result ReadWriteFlashConfig(PcmciaFlashConfig *flash, PcmciaInfo *pPcmciaInfo, int rdWrtFlg) 
{
	Result result = kCycSuccess;
	int i;

  dolog("ReadWriteFlashConfig()");

	// Modify the config file
	for (i=0; i<kMaxPcmciaSlots; i++) {
		ReadWriteIdeConfig(rdWrtFlg, flash, pPcmciaInfo, i);
		if (!rdWrtFlg && !ServiceActive(CYBUFFERING_SHELL, "ENABLE", kNo, 0)) 
			flash->enable[i] = kNo;
	}

	if (rdWrtFlg)
	{
		// Make sure this is always Yes
		ServiceActive(CYBUFFERING_SHELL, "ENABLE", kYes, rdWrtFlg); 

		if ((result = ReadWriteDbIdeConfig(rdWrtFlg, flash, pPcmciaInfo->pcmciaType.flash.dataBuf)) != kCycSuccess) {
			return (result);
		}
	} else {
		if ((result = ReadWriteDbIdeConfig(rdWrtFlg, flash, 0)) != kCycSuccess) {
			return (result);
		}
	}
				
	// Assuming card has already been inserted, eject and insert again so config file gets read again
	// I think we can just do an insert because it reloads the drivers. 
	/*if (rdWrtFlg && pPcmciaInfo->pcmciaType.flash.enable == kYes) 
	{
		sprintf(command, "cardctl insert %d", pPcmciaInfo->slot);
		dolog("COMMAND: %s", command);
		//system(command);
	}*/

	return (result);
}

//========================================================================
// ReadWriteIsdnConfig - Read/Write Pcmcia isdn config info
//========================================================================
static Result ReadWriteIsdnConfig(PcmciaIsdnConfig *isdn, PcmciaInfo *pPcmciaInfo, int rdWrtFlg) 
{
  FileBuffer *buf;
  char *line;
  char val[BUF_CUSHION1];
  int flgIns, len;
	char *shellValue;
	char temp[10]={0};

	dolog("readWriteIsdnConfig");

	/** Get or Set LocalIp info **/
  if ((buf = read_file(ISDN_OPTS_FILE)) == NULL) {
		LogError(FILE_READ_ERROR, ISDN_OPTS_FILE);	
    return(kFileReadError);
  }
	if ((line = search_var(buf, "LOCALIP", 0)) == NULL) 
	{
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "ipppd_options", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_shell_line(val, "LOCALIP", pPcmciaInfo->pcmciaType.isdn.localIp, 0);
			insert_line(line, buf, val, flgIns);
		}
	} 
	else 
	{
		if (rdWrtFlg) {
			if (*(pPcmciaInfo->pcmciaType.isdn.localIp))
				replace_Value(line, buf, pPcmciaInfo->pcmciaType.isdn.localIp, 0);
		} else {
				get_value_from_config_line(line, buf, &shellValue, &len, 0);
				strncpy(isdn->localIp, shellValue, len);
		}
	}

	/** Get or Set RemoteIp info **/
	if ((line = search_var(buf, "REMOTEIP", 0)) == NULL) 
	{
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "ipppd_options", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_shell_line(val, "REMOTEIP", pPcmciaInfo->pcmciaType.isdn.remoteIp, 0);
			insert_line(line, buf, val, flgIns);
		}
	} 
	else 
	{
		if (rdWrtFlg) {
			if (*(pPcmciaInfo->pcmciaType.isdn.remoteIp))
				replace_Value(line, buf, pPcmciaInfo->pcmciaType.isdn.remoteIp, 0);
		} else {
				get_value_from_config_line(line, buf, &shellValue, &len, 0);
				strncpy(isdn->remoteIp, shellValue, len);
		}
	}

	// Change dialin to yes to allow dial in
	if ((line = search_var(buf, "DIALIN_REMOTENUMBER", 0)) != NULL) 
	{
		
		/* WebApi.c:6213: warning: passing arg 1 of `search_var' from incompatible pointer type
		if ((line = search_var(line, "DIALIN", 0)) == NULL) {*/
		if ((line = search_var((FileBuffer *)line, "DIALIN", 0)) == NULL) {
			if (rdWrtFlg) {
				flgIns = 0;
				if ((line = search_var(buf, "ipppd_options", 0)) == NULL) {
					line = buf->buf;
					flgIns=1;
				}
				build_shell_line(val, "DIALIN", "yes", 0);
				insert_line(line, buf, val, flgIns);
			}
		} else {
			if (rdWrtFlg) {
				replace_Value(line, buf, "yes", 0);
			} 
			else {
				get_value_from_config_line(line, buf, &shellValue, &len, 0);
				if (strncmp(shellValue, "yes", len)) {
					// If dialin is NO, then clear localip/remoteip
					// that way users will be forced to configure the ips
					// and then all other paramters will be set correctly.
					memset(isdn->localIp, 0, kIpLength);	
					memset(isdn->remoteIp, 0, kIpLength);	
				}
			}
		}
	}

	// Change dialin authentication to auth login to use the defaults of pam
	if ((line = search_var(buf, "DIALIN_AUTHENTICATION", 0)) == NULL) 
	{
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "ipppd_options", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_shell_line(val, "DIALIN_AUTHENTICATION", "auth login", 0);
			insert_line(line, buf, val, flgIns);
		}
	} 
	else 
	{
		if (rdWrtFlg) {
			replace_Value(line, buf, "auth login", 0);
		} 
	}

	/** Get or Set Callback info **/
	if ((line = search_var(buf, "CALLBACK", 0)) == NULL) 
	{
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "ipppd_options", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_shell_line(val, "CALLBACK", 
				TransOptGetStr(IsdnCallbackOptions, SIZE_IsdnCallbackOptions, pPcmciaInfo->pcmciaType.isdn.callBack), 0);
			insert_line(line, buf, val, flgIns);
		}
	} 
	else 
	{
		if (rdWrtFlg) {
				replace_Value(line, buf, 
					TransOptGetStr(IsdnCallbackOptions, SIZE_IsdnCallbackOptions, pPcmciaInfo->pcmciaType.isdn.callBack), 0);
		} else {
				get_value_from_config_line(line, buf, &shellValue, &len, 0);
				strncpy(temp, shellValue, len);
				isdn->callBack=TransOptGetVal(IsdnCallbackOptions, SIZE_IsdnCallbackOptions, temp, strlen(temp));
		}
	}

	/** Get or Set Callback number info **/
	if ((line = search_var(buf, "DIALOUT_REMOTENUMBER", 0)) == NULL) 
	{
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "ipppd_options", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_shell_line(val, "DIALOUT_REMOTENUMBER", pPcmciaInfo->pcmciaType.isdn.callBackNum, 0);
			insert_line(line, buf, val, flgIns);
		}
	} 
	else 
	{
		if (rdWrtFlg) {
			if (*(pPcmciaInfo->pcmciaType.isdn.callBackNum))
				replace_Value(line, buf, pPcmciaInfo->pcmciaType.isdn.callBackNum, 0);
		} else {
				get_value_from_config_line(line, buf, &shellValue, &len, 0);
				strncpy(isdn->callBackNum, shellValue, len);
		}
	}

	if (rdWrtFlg) {
		write_file(buf, ISDN_OPTS_FILE);
	}

  free(buf);
	return(kCycSuccess);
}

//[GY]===================================================================
// ReadWriteModemMgettyConfig - Read/Write additional Pcmcia CDMA config.
// parameters (speed and addinit) in mgetty.config file
//=======================================================================
static Result ReadWriteModemMgettyConfig(PcmciaModemGsmConfig *modemGsm,
                PcmciaInfo *pPcmciaInfo, int rdWrtFlg, int slot)
{
  FileBuffer *buf;
  char *line, *line2, *line3;
  char val[BUF_CUSHION1];
  int flgIns, len;
  char *shellValue;
  char temp[60] = {0};
  char ttyDevice[6] = {0};
  char *dataOnlyVal = "y";
  char *initchatVal = "\"\" \\d\\d\\d+++\\d\\d\\dATZ OK";
  char *cdmaCmd = "AT$QCVAD=4 OK";

  dolog("ReadWriteModemMgettyConfig()");

  if( (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.speedBoth != 3 &&
      (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.speedBoth)) &&
      (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.addinitBoth != 3 &&
      (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.addinitBoth)) ) {
    return(kCycSuccess);}

  if( (buf = read_file(MGETTY_CONFIG_FILE)) == NULL ) {
    LogError(FILE_READ_ERROR, MGETTY_CONFIG_FILE);
    return(kFileReadError);
  }

  sprintf(ttyDevice, "ttyM%d", slot + 1);
  sprintf(temp, "port %s", ttyDevice);

  if( (line = search_var(buf, temp, 0)) == NULL ) {
    if( rdWrtFlg ) {
      dolog("No port ttyM1|2 found");
      line = buf->buf;
      flgIns = 2;
      sprintf(val, "%s %s\n   speed %d\n   data-only %s\n   init-chat %s %s %s\n",
                   "port", ttyDevice, pPcmciaInfo->pcmciaType.modemGsm.speed[slot], dataOnlyVal, initchatVal, cdmaCmd, pPcmciaInfo->pcmciaType.modemGsm.addinit[slot]);
      insert_line(line, buf, val, flgIns);
    }
  }
  else {
    if( (line2 = search_var_within_section(line, buf, "speed", 0)) != NULL ) {
      if( rdWrtFlg ) {
        sprintf(temp, "%d", pPcmciaInfo->pcmciaType.modemGsm.speed[slot]);
        replace_Value(line2, buf, temp, 1);
      }
      else {
        get_value_from_config_line(line2, buf, &shellValue, &len, 2);
        snprintf(temp, len+1, "%s",shellValue);
        modemGsm->speed[slot] = atoi(temp);
      }
    }
    else {
      if( rdWrtFlg ) {
        flgIns = 1;
        sprintf(val, "   speed %d\n", pPcmciaInfo->pcmciaType.modemGsm.speed[slot]);
        insert_line(line, buf, val, flgIns);
      }
    }

    if( (line2 = search_var_within_section(line, buf, "data-only", 0)) != NULL ) {
      if( rdWrtFlg ) {
        replace_Value(line2, buf, dataOnlyVal, 1);
      }
    }
    else {
      if( rdWrtFlg ) {
        flgIns = 1;
        sprintf(val, "   data-only %s\n", dataOnlyVal);
        insert_line(line, buf, val, flgIns);
      }
    }
    if( (line2 = search_var_within_section(line, buf, "init-chat", 0)) != NULL ) {
      if( rdWrtFlg ) {
        sprintf(temp, "%s %s %s", initchatVal, cdmaCmd, pPcmciaInfo->pcmciaType.modemGsm.addinit[slot]);
        replace_Value(line2, buf, temp, 1);
      }
      else {
        if( (line3 = search_var_within_line(line2, buf, cdmaCmd)) != NULL ) {
          line3 = line3 + strlen(cdmaCmd);
          len = line3 - buf->buf;
          if( len < buf->len ) {
            while( *line3 && isspace(*line3) && (len < buf->len))
              line3++;
            line2 = line3;
            while( *line3 != '\n' && *line3 != '\r' )
              line3++;
            len = line3 - line2;
            if( len > kAddinitLength )
              len = kAddinitLength;
            strncpy(modemGsm->addinit[slot], line2, len);
          }
        }
      }
    }
    else {
      if( rdWrtFlg ) {
        flgIns = 1;
        sprintf(val, "   init-chat %s %s %s\n", initchatVal, cdmaCmd, pPcmciaInfo->pcmciaType.modemGsm.addinit[slot]);
        insert_line(line, buf, val, flgIns);
      }
    }
  }

  if( rdWrtFlg ) {
    write_file(buf, MGETTY_CONFIG_FILE);
  }

  free(buf);
  return(kCycSuccess);
}

//========================================================================
// WriteModemSerialConfig - Write Pcmcia CDMA initchat (serial.opts)
// For now, it is required to write to the file. No data to read for a
// specific parameter.
//========================================================================
static Result WriteModemSerialConfig(PcmciaModemGsmConfig *modemGsm,
              PcmciaInfo *pPcmciaInfo, int rdWrtFlg, int slot)
{
  FileBuffer *buf;
  char *line, *line2;
  unsigned char *s, *t;
  char val[BUF_CUSHION2];
  int flgIns, len;
  char *shellValue;
  char *initchatVal = "- \\d\\d\\d+++\\d\\d\\datz OK";
  char temp[50] = {0};

  dolog("WriteModemSerialConfig()");

  if( (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.speedBoth != 3 &&
      (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.speedBoth)) &&
      (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.addinitBoth != 3 &&
      (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.addinitBoth)) ) return(kCycSuccess);

  if( (buf = read_file(SERIAL_OPTS_FILE)) == NULL ) {
    LogError(FILE_READ_ERROR, SERIAL_OPTS_FILE);
    return(kFileReadError);
  }

  // Check if there is a 'esac' anywhere in the file.
  if( (line = search_var(buf, "esac", 0)) == NULL ) {
    if( rdWrtFlg ) {
      line = buf->buf;
      flgIns=2;
      insert_line(line, buf, "esac\n", flgIns);
    }
  }

  sprintf(val, "*,%d,*)", slot);
  if( (line = search_var(buf, val, 0)) == NULL ) {
    line = search_var(buf, val, 1);
  }

  if( line == NULL ) {
    if( rdWrtFlg ) {
      flgIns = 1;
      if( (line = search_var(buf, "case", 0)) == NULL ) {
        line = buf->buf;
        flgIns = 2;
        sprintf(val, "case \"$ADDRESS\" in\n    *,%d,*)\n    INFO=\"Modem Slot %d Setup\"\n    LINK=\"/dev/modem\"\n    INITCHAT=\"%s\"\n    INITTAB=\"/sbin/mgetty\"\n    start_fn () { return; }\n    stop_fn () { return; }\n    NO_CHECK=n\n    NO_FUSER=n\n    ;;\n", slot, slot+1, initchatVal);
      }
      else {
        sprintf(val, "*,%d,*)\n    INFO=\"Modem Slot %d Setup\"\n    LINK=\"/dev/modem\"\n    INITCHAT=\"%s\"\n    INITTAB=\"/sbin/mgetty\"\n    start_fn () { return; }\n    stop_fn () { return; }\n    NO_CHECK=n\n    NO_FUSER=n\n    ;;\n", slot, slot+1, initchatVal);
      }
      insert_line(line, buf, val, flgIns);
    }
  }
  else { // if entry is found
    if( rdWrtFlg ) {
      if( *line == '#' ) {
        delete_chars(line, buf, 1);
      }
    }
    if( (line2 = search_var_within_section(line, buf, ";;", 0)) == NULL ) {
      if( rdWrtFlg ) {
        flgIns = 1;
        sprintf(val, "    ;;\n");
        insert_line(line, buf, val, flgIns);
      }
    }

    if( (line2 = search_var_within_section(line, buf, "INITCHAT", 0)) != NULL ) {
      if( rdWrtFlg ) {
        replace_Value(line2, buf, initchatVal, 0);
      }
      else { //in fact, there is nothing to be read
        get_value_from_config_line(line2, buf, &shellValue, &len, 0);
        strncpy(temp, shellValue, len);
        if( (s = strchr(temp, '=')) != NULL ) {
          s++;
          t=s;
          while( *s && !isspace(*s) ) s++;
          strncpy(modemGsm->addinit[slot], t, s-t);
        }
      }
    }
    else {
      if( rdWrtFlg ) {
        flgIns = 1;
        build_shell_line(val, "INITCHAT", initchatVal, 0);
        insert_line(line, buf, val, flgIns);
      }
    }
  }

  if( rdWrtFlg ) {
    write_file(buf, SERIAL_OPTS_FILE);
  }

  free(buf);
  return(kCycSuccess);
}

//========================================================================
// ReadWriteGsmPin - Read/Write Pcmcia Gsm pin number
//========================================================================
static Result ReadWriteGsmPin(PcmciaModemGsmConfig *modemGsm, 
	PcmciaInfo *pPcmciaInfo, int rdWrtFlg, int slot) 
{
	FileBuffer *buf;
	char *line, *line2;
	unsigned char *s, *t;
	char val[BUF_CUSHION2];
	int flgIns, len;
	char *shellValue;
	char temp[50] = {0};
	char pinLine[50] = {0};

	dolog("ReadWriteGsmPin");

  if (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.pinBoth != 3 &&
       (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.pinBoth)) return(kCycSuccess);


  if ((buf = read_file(SERIAL_OPTS_FILE)) == NULL) {
		LogError(FILE_READ_ERROR, SERIAL_OPTS_FILE);	
    return(kFileReadError);
  }

	// Check if there is a 'esac' anywhere in the file. 
	if ((line = search_var(buf, "esac", 0)) == NULL) {
		if (rdWrtFlg)
		{
			line = buf->buf;
			flgIns=2;
			insert_line(line, buf, "esac\n", flgIns);
		}
	} 

	sprintf(val, "*,%d,*)", slot);
	if (rdWrtFlg)
		sprintf(pinLine, "- \\d\\d\\d+++\\d\\d\\datz OK at+cpin=%s OK", 
			pPcmciaInfo->pcmciaType.modemGsm.pin[slot]);

	if ((line = search_var(buf, val, 0)) == NULL) {
		line = search_var(buf, val, 1);
	}	

	if (line == NULL) 
	{
		if (rdWrtFlg) 
		{
			flgIns = 1;
			if ((line = search_var(buf, "case", 0)) == NULL) {
				line = buf->buf;
				flgIns = 2;
				sprintf(val, "case \"$ADDRESS\" in\n    *,%d,*)\n    INFO=\"Modem Slot %d Setup\"\n    LINK=\"/dev/modem\"\n    INITCHAT=\"- \\d\\d\\d+++\\d\\d\\datz OK at+cpin=%s OK\"\n    INITTAB=\"/sbin/mgetty\"\n    start_fn () { return; }\n    stop_fn () { return; }\n    NO_CHECK=n\n    NO_FUSER=n\n    ;;\n", slot, slot+1, pPcmciaInfo->pcmciaType.modemGsm.pin[slot]);
			} else {
				sprintf(val, "*,%d,*)\n    INFO=\"Modem Slot %d Setup\"\n    LINK=\"/dev/modem\"\n    INITCHAT=\"- \\d\\d\\d+++\\d\\d\\datz OK at+cpin=%s OK\"\n    INITTAB=\"/sbin/mgetty\"\n    start_fn () { return; }\n    stop_fn () { return; }\n    NO_CHECK=n\n    NO_FUSER=n\n    ;;\n", slot, slot+1, pPcmciaInfo->pcmciaType.modemGsm.pin[slot]);
			}
			insert_line(line, buf, val, flgIns);
		} 
	}
	else // if entry is found
	{
		if (rdWrtFlg) 
		{
			if (*line == '#') {
				delete_chars(line, buf, 1);
			}
		} 
		if ((line2 = search_var_within_section(line, buf, ";;", 0)) == NULL)
		{
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    ;;\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "INITCHAT", 0)) != NULL)
		{
			if (rdWrtFlg) {
				replace_Value(line2, buf, pinLine, 0);
			} else {
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				strncpy(temp, shellValue, len);
				if ((s = strchr(temp, '=')) != NULL)
				{
					s++;	
					t=s;
					while(*s && !isspace(*s)) s++;
					strncpy(modemGsm->pin[slot], t, s-t);
				}
			}
		} 	
		else 
		{
			if (rdWrtFlg) {
				flgIns = 1;
				build_shell_line(val, "INITCHAT", pinLine, 0);
				insert_line(line, buf, val, flgIns);
			}
		}
	}

	if (rdWrtFlg) {
		write_file(buf, SERIAL_OPTS_FILE);
	}

  free(buf);
	return(kCycSuccess);
}

//========================================================================
// WriteGsmMgettyConfig - Write additional Pcmcia Gsm config. For now, 
// we only need to write to the file. No instructions were given to read
// for the values.
//========================================================================
static Result WriteGsmMgettyConfig(PcmciaModemGsmConfig *modemGsm, 
		PcmciaInfo *pPcmciaInfo, int rdWrtFlg, int slot) 
{
  FileBuffer *buf;
  char *line, *line2, *line3;
  char val[BUF_CUSHION1];
  int flgIns, len;
	char temp[50] = {0};
	char ttyDevice[6] = {0};
	char *dataOnlyVal = "y";
	char *initchatVal = "\"\" \\d\\d\\d+++\\d\\d\\dATZ OK";

	dolog("WriteGsmMgettyConfig()");


  if (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.pinBoth != 3 &&
       (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.pinBoth)) return(kCycSuccess);

  if ((buf = read_file(MGETTY_CONFIG_FILE)) == NULL) {
		LogError(FILE_READ_ERROR, MGETTY_CONFIG_FILE);	
    return(kFileReadError);
  }

	sprintf(ttyDevice, "ttyM%d", slot + 1);
	sprintf(temp, "port %s", ttyDevice);

	if ((line = search_var(buf, temp, 0)) == NULL) 
	{
		if (rdWrtFlg)
		{
			dolog("No port ttyS33 found");
			line = buf->buf;
			flgIns = 2;
			sprintf(val, "%s %s\n   data-only %s\n   init-chat %s\n", "port", 
					ttyDevice, dataOnlyVal, initchatVal); 
			insert_line(line, buf, val, flgIns);
		}
	} 
	else
	{
                if ((line2 = search_var_within_section(line, buf, "speed", 0)) != NULL) {
                  if (rdWrtFlg) {
                    line3 = line2;
                    while( *line3 != '\n' && *line3 != '\r' )
                      line3++;
                    while( *line3 == '\n' || *line3 == '\r' || isblank(*line3) )
                      line3++;
                    len = line3 - line2;
                    delete_chars(line2, buf, len);
                  }
                }

		if ((line2 = search_var_within_section(line, buf, "data-only", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, dataOnlyVal, 1);
			}	
		}
		else
		{
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "   data-only %s\n", dataOnlyVal);
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "init-chat", 0)) != NULL)
		{
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, initchatVal , 1);
                                if( (line3 = search_var_within_line(line2, buf, initchatVal)) != NULL ) {
                                  line3 = line3 + strlen(initchatVal);
                                  *line3 = '\n';
                                  buf->len = line3 - buf->buf + 1;
                                }
			}
		}
		else
		{
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "   init-chat %s\n", initchatVal);
				insert_line(line, buf, val, flgIns);
			}
		}
  }

	if (rdWrtFlg) {
		write_file(buf, MGETTY_CONFIG_FILE);
	}

  free(buf);
	return(kCycSuccess);
}

//========================================================================
// ReadWriteModemGsmCallBack - Read/Write Pcmcia modem/gsm call back number 
//========================================================================
static Result ReadWriteModemGsmCallback(PcmciaModemGsmConfig *modemGsm, PcmciaInfo *pPcmciaInfo, int rdWrtFlg)
{
	FILE *fp;
	unsigned char *buf, *s, *t, *a;
	unsigned char *name, *id, *utmp, *prog, *arg;
	int found=0, foundCbuser=0;
	int foundLogin=0; //[RK]Jan/20/06

	dolog("RdWrtModemGsmCallback()");

	// Read the file and writes it to the buffer
	if ((buf = ReadFile(MGETTY_LOGIN_FILE, rdWrtFlg)) == NULL) {
		LogError(FILE_READ_ERROR, MGETTY_LOGIN_FILE);	
		return(kFileReadError);
	}

	if (rdWrtFlg) {
		if ((fp = fopen(MGETTY_LOGIN_FILE, "w")) == NULL) {
			LogError(FILE_READ_ERROR, MGETTY_LOGIN_FILE);
			free(buf);
			return (kFileWriteError);
		}
	} else {
		modemGsm->callBack = kNo;
		modemGsm->otp = kNo;
	}

	t = s = buf;
	while (*s) {
		found=0;
		foundLogin=0;
		while (*s && *s!='\n') s++;
		if (*s) *s++ = 0;

		//Parse and get word, argument
		switch (ParseLineLoginConfig(t, &name, &id, &utmp, &prog, &arg)) {	
		case 1:
			if (!strcmp(name, "cbuser")) {
				foundCbuser=1;
				if (rdWrtFlg) {
					found=1;
					if(pPcmciaInfo->pcmciaType.modemGsm.callBack == kYes &&
							*(pPcmciaInfo->pcmciaType.modemGsm.callBackNum)) {
						fprintf(fp, "%s\t%s\t%s\t%s -S %s\n", name, id, utmp, prog, pPcmciaInfo->pcmciaType.modemGsm.callBackNum);  	
					}
				} else {
					modemGsm->callBack = kYes;
					a = arg;
					while (*a && !isdigit(*a)) a++;
					strcpy(modemGsm->callBackNum, a);
					dolog("call back Num: [%s]", modemGsm->callBackNum);
				}
			}
			//[RK]Jan/20/06 - OTP 
			if (!strcmp(prog, "/bin/login")) {
				foundLogin = 1;
				if (!rdWrtFlg) 
					modemGsm->otp = kNo;
				else 
					if (pPcmciaInfo->pcmciaType.modemGsm.otp != kNo)
						found = 1;
			}
			if (!strcmp(prog, "/bin/opielogin")) {
				foundLogin = 1;
				if (!rdWrtFlg) 
					modemGsm->otp = kYes;
				else
					if (pPcmciaInfo->pcmciaType.modemGsm.otp != kYes)
						found = 1;
			}
			if (rdWrtFlg && !foundCbuser && foundLogin ) {//[RK]Jan/20/06
				if (pPcmciaInfo->pcmciaType.modemGsm.callBack == kYes && *(pPcmciaInfo->pcmciaType.modemGsm.callBackNum))
					fprintf(fp, "cbuser\t-\t-\t/sbin/callback -S %s\n", pPcmciaInfo->pcmciaType.modemGsm.callBackNum);  	
			}
			//[RK]Jan/20/06 - OTP
			if (rdWrtFlg) {
				if (foundLogin && found) {
					if (pPcmciaInfo->pcmciaType.modemGsm.otp == kNo) {
						fprintf(fp, "%s\t%s\t%s\t/bin/login %s\n", name, id, utmp, arg);
					} else {
						fprintf(fp, "%s\t%s\t%s\t/bin/opielogin %s\n", name, id, utmp, arg);
					}
				} else {
					if (!found)
						fprintf(fp, "%s\t%s\t%s\t%s %s\n", name, id, utmp, prog, arg);
				}
			}
			t = s;
			break;
		default:
			if (rdWrtFlg)
				fprintf(fp, "%s\n", t);
			t = s;
			break;
		} // end of switch
	}

	if (rdWrtFlg)
		fclose(fp);

	free(buf);
	return (kCycSuccess);
}

//========================================================================
// ReadWriteModemGsmIpAddr - Read/Write Pcmcia modem/gsm local and remote Ip addr
//========================================================================
static Result ReadWriteModemGsmIpAddr(PcmciaModemGsmConfig *modemGsm, PcmciaInfo *pPcmciaInfo, 
	int rdWrtFlg, int slot)
{
	FILE *fp;
	unsigned char *buf, *s, *t, *remoteIp ;
	int found=0;
	struct stat st;
	unsigned char command[64] = {0}, ttyFile[50] = {0};

	dolog("RdWrtModemGsmIpAddr()");
	dolog("address of pPcmciaInfo: %x", (int)pPcmciaInfo);

	if (rdWrtFlg && pPcmciaInfo->pcmciaType.modemGsm.both != 3 &&
			 (slot+1 != pPcmciaInfo->pcmciaType.modemGsm.both))
		return(kCycSuccess);

	strcpy(ttyFile, "/etc/ppp/options.ttyM1");

	// Create file if it doesn't exist
	if (stat(ttyFile, &st) != 0 && errno == ENOENT) {
		if (rdWrtFlg) {
			sprintf(command, "cp /etc/ppp/options.ttyXX %s", ttyFile);
			system(command);
		} else {
			modemGsm->ppp[slot] = kNo;
			return (kCycSuccess);
		}
	}

	if ((buf = ReadFile(ttyFile, rdWrtFlg)) == NULL) {
		LogError(FILE_READ_ERROR, ttyFile);	
		return(kFileReadError);
	}

	if (rdWrtFlg) {
		if ((fp = fopen(ttyFile, "w")) == NULL) {
			LogError(FILE_READ_ERROR, ttyFile);
			free(buf);
			return (kFileWriteError);
		}
	} 
	
	t = s = buf;

	while (*s) {
		if (*s == '\n') {
			if (*s) s++;
			if (rdWrtFlg)
				fprintf(fp, "\n");
			t=s;
			continue;
		}
		while (*s && *s!='\n') s++;
		if (*s) *s++ = 0;
		if (*t == '#') {
			if (rdWrtFlg) {
				fprintf(fp, "%s\n", t);
			}
			t=s;
			continue;
		}
		if ((remoteIp = strchr(t, ':')) != NULL) {
			if (rdWrtFlg) {
				if (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kYes 
					&& *(pPcmciaInfo->pcmciaType.modemGsm.localIp[slot]) 
					&& *(pPcmciaInfo->pcmciaType.modemGsm.remoteIp[slot]))
				{
					fprintf(fp, "%s:%s\n",
						pPcmciaInfo->pcmciaType.modemGsm.localIp[slot],
						pPcmciaInfo->pcmciaType.modemGsm.remoteIp[slot]);
					found = 1;
				} 
				/*else if (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kNo)
				{ // Comment out localip:remoteip line
					*remoteIp++=0;
					fprintf(fp, "#%s:%s\n",  t, remoteIp);
					found = 1;
				}*/
			} else {
				*remoteIp++=0;
				dolog("Local: %s, remoteIp: %s", t, remoteIp);
				strcpy(modemGsm->localIp[slot], t);		
				strcpy(modemGsm->remoteIp[slot], remoteIp);		
				modemGsm->ppp[slot] = kYes;
			}
		} else {
			if (rdWrtFlg) {
				fprintf(fp, "%s\n", t);
			}
		}
		t=s;
	}

	if (rdWrtFlg && !found) {
		if (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kYes
				&& *(pPcmciaInfo->pcmciaType.modemGsm.localIp[slot]) 
				&& *(pPcmciaInfo->pcmciaType.modemGsm.remoteIp[slot]))
			fprintf(fp, "%s:%s\n",
				pPcmciaInfo->pcmciaType.modemGsm.localIp[slot],
				pPcmciaInfo->pcmciaType.modemGsm.remoteIp[slot]);
	}
	if (rdWrtFlg)
		fclose(fp);

	free(buf);

	return (kCycSuccess);
}

//========================================================================
// ReadWriteModemPPP - Read/Write Pcmcia modem Auto PPP line
//========================================================================
static Result ReadWriteModemPPP(PcmciaModemGsmConfig *modemGsm, PcmciaInfo *pPcmciaInfo, 
	int rdWrtFlg, int slot)
{
	FILE *fp;
	unsigned char *buf, *s, *t;
	unsigned char *name, *id, *utmp, *prog, *arg;
	int found=0, foundAutoPPP=0, foundAllPPPArgs=0, foundBin=0;

	if (!rdWrtFlg && modemGsm->ppp[slot] == kNo) return (kCycSuccess);

	// Read the file and writes it to the buffer
	if ((buf = ReadFile(MGETTY_LOGIN_FILE, rdWrtFlg)) == NULL) {
		LogError(FILE_READ_ERROR, MGETTY_LOGIN_FILE);	
		return(kFileReadError);
	}

	if (rdWrtFlg) {
		if ((fp = fopen(MGETTY_LOGIN_FILE, "w")) == NULL) {
			LogError(FILE_READ_ERROR, MGETTY_LOGIN_FILE);
			free(buf);
			return (kFileWriteError);
		}
	} 

	t = s = buf;
	while (*s) {
		found=0;
		while (*s && *s!='\n') s++;
		if (*s) *s++ = 0;

		//Parse and get word, argument
		switch (ParseLineLoginConfig(t, &name, &id, &utmp, &prog, &arg)) {	
		case 1:
			if (!strcmp(name, "/AutoPPP/") && !strcmp(utmp, "a_ppp") 
					&& !strcmp(prog, "/usr/local/sbin/pppd")) {
				if (foundBin) {// already found the bin/login line
					foundAutoPPP=0;
					found = 1;
				} else
					foundAutoPPP=1;
				if (strstr(arg, "auth") != NULL
						&& strstr(arg, "-chap") != NULL
						&& strstr(arg, "+pap") != NULL
						&& strstr(arg, "login") != NULL) {
					foundAllPPPArgs = 1;
					if (!rdWrtFlg && foundAutoPPP)
						modemGsm->ppp[slot] = kYes;
				}
				if (rdWrtFlg) {
					if(!foundAllPPPArgs && foundAutoPPP
						&& (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kYes ||
							pPcmciaInfo->pcmciaType.modemGsm.ppp[slot+1] == kYes))
					{
						found = 1;
						fprintf(fp, "%s\t%s\t%s\t%s auth -chap +pap login debug nobsdcomp nodeflate\n", 
							name, id, utmp, prog);  	
					}
				} 
			}
			if (!strcmp(prog, "/bin/login") || !strcmp(prog,"/bin/opielogin")) { //[RK]Jan/23/06
				foundBin = 1;
				if (rdWrtFlg && !foundAutoPPP) {
					if (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kYes ||
						pPcmciaInfo->pcmciaType.modemGsm.ppp[slot+1] == kYes) {
						fprintf(fp, "/AutoPPP/	-	a_ppp	/usr/local/sbin/pppd auth -chap +pap login debug nobsdcomp nodeflate\n");  	
					}
				}
			}
			if (rdWrtFlg && !found)
				fprintf(fp, "%s\t%s\t%s\t%s %s\n",
					name, id, utmp, prog, arg);  	
				
			t = s;
			break;
		default:
			if (rdWrtFlg)
				fprintf(fp, "%s\n", t);
			t = s;
			break;
		} // end of switch
	}

	if (rdWrtFlg)
		fclose(fp);
	else
		if (!foundAutoPPP)
			modemGsm->ppp[slot] = kNo;

	free(buf);
	return (kCycSuccess);
}

//========================================================================
// ReadWriteModemPapSecret - Read/Write Pcmcia modem pap secret
//========================================================================
static Result ReadWriteModemPapSecret(PcmciaModemGsmConfig *modemGsm, PcmciaInfo *pPcmciaInfo, 
	int rdWrtFlg, int slot)
{
	FILE *fp;
	unsigned char *buf, *s, *t;
	unsigned char *name, *id, *utmp, *prog, *arg;
	int found=0, foundEntry=0;

	if (!rdWrtFlg && modemGsm->ppp[slot] == kNo) return (kCycSuccess);

	// Read the file and writes it to the buffer
	if ((buf = ReadFile(PAP_SECRETS_FILE, rdWrtFlg)) == NULL) {
		LogError(FILE_READ_ERROR, PAP_SECRETS_FILE);	
		return(kFileReadError);
	}

	if (rdWrtFlg) {
		if ((fp = fopen(PAP_SECRETS_FILE, "w")) == NULL) {
			LogError(FILE_READ_ERROR, PAP_SECRETS_FILE);
			free(buf);
			return (kFileWriteError);
		}
	} 

	t = s = buf;
	while (*s) {
		found=0;
		if (foundEntry) { // should not be here if entry was already found
			foundEntry = 0;
			if (!rdWrtFlg) modemGsm->ppp[slot] = kNo;
		}
		while (*s && *s!='\n') s++;
		if (*s) *s++=0;

		//Parse and get word, argument
		switch (ParseLineLoginConfig(t, &name, &id, &utmp, &prog, &arg)) {	
		case 1:
			if (!foundEntry && !strcmp(name, "*") && !strcmp(utmp, "\"\"") 
					&& !strcmp(prog, "*")) {
				// entry should be in the last line of the file
				foundEntry = 1;
				if(rdWrtFlg) {
					if (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kNo 
						&& pPcmciaInfo->pcmciaType.modemGsm.ppp[slot+1] == kNo)
						found = 1;	
				} else {
					modemGsm->ppp[slot] = kYes;
				}
			}
			if (rdWrtFlg && !found)
				fprintf(fp, "%s\t%s\t%s\t%s %s\n", name, id, utmp, prog, arg);
			t = s;
			break;
		default:
			if (rdWrtFlg)
				fprintf(fp, "%s\n", t);
			t = s;
			break;
		} // end of switch
	}

	if (rdWrtFlg) {
		if (!foundEntry 
			&& (pPcmciaInfo->pcmciaType.modemGsm.ppp[slot] == kYes ||
			pPcmciaInfo->pcmciaType.modemGsm.ppp[slot+1] == kYes)) {
			fprintf(fp, "*\t*\t\"\"\t*\n");
		}
		fclose(fp);
	} else {
		if (!foundEntry)
			modemGsm->ppp[slot] = kNo;
	}

	free(buf);
	return (kCycSuccess);
}

//========================================================================
// ReadWriteWirelessConfig - Read/Write Pcmcia wireless configuration
//========================================================================
static Result ReadWriteWirelessConfig(PcmciaWirelessConfig *wireless, 
	PcmciaInfo *pPcmciaInfo, int rdWrtFlg, int slot) 
{
	FileBuffer *buf;
	char *line, *line2;
	char val[BUF_CUSHION2] = {0};
	int flgIns, len;
	char *shellValue;
	char temp[50] = {0};

	dolog("ReadWriteWirelessConfig");

	if (rdWrtFlg && pPcmciaInfo->pcmciaType.wireless.both != 3 &&
		(slot+1 != pPcmciaInfo->pcmciaType.wireless.both)) return(kCycSuccess);

	if ((buf = read_file(WIRELESS_OPTS_FILE)) == NULL) {
		LogError(FILE_READ_ERROR, WIRELESS_OPTS_FILE);	
		return(kFileReadError);
	}

	// Check if there is a 'esac' anywhere in the file. 
	if ((line = search_var(buf, "esac", 0)) == NULL) {
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			insert_line(line, buf, "esac\n", flgIns);
		}
	} 

	sprintf(val, "*,%d,*,*)", slot);

	if ((line = search_var(buf, val, 0)) == NULL) {
		line = search_var(buf, val, 1);
	} 

	if (line == NULL) {
		if (rdWrtFlg) {
			flgIns = 1;
			if ((line = search_var(buf, "case", 0)) == NULL) {
				line = buf->buf;
				flgIns = 2;
				sprintf(val, "case \"$ADDRESS\" in\n    *,%d,*,*)\n    ESSID=\"%s\"\n    KEY=\"%s\"\n    MODE=\"%s\"\n    CHANNEL=\"%d\"\n    ;;\n", slot, pPcmciaInfo->pcmciaType.wireless.essid[slot], 
				pPcmciaInfo->pcmciaType.wireless.key[slot], 
				TransOptGetStr(WirelessModeOptions, SIZE_WirelessModeOptions,
            pPcmciaInfo->pcmciaType.wireless.encryption[slot]), 
				pPcmciaInfo->pcmciaType.wireless.channel[slot]);
			} else {
			sprintf(val, "*,%d,*,*)\n    ESSID=\"%s\"\n    KEY=\"%s\"\n    MODE=\"%s\"\n    CHANNEL=\"%d\"\n    ;;\n", slot, pPcmciaInfo->pcmciaType.wireless.essid[slot], 
				pPcmciaInfo->pcmciaType.wireless.key[slot], 
				TransOptGetStr(WirelessModeOptions, SIZE_WirelessModeOptions,
				pPcmciaInfo->pcmciaType.wireless.encryption[slot]), 
				pPcmciaInfo->pcmciaType.wireless.channel[slot]); 
			}
			insert_line(line, buf, val, flgIns);
		 }
	}else {
		if (rdWrtFlg) {
			if (*line == '#') {
				delete_chars(line, buf, 1);
			}
		}
		if ((line2 = search_var_within_section(line, buf, ";;", 0)) == NULL) {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    ;;\n");
				insert_line(line, buf, val, flgIns);
			}
		}

		if ((line2 = search_var_within_section(line, buf, "CHANNEL", 0)) != NULL) {
			if (rdWrtFlg) {
				sprintf(temp, "%d", pPcmciaInfo->pcmciaType.wireless.channel[slot]);
				replace_Value(line2, buf, temp, 0);
			} else {
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("SHELL VALUE3: %s, len: %d", shellValue, len);
				strncpy(temp, shellValue, len);
				wireless->channel[slot] = atoi(temp);
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    CHANNEL=\"%d\"\n",
					pPcmciaInfo->pcmciaType.wireless.channel[slot]);
				insert_line(line, buf, val, flgIns);
			}	
		}
	
		if ((line2 = search_var_within_section(line, buf, "MODE", 0)) != NULL) {
			if (rdWrtFlg) {
				replace_Value(line2, buf,
					TransOptGetStr(WirelessModeOptions,
						SIZE_WirelessModeOptions,
						pPcmciaInfo->pcmciaType.wireless.encryption[slot]),
					0);
			} else {
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("SHELL VALUE3: %s, len: %d", shellValue, len);
				strncpy(temp, shellValue, len);
				wireless->encryption[slot] =
					TransOptGetVal(WirelessModeOptions,
						SIZE_WirelessModeOptions, temp, len); 
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    MODE=\"%s\"\n",
					TransOptGetStr(WirelessModeOptions,
					SIZE_WirelessModeOptions,
					pPcmciaInfo->pcmciaType.wireless.encryption[slot]));
				insert_line(line, buf, val, flgIns);
			}	
		}

		if ((line2 = search_var_within_section(line, buf, "KEY", 0)) != NULL) {
			if (rdWrtFlg) {
				replace_Value(line2, buf, pPcmciaInfo->pcmciaType.wireless.key[slot], 0);
			} else {
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("SHELL VALUE2: %s, len: %d", shellValue, len);
				strncpy(wireless->key[slot], shellValue, len);
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    KEY=\"%s\"\n", pPcmciaInfo->pcmciaType.wireless.key[slot]);
				insert_line(line, buf, val, flgIns);
			}	
		}

		if ((line2 = search_var_within_section(line, buf, "ESSID", 0)) != NULL) {
			if (rdWrtFlg)
			{
				replace_Value(line2, buf, pPcmciaInfo->pcmciaType.wireless.essid[slot], 0);
			} else {
				get_value_from_config_line(line2, buf, &shellValue, &len, 0);
				//dolog("SHELL VALUE: %s, Len: %d", shellValue, len);
				strncpy(wireless->essid[slot], shellValue, len);
			}
		} else {
			if (rdWrtFlg) {
				flgIns = 1;
				sprintf(val, "    ESSID=\"%s\"\n", pPcmciaInfo->pcmciaType.wireless.essid[slot]);
				insert_line(line, buf, val, flgIns);
			}	
		}
	}

	if (rdWrtFlg) {
		write_file(buf, WIRELESS_OPTS_FILE);
	}

	free(buf);
	return(kCycSuccess);
}

//========================================================================
// RdWrtPcmciaNetwkConfig - Read/Write Pcmcia network interfaces
//========================================================================
static Result ReadWriteNetworkConfig(PcmciaNetwkConfig *network, PcmciaInfo *pPcmciaInfo, int rdWrtFlg) 
{
  FileBuffer *buf;
  char *line, *line2;
  char val[BUF_CUSHION1];
  int flgIns, len;
	char *shellValue;

	dolog("ReadWriteNetworkConfig");

  if ((buf = read_file(NETWK_INTERFACE_FILE)) == NULL) 
	{
		LogError(FILE_READ_ERROR, NETWK_INTERFACE_FILE);	
    return(kFileReadError);
  }

	//[RK]Oct/05/04 - the "auto eth1" :  can have spaces before the string
	if ((line = search_var(buf, "auto eth1", 2)) == NULL)
  {
		if (rdWrtFlg) {
      line = buf->buf;
      flgIns=2;
			sprintf(val, "auto eth1\niface eth1 inet static\n\taddress %s\n\tnetmask %s\n", 
					pPcmciaInfo->pcmciaType.netWkConfig.ipAddr, pPcmciaInfo->pcmciaType.netWkConfig.netMask);
      insert_line(line, buf, val, flgIns);
    }
  }
  else
  {
		//[RK]Oct/05/04 - the "auto eth1" :  can have spaces before the string
		if ((line = search_var(buf, "iface eth1 inet static", 2)) == NULL)
		{
			if (rdWrtFlg) {
				line = buf->buf;
				flgIns=2;
				sprintf(val, "auto eth1\niface eth1 inet static\n\taddress %s\n\tnetmask %s\n", 
				pPcmciaInfo->pcmciaType.netWkConfig.ipAddr,
				pPcmciaInfo->pcmciaType.netWkConfig.netMask);
				insert_line(line, buf, val, flgIns);
			}
		}
		else
		{
			if ((line2 = search_var_within_section(line, buf, "address", 1)) != NULL)
			{
				if (rdWrtFlg)
				{
					replace_Value(line2, buf, pPcmciaInfo->pcmciaType.netWkConfig.ipAddr, 1);
				}	
				else
				{
					get_value_from_config_line(line2, buf, &shellValue, &len, 2);
					strncpy(network->ipAddr, shellValue, len);
				}
			}
			if ((line2 = search_var_within_section(line, buf, "netmask", 1)) != NULL)
			{
				if (rdWrtFlg)
				{
					replace_Value(line2, buf, pPcmciaInfo->pcmciaType.netWkConfig.netMask, 1);
				}
				else
				{
					get_value_from_config_line(line2, buf, &shellValue, &len, 2);
					strncpy(network->netMask, shellValue, len);
				}
			}
			// Commented out for now. This version, we do not need to read for these
			// parameters. May be used in the future.
			/*if ((line2 = search_var_within_section(line, buf, "network", 1)) != NULL)
			{
				if (rdWrtFlg)
				{
					replace_Value(line2, buf, pPcmciaInfo->pcmciaType.netWkConfig.netWkAddr, 1);
				}
				else
				{
					get_value_from_config_line(line2, buf, &shellValue, &len, 2);
					strncpy(network->netWkAddr, shellValue, len);
				}
			}
			if ((line2 = search_var_within_section(line, buf, "broadcast", 0)) != NULL)
			{
				if (rdWrtFlg)
				{
					replace_Value(line2, buf, pPcmciaInfo->pcmciaType.netWkConfig.broadCast, 1);
				}
				else
				{
					get_value_from_config_line(line2, buf, &shellValue, &len, 2);
					strncpy(network->broadCast, shellValue, len);
				}
			}
			if ((line2 = search_var_within_section(line, buf, "gateway", 0)) != NULL)
			{
				if (rdWrtFlg)
				{
					replace_Value(line2, buf, pPcmciaInfo->pcmciaType.netWkConfig.gateWay, 1);
				}
				else
				{
					get_value_from_config_line(line2, buf, &shellValue, &len, 2);
					strncpy(network->gateWay, shellValue, len);
				}
			}*/
		}
  }

	if (rdWrtFlg) {
		write_file(buf, NETWK_INTERFACE_FILE);
	}

  free(buf);
	return(kCycSuccess);
}

//========================================================================
// ReadWritePcmciaType - Read all pcmcia info and write according to
// pcmcia type configured and set
//========================================================================
static PcmciaInfo *ReadWritePcmciaType(CycParam *paramList, PcmciaType *pPcmType, int slot, void *p, int rdWrtFlg) 
{
	PcmciaInfo *pPcmciaInfo;
	int i;

	if (p != NULL && rdWrtFlg) {
		pPcmciaInfo = (PcmciaInfo *)p;
	}

	dolog("ReadWritePcmciaType()");

	if (rdWrtFlg) {
		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsEthernet) {
			ReadWriteNetworkConfig(NULL, p, rdWrtFlg);
		} 

		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsWireless) {
			ReadWriteNetworkConfig(NULL, p, rdWrtFlg);
			for (i=0; i<kMaxPcmciaSlots; i++) {
				ReadWriteWirelessConfig(NULL, p, rdWrtFlg, i);
			}
		}

		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsModem) {
			for (i=0; i<kMaxPcmciaSlots; i++) {
				ReadWriteModemGsmIpAddr(NULL, p, rdWrtFlg, i);
			}
			ReadWriteModemPPP(NULL, p, rdWrtFlg, 0);
			ReadWriteModemPapSecret(NULL, p, rdWrtFlg, 0);
		}
		
		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsModemCallback) {
			ReadWriteModemGsmCallback(NULL, p, rdWrtFlg);
		}

		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsGsm) {
			//ReadWriteModemGsmCallback(NULL, p, rdWrtFlg);
			for (i=0; i<kMaxPcmciaSlots; i++) {
				ReadWriteGsmPin(NULL, p, rdWrtFlg, i);
				WriteGsmMgettyConfig(NULL, p, rdWrtFlg, i);
			}
		}
 
                if( (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsGsmSpeed) ||
                    (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsGsmAddinit) ) {
                  for( i=0; i<kMaxPcmciaSlots; i++ ) {
                    WriteModemSerialConfig( NULL, p, rdWrtFlg, i );
                    ReadWriteModemMgettyConfig( NULL, p, rdWrtFlg, i );
                  }
                }

		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsIsdn) {
			ReadWriteIsdnConfig(NULL, p, rdWrtFlg);
		}

		if (pPcmciaInfo->pcmciaTypeFlag & kPcmciaFlagsFlash) {
			ReadWriteFlashConfig(NULL, p, rdWrtFlg);
		}

		/*if (((PcmciaInfo *)paramList->value + paramList->collectionSize) == pPcmciaInfo)
		{
			dolog("Error: Exceeded number of possible entries. Should exit.");
			return(NULL);
		}
		pPcmciaInfo++; 
		*/
		return(pPcmciaInfo);
	} else {
		// May be used later when we can associate configurations for 
		// all types of cards to each slot
		/*ReadWriteNetworkConfig(&pPcmType->netWkConfig, p, rdWrtFlg);
		ReadWriteWirelessConfig(&pPcmType->wireless, p, rdWrtFlg);
		ReadWriteModemGsmIpAddr(&pPcmType->modemGsm, p, rdWrtFlg);
		ReadWriteModemGsmCallback(&pPcmType->modemGsm, p, rdWrtFlg);
		ReadWriteGsmPin(&pPcmType->modemGsm, p, rdWrtFlg);
		ReadWriteIsdnConfig(&pPcmType->isdn, p, rdWrtFlg);
		ReadWriteFlashConfig(&pPcmType->flash, slot, p, rdWrtFlg);
		*/
	}

	return (NULL);
}

//========================================================================
// ParsePcmciaInfo - Function that gets all of pcmcia info
//========================================================================
static void *ParsePcmciaInfo(int slot,  CycParam *paramList, void *p, int rdWrtFlg)
{
	FILE *fp;
	unsigned char buffer[512]={0}, *s;
	PcmciaInfo pcmcia = {0}, *pPcmciaInfo;

	dolog("ParsePcmciaInfo()");

	pPcmciaInfo = (PcmciaInfo *)p;

	pcmcia.slot = slot;	

	// Get identity of card	
	sprintf(buffer, "cardctl ident %d > /tmp/webtemp", slot);
	system(buffer);

	if ((fp = fopen("/tmp/webtemp", "r"))!= NULL) 
	{
		while (fgets(buffer, 100, fp)) 
		{
			s = buffer;	// Remove extra space before the actual info
			while (isspace(*s)) s++;		
			strcat(pcmcia.identInfo, s);
		}
		fclose(fp);
		memset(buffer, 0, sizeof(buffer));
	}

	// Get config info of card
	sprintf(buffer, "cardctl config %d > /tmp/webtemp", slot);
	system(buffer);
	if ((fp = fopen("/tmp/webtemp", "r"))!= NULL) 
	{
		while (fgets(buffer, 100, fp)) 
		{
			s = buffer;	// Remove extra space before the actual info
			while (isspace(*s)) s++;		
			strcat(pcmcia.configInfo, s);
		}
		fclose(fp);
		memset(buffer, 0, sizeof(buffer));
	}

	// Get status of card
	sprintf(buffer, "cardctl status %d > /tmp/webtemp", slot);
	system(buffer);

	if ((fp = fopen("/tmp/webtemp", "r"))!= NULL) 
	{
		while (fgets(buffer, 100, fp)) 
		{
			s = buffer;	// Remove extra space before the actual info
			while (isspace(*s)) s++;		
			strcat(pcmcia.status, s);
		}
		fclose(fp);
		memset(buffer, 0, sizeof(buffer));
	}

	// This may be used in the future when we can associate 
	// configurations of each type of card to slots
	/*if (paramList->key != kUnitPcmciaInfo)
		ReadWritePcmciaType(NULL, &pcmcia.pcmciaType, pcmcia.slot, NULL, rdWrtFlg); 
	*/

	if (((PcmciaInfo *)paramList->value + paramList->collectionSize) == pPcmciaInfo)
  {
		dolog("Error: Exceeded number of possible entries. Should exit.");
		return(NULL);
  }

	*pPcmciaInfo++ = pcmcia;
	
	return(pPcmciaInfo);
}

//========================================================================
// GetPcmciaInfo - Get number of Pcmcia slot and its status
//========================================================================
static Result GetPcmciaInfo(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	int slot;
	void *p;
	
	dolog("GetPcmciaInfo()");
	
	if (rdWrtFlg)
	{
		p = paramList->value;
		// The following is commented out for now
		// because it should not be used yet. We may use this part
		// in the future when we can associate slots with configurations 
		// for each type of card. 
		/*for (slot=0; slot < paramList->collectionSize; slot++) 
		{
			if ((p = ReadWritePcmciaType(paramList, NULL, 0, p, rdWrtFlg)) == NULL)
				return (kExceedSpaceAvail);
		}*/
		p = ReadWritePcmciaType(paramList, NULL, 0, p, 1); 
	}
	else 
	{
		
		if (paramList->key == kUnitPcmciaInfo)
		{
			p = paramList->value;
			for (slot=0; slot < paramList->collectionSize; slot++) 
			{
				 if ((p = ParsePcmciaInfo(slot, paramList, p, rdWrtFlg)) == NULL)
					return (kExceedSpaceAvail);
			}
			system("rm -f /tmp/webtemp");
		}
		else
		{
			PcmciaType *pPcmType = (PcmciaType *)paramList->value;
			int i;

			ReadWriteNetworkConfig(&pPcmType->netWkConfig, p, rdWrtFlg);
			for (i=0; i<kMaxPcmciaSlots; i++) {
				ReadWriteModemGsmIpAddr(&pPcmType->modemGsm, p, rdWrtFlg, i);
				ReadWriteModemPPP(&pPcmType->modemGsm, p, rdWrtFlg, i);
				ReadWriteModemPapSecret(&pPcmType->modemGsm, p, rdWrtFlg, i);
				ReadWriteGsmPin(&pPcmType->modemGsm, p, rdWrtFlg, i);
				ReadWriteWirelessConfig(&pPcmType->wireless, p, rdWrtFlg, i);
                                ReadWriteModemMgettyConfig(&pPcmType->modemGsm, p, rdWrtFlg, i);
			}
			ReadWriteModemGsmCallback(&pPcmType->modemGsm, p, rdWrtFlg);
			ReadWriteIsdnConfig(&pPcmType->isdn, p, rdWrtFlg);
			ReadWriteFlashConfig(&pPcmType->flash, p, rdWrtFlg);
		}
	}
	
	return (kCycSuccess);
}

//========================================================================
// GetVersion - Read unit version info
//========================================================================
static Result GetVersion(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[512], *t, *s;
	UnitVersionInfo version ={{0}};

	dolog("GetVersion()");

	if ((fp = fopen(pCkIndex->fileName, "r")) == NULL)
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return (kFileReadError);
	}

	fgets(buffer, sizeof(buffer), fp);  // Discard first line.

	// Get Linux Version 
	t=buffer;
	s=t+1;
	while (*s && *s!='(') s++;
	*(s-1) = 0;
	strcpy(version.linuxVersion, t);
	dolog("LinuxVersion: %s", version.linuxVersion);

//[RK]Feb/25/05 - remove the user and hostname 
	// Get the session where the kernel was generated 
//	t=s;
//	s++;
//	while (*s && *s!='(') s++;
//	*(s-1) = 0;
//	strcpy(version.kernelGenerationSess, t);
//	dolog("kernel Version: %s", version.kernelGenerationSess);

	// Get the compiler version 
	t=s;
	s++;
	while (*s && *s!='#') s++;
	while (*s && !isspace(*s)) s++;
	if (*s) *s++=0;
	strcpy(version.compilerVersion, t);
	dolog("Compiler Version: %s", version.compilerVersion);

	// Get the date of generation
	t=s;
	while (*s && *s != '\n') s++;	
	if (*s) *s++=0;
	strcpy(version.dateOfVersionGeneration, t);
	
	/*for (i = 0; i < 512; i++) {
		buffer[i] = 0;
	}*/
	memset(buffer, 0, sizeof(buffer));
	fgets(buffer, sizeof(buffer), fp);
	t = s = buffer;
	while (*s && *s != '\n') s++;	
	if (*s) *s++=0;
	strcpy(version.firmwareVersion, t);
	dolog("Firmware Version: %s", version.firmwareVersion);

	memcpy(paramList->value, &version, sizeof(version));
	fclose(fp);

	return (kCycSuccess);
}

//========================================================================
// GetDate - Read unit's date info
//========================================================================
static Result GetDate(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[512];
	
	dolog("GetDate()");

	//system("date > /tmp/webtemp");
	system("date \"+%a %d %b %Y %T %Z\" > /tmp/webtemp");  //Christine Qiu: fix bug 4062..
	if ((fp = fopen(WEB_TEMP_FILE, "r")) == NULL)
	{
		LogError(FILE_READ_ERROR, WEB_TEMP_FILE);
		return (kFileReadError);
	}

	fgets(buffer, sizeof(buffer), fp);
	buffer[kDateLength-1] = 0;
	memcpy(paramList->value, buffer, kDateLength);
	dolog("System date: [%s]", (char *)paramList->value);
	fclose(fp);
	system("rm -f /tmp/webtemp");
	
	return (kCycSuccess);
}



//========================================================================
// RdWrtIssue - Read/Write /etc/issue function
//========================================================================
static Result GetInterfacesInfo(CycCatKeyTable *pCkIndex, CycParam *paramList) 
{
	char buf[BUFSIZ];
	struct ifconf ifc;
	int i, sd;     
	InterfaceInfo ifinfo = {0};

	dolog("RdInterfaces()");

	/* zero out structure */
	memset(&ifc, 0, sizeof ifc);

	ifc.ifc_len = sizeof buf;
	ifc.ifc_buf = (char *)buf;

	if ( (sd = socket(AF_INET, SOCK_DGRAM, 0)) < 0 ) {
		perror("socket() error");
		exit(1);
	}

	if ( -1 == ioctl(sd, SIOCGIFCONF, &ifc) ) {
		perror("ioctl() error");
		exit(1);
	}

	ifinfo.numEntries = ifc.ifc_len / sizeof(struct ifreq);
	for (i = 0; i < ifinfo.numEntries; i++ ) {
		strncpy(ifinfo.name[i], (ifc.ifc_req++)->ifr_name, kHostNameLength);
		dolog("interface %d: %s\n", i, ifinfo.name[i]);
	}

	close(sd);

	memcpy(paramList->value, &ifinfo, sizeof(InterfaceInfo));
	return (kCycSuccess);
}





//========================================================================
// GetPwrSupplyInfo - Read unit's power supply info
//========================================================================
static Result GetPwrSupplyInfo(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	int fd;
	int npw = 0, state = 1;
	PwrSupplyInfo pwrSupply = {0};

	dolog("GetPwrSupplyInfo()");

	if ((fd = open(pCkIndex->fileName, O_RDWR)) > 0) {
		ioctl(fd, 0, &npw);
		ioctl(fd, 1, &state);
		close(fd);
	}

	if (npw) {
		pwrSupply.pwrSupply1 = (state & 1) ? kOn : kOff;
		pwrSupply.pwrSupply2 = (state & 2) ? kOn : kOff;
	
	} else { //only one power supply
		pwrSupply.pwrSupply1 = kSinglePower;
	
	}

	dolog("Pwr1: %d", pwrSupply.pwrSupply1);
	dolog("Pwr2: %d", pwrSupply.pwrSupply2);

	memcpy(paramList->value, &pwrSupply, sizeof(pwrSupply));

	return (kCycSuccess);
}

//========================================================================
// GetCpuInfo - Read unit's cpu info
//========================================================================
static Result GetCpuInfo(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[512];
	unsigned char *name, *n;
	unsigned char *value, *v;
	CpuInfo cpuInfo = {0}; 

	dolog("GetCpuInfo()");

	if ((fp = fopen(pCkIndex->fileName, "r")) == NULL)
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		return (kFileReadError);
	}
	
	while (fgets(buffer, sizeof(buffer), fp)) 
	{
		name = strtok(buffer, ":");
		n = name;
		while(*name && *name != '\t') name++;	
		if (*name) *name++=0;
		*n &= ~(*n & 0x20);
		value = strtok(NULL, ":");
		while(isspace(*value)) value++;
		v = value;
		while (*value && *value != '\n') value++;
		if (*value) *value++=0;

		if (!strncmp(n, "Processor", strlen("Processor")))
		{
			cpuInfo.processor = atoi(v);
		}
		else if (!strncmp(n, "Cpu", strlen("Cpu")))
		{
			strcpy(cpuInfo.cpu, v);	
		}
		else if (!strncmp(n, "Clock", strlen("Clock")))
		{
			strcpy(cpuInfo.clock, v);	
		}
		else if (!strncmp(n, "Bus clock", strlen("Bus clock")))
		{
			strcpy(cpuInfo.busClock, v);	
		}
		else if (!strncmp(n, "Revision", strlen("Revision")))
		{
			strcpy(cpuInfo.revision, v);	
		}
		else // Bogomips 
		{
			strcpy(cpuInfo.bogomips, v);	
		}
	}
	fclose(fp);
	dolog("cpu processor: %d", cpuInfo.processor);
	dolog("cpu: %s", cpuInfo.cpu);
	dolog("clock: %s", cpuInfo.clock);
	dolog("bus clock: %s", cpuInfo.busClock);
	dolog("revision: %s", cpuInfo.revision);
	dolog("bogomips: %s", cpuInfo.bogomips);
	memcpy(paramList->value, &cpuInfo, sizeof(cpuInfo));
	
	return (kCycSuccess);
}

//========================================================================
// GetMemoryInfo - Read unit's memory info
//========================================================================
static Result GetMemoryInfo(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[512];
	unsigned char *name, *n;
	unsigned char *value, *v;
	int numEntries = 0;
	MemInfo mem = {0};

	dolog("GetMemoryInfo()");

	if ((fp = fopen(pCkIndex->fileName, "r")) == NULL)
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		return (kFileReadError);
	}

#ifndef KERNEL_26 //[RK]Feb/15/05
	fgets(buffer, sizeof(buffer), fp);
	fgets(buffer, sizeof(buffer), fp);
	fgets(buffer, sizeof(buffer), fp);
#endif

	while (fgets(buffer, 512, fp)) 
	{
		name = strtok(buffer, ":");
		n = name;
		while(*name && *name != '\t') name++;
		if (*name) *name++=0;
		value = strtok(NULL, ":");
		while(isspace(*value)) value++;
		v = value;
		while (*value && *value != '\n') value++;
		if (*value) *value++=0;
		dolog("Name: [%s]", n);
		dolog("Value: [%s]", v);
		//store into array
		strcpy(mem.name[numEntries], n);
		strcpy(mem.value[numEntries], v);
		mem.numEntries = ++numEntries;
	}
		dolog("Entry: [%d]", mem.numEntries);
	fclose(fp);
	memcpy(paramList->value, &mem, sizeof(mem));

	return (kCycSuccess);
}

//========================================================================
// GetUpTime - Read unit's up time 
//========================================================================
static Result GetUpTime(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[512] = {0};
	unsigned char *pStr;
	pStr = 0;

	system("uptime > /tmp/webtemp");

	if ((fp = fopen(WEB_TEMP_FILE, "r")) == NULL)
	{
		LogError(FILE_READ_ERROR, WEB_TEMP_FILE);
		return (kFileReadError);
	}

	fgets(buffer, sizeof(buffer), fp);
	pStr = strstr(buffer, "up");
	while (*pStr && !isspace(*pStr)) pStr++; 
	while (*pStr && isspace(*pStr)) pStr++; 
	pStr = strtok(pStr, ",");
	strcpy(paramList->value, pStr);

	fclose(fp);
	system("rm -f /tmp/webtemp");

	return (kCycSuccess);
}

#if defined(KVM) || defined(ONS)
//========================================================================
// GetKVMPortStatus
//========================================================================
static Result GetKVMPortStatus(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;
	unsigned char command[128], *s;
	unsigned char **p = (unsigned char **)paramList->value, *buf;
	int station, i;

	for (station = 0; station < kMaxKVMStations; station ++) { 
		buf = p[station];
		*buf = 0;
		sprintf(command, "kvm status -s %d > %s", station + 1, 
			WEB_TEMP_FILE);
		system(command);
		i = 0;
		if ((fp = fopen(WEB_TEMP_FILE, "r")) == NULL)
		{
			LogError(FILE_READ_ERROR, WEB_TEMP_FILE);
			return (kFileReadError);
		}
		while (fgets(command, 128, fp) != NULL) {
			if ((s = strstr(command, ": ")) != NULL) {
				*s = 0;
				s += 2;
			} else {
				continue;
			}
			snprintf(buf + strlen(buf), 
				kKVMPortInfoLength - strlen(buf),
				"<tr class = \"colorTRow%s\">"
				"<td class = \"colorTRow%s\">%s</td>"
				"<td class = \"colotTRow%s\">%s</td></tr>",
				(i%2)?"Alt":"", (i%2)?"Alt":"", 
				command, (i%2)?"Alt":"", s);
			i ++;
		}
	}
	fclose(fp);
	unlink(WEB_TEMP_FILE);

	return (kCycSuccess);
}

static Result GetFanStatus(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	dolog("GetFanStatus()");

	switch(libcyc_kvm_get_model(cyc)) {
	case MODEL_KVM:
		if ((((UInt32*)(paramList->value))[0] = libcyc_apctl_get_fan_speed(cyc,FAN_1)) == -1) {
			((UInt32*)(paramList->value))[0] = 0;
		}
		((UInt32*)(paramList->value))[1] = 0;
		((UInt32*)(paramList->value))[2] = 0;
		break;
	case MODEL_KVMNET:
		if ((((UInt32*)(paramList->value))[0] = libcyc_apctl_get_fan_speed(cyc,FAN_1)) == -1) {
			((UInt32*)(paramList->value))[0] = 0;
		}
		if ((((UInt32*)(paramList->value))[1] = libcyc_apctl_get_fan_speed(cyc,FAN_2)) == -1) {
			((UInt32*)(paramList->value))[1] = 0;
		}
		((UInt32*)(paramList->value))[2] = 0;
		break;
	case MODEL_KVMNET_PLUS:
		if ((((UInt32*)(paramList->value))[0] = libcyc_apctl_get_fan_speed(cyc,FAN_1)) == -1) {
			((UInt32*)(paramList->value))[0] = 0;
		}
		if ((((UInt32*)(paramList->value))[1] = libcyc_apctl_get_fan_speed(cyc,FAN_2)) == -1) {
			((UInt32*)(paramList->value))[1] = 0;
		}
		if ((((UInt32*)(paramList->value))[2] = libcyc_apctl_get_fan_speed(cyc,FAN_3)) == -1) {
			((UInt32*)(paramList->value))[2] = 0;
		}
		break;
	case MODEL_ONSITE:
		if ((((UInt32*)(paramList->value))[0] = libcyc_apctl_get_fan_speed(cyc,FAN_1)) == -1) {
			((UInt32*)(paramList->value))[0] = 0;
		}
		if ((((UInt32*)(paramList->value))[1] = libcyc_apctl_get_fan_speed(cyc,FAN_2)) == -1) {
			((UInt32*)(paramList->value))[1] = 0;
		}
		((UInt32*)(paramList->value))[2] = 0;
		break;
	default:
		((UInt32*)(paramList->value))[0] = 0;
		((UInt32*)(paramList->value))[1] = 0;
		((UInt32*)(paramList->value))[2] = 0;
	}

	return (kCycSuccess);
}

static Result GetKVMBoard(CycCatKeyTable *pCkIndex,CycParam *paramList)
{
	UInt32 *analog = (UInt32 *)(paramList->value);
	UInt32 *numports = (UInt32 *)(paramList->value) + 1;
	UInt32 *numports_1 = (UInt32 *)(paramList->value) + 2;
	UInt32 *numstations = (UInt32 *)(paramList->value) + 3;
	UInt32 *numstations_1 = (UInt32 *)(paramList->value) + 4;
	UInt32 *maxports = (UInt32 *)(paramList->value) + 5;
	
	dolog("GetKVMBoard()");
	*numstations = 0;
	*numstations_1 = 0;
	*numports = 0;
	*numports_1 = 0;
	*analog = 0;
	*maxports = MAXKVMPORTS;
	
	switch (mt.board_type) {
		case BOARD_KVM16:
			*numports = 16;
			*numstations = 2;
			*analog = 1;
			break;
		case BOARD_KVM32:
			*numports = 32;
			*numstations = 2;
			*analog = 1;
			break;
		case BOARD_KVMNET16:
			*numports = 16;
			*numstations = 2;
			break;
		case BOARD_KVMNET32:
			*numports = 32;
			*numstations = 2;
			break;
		case BOARD_KVMP16:
			*numports = 16;
			*numstations = 6;
			break;
		case BOARD_KVMP32:
			*numports = 32;
			*numstations = 6;
			break;
		default:
/* Please, FIXME !!! */
			*numports = 8;
			*numstations = 2;
			break;
	}
	*numports_1 = *numports + 1;
	*numstations_1 = *numstations + 1;
	return (kCycSuccess);
}
#endif //KVM		
	
//========================================================================

//========================================================================
// RdTs110Info - Read TS110 digital/analog ports info
//========================================================================
static Result RdTs110Info(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	FILE *fp;
	unsigned char buffer[512];
	unsigned char *value, *v, *val;
	int i=0, j=0;
	int *digitalPtr = NULL;
	char *analogPtr = NULL;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	
	dolog("RdTs110Info()");

	if (pCkIndex->key == kDigitalStatus)
	{
		digitalPtr = paramList->value;
		system("/bin/pu -r -d /dev/gpio -l > /tmp/gpio_web");

		if ((fp = fopen("/tmp/gpio_web", "r")) == NULL)
		{
			LogError(FILE_READ_ERROR, "/tmp/gpio_web");
			return (kFileReadError);
		}
		while (fgets(buffer, sizeof(buffer), fp)) 
		{
			if (j++ < 1) continue; /* Filter first line out */
			value = buffer;
			for (i = 0; i < 30; i++) 
			{
				if (*value == '-') break;
					value++;
			}
			if (i == 30) break;
			*value = 0;
			value++;
			val = v =	value;
			while (*v && isspace(*v)) v++;
			value = val = v;
			while (*val && !isspace(*val)) val++;
			*val=0;
			if (!strncmp(value, "open", strlen(value)))
				*digitalPtr = kOpen;
			else
				*digitalPtr = kClosed;

			dolog("Digital status: %d", *digitalPtr);
			digitalPtr++;	
		}
		fclose(fp);
		system("rm -f /tmp/gpio_web");
	}
	else
	{
		analogPtr = paramList->value;
		system("/bin/pu -r -d /dev/adc1 > /tmp/adc1_web");

		if ((fp = fopen("/tmp/adc1_web", "r")) == NULL)
		{
			LogError(FILE_READ_ERROR, "/tmp/adc1_web");
			return (kFileReadError);
		}

		j = 1;
		while (fgets(buffer, sizeof(buffer), fp)) 
		{
			value = v = buffer;
			while (*v && !isspace(*v)) v++;
			*v=0;
			strcpy(analogPtr, value);
			dolog("First analog info: %s", analogPtr);
			analogPtr+=(pCkIndex->size);
		}
		fclose(fp);
		system("rm -f /tmp/adc1_web");

		system("/bin/pu -r -d /dev/adc2 > /tmp/adc2_web");

		if ((fp = fopen("/tmp/adc2_web", "r")) == NULL)
		{
			LogError(FILE_READ_ERROR, "/tmp/adc2_web");
			return (kFileReadError);
		}

		while (fgets(buffer, sizeof(buffer), fp)) 
		{
			value = v = buffer;
			while (*v && !isspace(*v)) v++;
			if (*v) *v++=0;
			strcpy(analogPtr, value);
			dolog("Second analog info: %s", analogPtr);
		}
		fclose(fp);
		system("rm -f /tmp/adc2_web");
	}
	return (kCycSuccess);
}

//========================================================================
// RdUnitInfo - Read unit's system info
//========================================================================
static Result RdUnitInfo(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	if(!paramList) return kSystemError;

	switch (pCkIndex->key)
	{
		case kUnitVersionInfo:
			GetVersion(pCkIndex, paramList);
			break;
		case kDate:
			GetDate(pCkIndex, paramList);
			break;
		case kPwrSupplyInfo:
			GetPwrSupplyInfo(pCkIndex, paramList);
			break;
		case kCpuInfo:
			GetCpuInfo(pCkIndex, paramList);
			break;
		case kMemInfo:
			GetMemoryInfo(pCkIndex, paramList);
			break;
		case kUpTime:
			GetUpTime(pCkIndex, paramList);
			break;
#if defined(KVM) || defined(ONS)
		case kKVMPortStatus:
			GetKVMPortStatus(pCkIndex, paramList);
			break;
		case kFanStatus:
			GetFanStatus(pCkIndex, paramList);
			break;
		case kInterfacesInfo:
			GetInterfacesInfo(pCkIndex, paramList);
			break;
		case kKVMBoard:
			GetKVMBoard(pCkIndex, paramList);
			break;
#endif
		default:
			break;
	}

	/* Return success even though one of these
	 calls may have failed. Show all possible info */
	return (kCycSuccess); 
}

char *CycGetBoardName(void)
{
#if defined(KVM) || defined(ONS)
    return(mt.name);
#else
    return(mt.board_name);
#endif
}

//========================================================================
// CycGetFamilyModel - Gets the product line: ACS, ONS, KVM, ...
//========================================================================

char *CycGetFamilyModel(void)
{
//	char *temp; WebApi.c:8212: warning: unused variable `temp'
#ifdef KVM
    return("KVM");
#else
#ifdef ONS
    return("ONS");
#else
    return("ACS");
#endif
#endif
}

//========================================================================
// CycGetFamilyExt - Gets the product line extra info: KVMNETPLUS, ...
//========================================================================

char *CycGetFamilyExt(void)
{
    char *temp;

    if ((temp = getenv("FamilyExt"))) return(temp);

#ifdef KVMNETP
    return("KVMNETP");
#endif
    return("UNDEF");
}


//========================================================================
// get_picture - Gets picture name based in the model
//========================================================================

void get_picture(void)
{
#ifdef KVM
#if defined(KVMNETP)
    char *def = "kvmp.jpg";
#else
    char *def = "kvm.gif";
#endif
#elif defined(ONS)
	char *def = "ons.jpg";
#else
    char *def = "acs.jpg";
#endif
	char *aux = NULL;
	struct stat st;
	char fname[64];

    switch (mt.board_type) {
    case BOARD_TS2100:
#ifdef OEM2
		aux = "cs32.gif";
#endif

#ifdef OEM3
		aux = "acs32.gif";
#endif

#ifdef OEM4
		aux = "cs32.gif";
#endif
		break;
	case BOARD_TS1100:
#ifdef OEM2
		aux = "cs16.gif";
#endif

#ifdef OEM3
		aux = "cs16.gif";
#endif

#ifdef OEM4
		aux = "cs16.gif";
#endif
		break;
	case BOARD_ACS1:
		aux = "acs1.gif";
		break;
	case BOARD_ONS441:
	case BOARD_ONS481:
	case BOARD_ONS881:
	case BOARD_ONS882:
	case BOARD_ONS442:
	case BOARD_ONS482:
	case BOARD_ONS841:
	case BOARD_ONS842:
		break;
	}

	if (aux == NULL) {
		goto def_name;
	}

	snprintf(fname, sizeof(fname), "/%s/Images/%s", WebPagesDir, aux);

	if (stat(fname, &st)) {
		goto def_name;
	}

	snprintf(picture_name, sizeof(picture_name), "%s", aux);
	dolog("get_picture : %s", picture_name);
	return;

def_name:
	strcpy(picture_name, def);
	dolog("get_picture : default[%s]", picture_name);
}

//========================================================================
// RdSwVersionModel - Gets Sw Version, picture name, unit model, etc
//========================================================================
static Result RdSwVersionModel(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	dolog("RdSwVersionModel()");
	dolog("RdSwVersionModel() - version %s model %s", mt.version, mt.board_name);

	switch (pCkIndex->key) {
		case kMacAddress:
			sprintf((char *)paramList->value,"%c%c:%c%c:%c%c:%c%c:%c%c:%c%c",
				 mt.mac_address[0],
				 mt.mac_address[1],
				 mt.mac_address[2],
				 mt.mac_address[3],
				 mt.mac_address[4],
				 mt.mac_address[5],
				 mt.mac_address[6],
				 mt.mac_address[7],
				 mt.mac_address[8],
				 mt.mac_address[9],
				 mt.mac_address[10],
				 mt.mac_address[11]);
			break;
		case kSwVersion:
			strcpy((char *)paramList->value, mt.version);
			break;
		case kModel:
#ifdef KVM
			if (!strncmp(mt.board_name, "KVMN", 4)) {
				sprintf((char *)paramList->value, "KVM/net %s",
					mt.board_name + 4);
			} else if (!strncmp(mt.board_name, "KVMP", 4)) {
				sprintf((char *)paramList->value, 
					"KVM/net Plus %s",
					mt.board_name + 4);
			} else if (!strcmp(mt.board_name + 2, "C5KVM")) {
				sprintf((char *)paramList->value, 
					"%c%c-port CAT5 KVM",
					mt.board_name[0], mt.board_name[1]);
			} else if (!strcmp(mt.board_name + 2, "IPKVM")) {
				sprintf((char *)paramList->value, 
					"%c%c-port IP KVM",
					mt.board_name[0], mt.board_name[1]);
			} else {
				strcpy((char *)paramList->value, mt.board_name);
			}
#else
			strcpy((char *)paramList->value, mt.board_name);
#endif
			break;
		case kPicture:
			get_picture();
			strcpy((char *)paramList->value, picture_name);
			break;
		case kNumber:
#if defined(KVM) || defined(ONS)
			switch (mt.board_type) {
				case BOARD_KVM16:
				case BOARD_KVMNET16:
				case BOARD_KVMP16:
					*(int *)paramList->value = 16;
					break;
				case BOARD_KVM32:
				case BOARD_KVMNET32:
				case BOARD_KVMP32:
					*(int *)paramList->value = 32;
					break;
#if defined(ONS)
				case BOARD_ONS441:
				case BOARD_ONS841:
				case BOARD_ONS442:
				case BOARD_ONS842:
					*(int *)paramList->value = 4;
					break;
				case BOARD_ONS481:
				case BOARD_ONS482:
				case BOARD_ONS881:
				case BOARD_ONS882:
					*(int *)paramList->value = 8;
					break;
#endif
				default:
					*(int *)paramList->value = mt.nportsS;
					break;
			}
#else
			*(int *)paramList->value = mt.nportsS;
#endif
			break;
#ifdef ONS
		case kNumberS:
			*(int *)paramList->value = mt.nportsS;
			break;
		case kNumberSA:
			*(int *)paramList->value = MAX_DEV;
			break;
#endif			
		default:
			break;
	}
	return (kCycSuccess);
}

//========================================================================
// RdWrtHostName - Read/Write /etc/hostname function
//========================================================================
static Result RdWrtHostName(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	//rdWrtFlg = 0 = read, 1 = write

	FILE *fp;
	char hostName[kHostNameLength];
	char *s;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	
	dolog("RdWrtHostName()");
	
	if (rdWrtFlg) 
	{
                if ((fp = fopen(pCkIndex->fileName, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			return (kFileWriteError);
		} 
		// !! Check/Validate configuration
    	        fprintf(fp,"%s\n", (char *)paramList->value);
                executeFlg |= EXE_SIGNAL_RAS; //[GY]2006/Jan/06  BUG#6040
	}
	else
	{
		*(char *)paramList->value = 0;
		if ((fp = fopen(pCkIndex->fileName, "r")) == NULL) 
		{
			LogError(FILE_READ_ERROR, pCkIndex->fileName);
			return (kFileReadError);
		}
		*hostName = 0;
		fgets(hostName, sizeof(hostName), fp);
		if ((s = strchr(hostName, '\n'))) {
			*s=0;
		}
		// !! Check/validate configuration 
		strcpy(paramList->value, hostName);
		//dolog("RdWrtHostName(): Hostname: [%s]", paramList->value);
	}

	fclose(fp);

  return (kCycSuccess);
}


//========================================================================
// RdWrtIssue - Read/Write /etc/issue function
//========================================================================
static Result RdWrtIssue(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	//rdWrtFlg = 0 = read, 1 = write

	FILE *fp;
	char issue[kConsoleBannerLength];
	unsigned int size;
	unsigned char *s, *a;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	dolog("RdWrtIssue()");

	if (rdWrtFlg) 
	{
    if ((fp = fopen(pCkIndex->fileName, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			return (kFileWriteError);
		}
    fprintf(fp,"%s\n\n", (char *)paramList->value);
	}
	else
	{
		if ((fp = fopen(pCkIndex->fileName, "r")) == NULL)
		{
			LogError(FILE_READ_ERROR, pCkIndex->fileName);
			return (kFileReadError);
		}
		size = fread(issue, 1, kConsoleBannerLength-1, fp);
		issue[size] = 0;
		s = a = issue;
		while (*a && *a != '\n') a++;
		if (*a) *a=0;
		strcpy((char *)paramList->value, s);
		dolog("RdWrtIssue(): Issue: [%s]", (char *)paramList->value);
	}

	fclose(fp);

  return (kCycSuccess);
}

//========================================================================
// RdWrtResolvConf - Read/Write /etc/resolv.conf 
//========================================================================
static Result RdWrtResolvConf(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
  FileBuffer *buf;
	FILE *fp;
  char *line, *line2;
  int len;
	char *shellValue;
	DnsService dnsInfo = {{0}}, *pdnsInfo;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	dolog("RdWrtResolvHostConf()");

	if (rdWrtFlg)
	{
		pdnsInfo = (DnsService *)paramList->value;
		if ((fp = fopen (pCkIndex->fileName, "w")) == NULL) 
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			return (kFileWriteError);
		}
		if (*(pdnsInfo->dns1))
			fprintf(fp, "nameserver %s\n", pdnsInfo->dns1);
		if (*(pdnsInfo->dns2))
			fprintf(fp, "nameserver %s\n", pdnsInfo->dns2);
		if (*(pdnsInfo->domainName))
			fprintf(fp, "domain %s\n", pdnsInfo->domainName);
		fclose(fp);
	}
	else
	{
		if ((buf = read_file(pCkIndex->fileName)) == NULL)
		{
			LogError(FILE_READ_ERROR, pCkIndex->fileName);
			return(kFileReadError);
		}

		if ((line = search_var(buf, "nameserver", 0)) != NULL)
		{
			get_value_from_config_line(line, buf, &shellValue, &len, 2);
			strncpy(dnsInfo.dns1, shellValue, len);
			if ((line2 = search_var_within_section(line, buf, "nameserver", 1)) != NULL)
			{
				get_value_from_config_line(line2, buf, &shellValue, &len, 2);
				strncpy(dnsInfo.dns2, shellValue, len);
			}
		}
			
		if ((line = search_var(buf, "search", 0)) != NULL)
		{
			get_value_from_config_line(line, buf, &shellValue, &len, 2);
			strncpy(dnsInfo.domainName, shellValue, len);
		}
		else
		{
			if ((line = search_var(buf, "domain", 0)) != NULL) {
				get_value_from_config_line(line, buf, &shellValue, &len, 2);
				strncpy(dnsInfo.domainName, shellValue, len);
			}
		}

		memcpy(paramList->value, &dnsInfo, sizeof(dnsInfo));
		free(buf);
	}

	return(kCycSuccess);
}

//========================================================================
// RdWrtHostConf - Read/Write /etc/host.conf 
//========================================================================
static Result RdWrtHostConf(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
  FileBuffer *buf;
	FILE *fp;
  char *line;
  char temp[15]={0};
  int len;
	char *shellValue;
	NameServiceAccess multiIpAccessOrder = {0}, *pmultiIpAccessOrder;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	dolog("RdWrtHostConf()");

	if (rdWrtFlg)
	{
		pmultiIpAccessOrder = (NameServiceAccess *)paramList->value;
		if ((fp = fopen (pCkIndex->fileName, "w")) == NULL) 
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			return (kFileWriteError);
		}
		// !!! Must check if it's 'none' then don't print order
		if (pmultiIpAccessOrder->accessOrder != 0)
		{
			fprintf(fp, "order %s\n", TransOptGetStr(AccessOrderOptions, SIZE_AccessOrderOptions, pmultiIpAccessOrder->accessOrder)); 
		}
		fprintf(fp, "multi %s\n", TransOptGetStr(OffOnOptions, SIZE_OffOnOptions, pmultiIpAccessOrder->multiIp)); 
		fclose(fp);
	}
	else
	{
		if ((buf = read_file(pCkIndex->fileName)) == NULL)
		{
			LogError(FILE_READ_ERROR, pCkIndex->fileName);
			return(kFileReadError);
		}

		if ((line = search_var(buf, "order", 0)) != NULL)
		{
			get_value_from_config_line(line, buf, &shellValue, &len, 2);
			memcpy(temp, shellValue, len);
			multiIpAccessOrder.accessOrder = TransOptGetVal(AccessOrderOptions, SIZE_AccessOrderOptions, temp, strlen(temp));
			memset(temp, 0, sizeof(temp));
		}
		if ((line = search_var(buf, "multi", 0)) != NULL)
		{
			get_value_from_config_line(line, buf, &shellValue, &len, 2);
			memcpy(temp, shellValue, len);
			multiIpAccessOrder.multiIp = TransOptGetVal(OffOnOptions, SIZE_OffOnOptions, temp, strlen(temp));
		}
		memcpy(paramList->value, &multiIpAccessOrder, sizeof(multiIpAccessOrder));
		free(buf);
	}

	return(kCycSuccess);
}

//========================================================================
// RdWrtGateWay - Read/Write gateway IP into /etc/network/st_routes
//========================================================================
static Result RdWrtGateWay(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	FILE *fp;
  char buf[512];
  unsigned char *t, *s, *c;	
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	int noSet = 1;	// [RK]Feb/24/05  
															// gets changed	
	//int foundDefaultRoutePreviously = 0; 
	
	dolog("RdWrtGateWay()");
	if ((fp = fopen (pCkIndex->fileName, "r")) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		return (kFileReadError);
	}
	memset(buf,0,512); //[RK]Feb/24/05
	fread(buf, 1, 511, fp);
	fclose(fp);

	if (rdWrtFlg)
	{
		if ((fp = fopen (pCkIndex->fileName, "w")) == NULL) 
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			return (kFileWriteError);
		}
		executeFlg |= EXE_SIGNAL_RAS;

		s = buf;

		//[RK]Feb/24/05 - parse problem	
		while(*s)		
		{						
			t = s;
			while (*s && *s!='\n') s++;
			if (*s) *s++=0;
			
			if (noSet) {
				/*WebApi.c:8669: warning: suggest parentheses around 
				 assignment used as truth value
				 if (c = strstr(t,"default")) {*/
				if ((c = strstr(t,"default")) != NULL) {
					/* WebApi.c:8670: warning: suggest parentheses 
					around assignment used as truth value
					if (c = strstr(c,"gw")) {*/
					if ((c = strstr(c,"gw")) != NULL) {
						if (*(char *)paramList->value) 
							fprintf(fp, "/sbin/route add default gw %s\n", 
								(char *)paramList->value);
						noSet = 0;
						continue;
					}
				}
			}	
			fprintf(fp, "%s ", t);
			fprintf(fp, "\n");
		} 
		
		// This adds a default route if there wasn't one before
		if (noSet)
		{
			if (*(char *)paramList->value)
			{
				fprintf(fp, "/sbin/route add default gw %s\n", (char *)paramList->value);	
			}
		}
		fclose(fp);
	}
	else // Gateway is only modified in normal mode 
	{
		s = buf;
		//[RK]Feb/24/05 - parse problem	
		while(*s)		
		{						
			t = s;
			while (*s && *s!='\n') s++;
			if (*s) *s++=0;
			
			/* WebApi.c:8703: warning: suggest parentheses around 
			assignment used as truth value
			if (c = strstr(t,"default")) */
			if ((c = strstr(t,"default")) != NULL) {
				/*WebApi.c:8704: warning: suggest parentheses 
				around assignment used as truth value 
				if (c = strstr(c,"gw")) */
				if ((c = strstr(c,"gw")) != NULL) {
					c += 2; //skip default
					while (*c && isspace(*c)) c++;
					t = c;
					while (*c && !isspace(*c)) c++;
					*c = 0;
					strcpy((char *)paramList->value, t);
					return(kCycSuccess);
				}
			}	
		} 
	}
	return (kCycSuccess);
}

//========================================================================
// Control - Translate characters
//========================================================================
static char *Control(int ch)
{
static char str_ch[4];

  if (!ch) {
    return "off";
  }
  if (ch >= 0x20) {
    str_ch[0] = ch;
    str_ch[1] = 0;
  } else {
    str_ch[0] = '^';
    str_ch[1] = '@'+ch;
    str_ch[2] = 0;
  }
  return(str_ch);
}

//========================================================================
// ParseConfGroups  - Parse a conf.group line and get group name and users
//========================================================================
static void ParseConfGroups(ConfGroups *pGroup, unsigned char *s)
{
	int i=0;
	unsigned char *p;
	
	dolog("ParseConfGroups()");

	if (!s || !*s) return;
	p=s;
	while (*s && *s!=':') s++,i++;
	strncpy(pGroup->newGrpName, p, i);
	pGroup->newGrpName[i] = '\0';
dolog("Name of group: [%s]", pGroup->newGrpName);
	if (*s++) { //there are users
		while (isspace(*s)) s++;
		p=s; i=0;
		while (*s) s++, i++;
		strncpy(pGroup->usersInGrp, p, i);
		pGroup->usersInGrp[i] = '\0';
dolog("Users in group: [%s]", pGroup->usersInGrp);
	}
}

//========================================================================
// ReadPslaveGroups - Read conf.group line
//========================================================================
static Result ReadPslaveGroups(char *groups, void *pValue, int key, int collectionSize)
{
	int i = 0;
	ConfGroups *pg;
	
	dolog("ReadPslaveGroups()");

	pg = (ConfGroups *)pValue;

	while (groups) {
		++i;
		if (key == kConfGroup)
		{
			if (i > collectionSize)
			{
				LogError("Number of groups configured exceeded the available amount of space for storage");
				dolog("Error: Exceeded number of possible entries. Should exit.");
				return (kExceedSpaceAvail);
			}
			ParseConfGroups(pg, groups+4);
			pg++;
		}
		groups = *(char **)groups;
	}
	if (key == kNumConfGroups)
		*((int *)pValue) = i;

	return (kCycSuccess);
}
//========================================================================
// DeterminNisType - Determines the NIS authication type
//========================================================================
int DetermineNisType(unsigned char *s)
{
	unsigned char *word;
	int type = -1;
	int i=0;

	while (*s)
	{
		i++;
	  while (isspace(*s)) s++;
    word=s;
    while (*s && !isspace(*s)) s++;
    if (*s) *s++=0;
		
dolog("%s[%d] %d word is %s", __FUNCTION__, __LINE__, i, word);
		switch (i)
		{
			case 1:
				if (!strcmp(word, "files"))
				{
					type = kPatLocal;	
					break;
				}
				if (!strcmp(word, "nis")) {
					type = kPatNis;	
				}
				break;
			case 2:
				if (!strcmp(word, "nis"))	
				{
					if (type == kPatLocal)
					{
						type = kPatLocalNis;	
					}
					break;
				}
				if (!strcmp(word, "files"))
				{
					if (type == kPatNis)
					{
						type = kPatNisLocal;	
					}
					break;
				}
				if (!strcmp(word,"[")) {
					if (type == kPatNis){
						type = kPatNisDownLocal;	
					}
				}
				break;
		} //end of switch
	}
	return(type);
}

//========================================================================
// ReturnNisType - Function that just returns the nis type
//========================================================================
int ReturnNisType(int rdWrtFlg)
{
	FILE *fp;
  unsigned char *a, *buf, *s, *t, *w;
  int type=0;

	dolog("ReturnNisType()");

	if ((buf = ReadFile(NSSWITCH_CONF_FILE, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, NSSWITCH_CONF_FILE);	
		return(kFileReadError);
	}

	if (rdWrtFlg)
	{
		if ((fp = fopen(NSSWITCH_CONF_FILE, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, NSSWITCH_CONF_FILE);
			free(buf);
			return (kFileWriteError);
		}
	}

	t = s = buf;

	while (*s)
  {
    while (*s && *s!='\n') s++;
    if (*s) *s++=0;

    //Parse and get word, argument
    switch (ParseLineNis(t, &w, &a))
    {
      case 1:
		dolog("Word: [%s], Rest of the line: [%s]", w, a);
				if (!strcmp(w, "passwd"))
				{
					if ((type = DetermineNisType(a)) != -1)
					{
						return (type);
					}
				}
				t = s;
        break;

      default:
        t = s;
        break;
		} // end of switch
	}
	
	free(buf);
	return (-1);
}
//========================================================================
// ServiceOnOff - When rdWrtFlg = 1 => Enables/disables services
// When rdWrtFlg = 0 => 
//						Returns kYes if service is configured to be active 
//            Returns kNo if service is configured to be inactive 
//========================================================================
CycYesNoOption ServiceActive(char *fileName, char *key, CycYesNoOption enable, int rdWrtFlg) 
{
	CycYesNoOption result = kNo;
	FileBuffer *buf;
	char *line, *shellValue;
	char val[BUF_CUSHION1];
	int flgIns, len;

	dolog("ServiceActive()");

	if ((buf = read_file(fileName)) == NULL) {
		LogError(FILE_READ_ERROR, fileName);
		return (kFileReadError);
	}

	if ((line = search_var(buf, key, 0)) == NULL) {
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "DPARM", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_shell_line(val, key, TransOptGetStr(EnableOptions, SIZE_EnableOptions, enable), 1);
			insert_line(line, buf, val, flgIns);
		}
	} else {
		if (rdWrtFlg) {
			replace_Value(line, buf, TransOptGetStr(EnableOptions, SIZE_EnableOptions, enable), 0);
		} else {
			get_value_from_config_line(line, buf, &shellValue, &len, 0);
			result = TransOptGetVal(EnableOptions, SIZE_EnableOptions, shellValue, len);
		}
	}

	if (rdWrtFlg) {
		executeFlg |= EXE_DAEMON_SH;
		write_file(buf, fileName);
	}
	free(buf);
	return (result);
}

//========================================================================
// ReadPslaveParam - Read pslave parameters
//========================================================================
static void ReadPslaveParam(CycCatKeyTable *pCkIndex, void *pValue, struct conf *pc, char *p)
{
	int i;
	y_types	y; //cy_ras.c, rwconf.c rwconf.h
	char ipAddr[16];
	struct lst *list;

	//dolog("ReadPslaveParam()");

	for( ; pc->name != NULL; pc++) 
	{
		if (strcmp(pc->name, pCkIndex->name) == 0)
		{
			y.yc = p+pc->offs;
			//dolog("ReadPslaveParam(): Y.yc: %x[%x] , Found value: [%s]", (int)y.yc, *y.yc, pc->name);
			switch(pc->type) 
			{
				case C_STR:
				case C_MSTR:
				case C_CHAT:
					if (*(y.ypc)) 
					{
						if (pCkIndex->key == kTty)
						{
							*((int *)pValue) = kYes;
							break;
						}
						memcpy(pValue, *y.ypc, strlen(*y.ypc)); 
					//	dolog("Parameter string found: [%s]", (char *)pValue);
					} 
					else
					{
						if (pCkIndex->key == kTty)
           				{
							*((int *)pValue) = kNo;
            			}
					}
					break;
				case C_IPNO:
				case C_IPDY:
				case C_HOST:
					sprintf(ipAddr, "%d.%d.%d.%d",  y.yc[0], y.yc[1], y.yc[2], y.yc[3]);
					if (!strcmp(ipAddr, "0.0.0.0"))
						((char *)pValue)[0] = '\0';
					else
						memcpy(pValue, ipAddr, pCkIndex->size); 
					//dolog("IP found: [%s]", (char *)pValue);
					break;
				case C_CHAR:
					memcpy(pValue, Control(*y.yi), pCkIndex->size); 
					dolog("Character found: [%s]", (char *)pValue);
					break;
				case C_INT:
				case C_INDY:
					*((int *)pValue) = *y.yi;
					//dolog("Value found: [%d]", *(int *)pValue);
					break;
				case C_LIST:
					list = pc->opts;
					for(i = 0; list[i].name; i++) 
					{
						if (list[i].value == *y.yi) 
						{
                            // Special case for checking if authtype is type NIS
                            if (((pCkIndex->key == kAuth) || (pCkIndex->key == kUnitAuth))
									&& *y.yi == kPatLocal)
                            {
                                if (ServiceActive(NIS_SHELL, "ENABLE", kNo, 0))
                                {
                                    if ((*((int *)pValue) = ReturnNisType(0)) != -1) {
					//printf("found nistype is %d\n", *((int *)pValue));
                                        break;
									}
                                }
                            }
							//Need to have enums for all of list structures
							*((int *)pValue) = *y.yi;
							//dolog("list name: [%s] = list value: [%d]", list[i].name,  *(int *)pValue);
							break;
						}
					}
					if ((list[i].name == NULL) &&
						(pCkIndex->key == kUnitAuth)) {
						// set to local if the name is not found
						dolog("conf.authtype is not found, set value to local");
						*((int *)pValue) = kPatLocal;
						break;
					}	
					if (list[i].name == NULL) 
					{
						//dolog("list name = null");
						*((int *)pValue) = 0;
					}
					break;
			}
			break;  // value is found
		} 
	} // end of for loop
}

//========================================================================
// ConvertParamNumToString - Routine that converts list type to string
//========================================================================
unsigned char *ConvertParamNumToString(char *c, int pValue, struct conf *pc, char *p)
{
	int i;
	y_types	y; 
	struct lst *list;

	//dolog("ConvertParamNumToString()");

	for( ; pc->name != NULL; pc++) 
	{
		if (strcmp(pc->name, c) == 0)
		{
		//	dolog("ConvertParamNumToString(): Found value: %s", pc->name);
			y.yc = p+pc->offs;
			switch(pc->type) 
			{
				case C_LIST:
					list = pc->opts;
					for(i = 0; list[i].name; i++) 
					{
						if (list[i].value == pValue) 
						{
							return (list[i].name);	
						}
					}
					if (list[i].name == NULL) 
					{
						return (list[0].name);
					}
			}
		} 
	} // end of for loop
	return (NULL);
}

//========================================================================
// WritePslaveParam - Routine that checks on the type of parameter and 
// writes out to pslave.conf
//========================================================================
int WritePslaveParam(FILE *fp, char *w, char *c, CycKey key, void *pValue, struct conf *pc, char *p)
{
	int i, val;
	y_types	y; 
	struct lst *list;
	int local_type = AUTH_LOCAL;

	//dolog("WritePslaveParam()");

	for( ; pc->name != NULL; pc++) 
	{
		if (strcmp(pc->name, c) == 0)
		{
			dolog("WritePslaveParam(): Found value: %s", pc->name);
			y.yc = p+pc->offs;
			switch(pc->type) 
			{
				case C_STR:
				case C_MSTR:
				case C_CHAT:
					dolog("WritePslaveParam(): Printing %s.%s  %s", w, c, (char *)pValue);
					PrintLinePslave(fp, w, c, (char *)pValue);			
					return (1);
				case C_IPNO:
				case C_IPDY:
				case C_HOST:
					dolog("WritePslaveParam(): Printing %s.%s  %s", w, c, (char *)pValue);
					PrintLinePslave(fp, w, c, (char *)pValue);			
					return (1);
				case C_CHAR:
					dolog("WritePslaveParam(): Printing %s.%s  %s", w, c, (char *)pValue);
					PrintLinePslave(fp, w, c, (char *)pValue);			
					return (1);
				case C_INT:
				case C_INDY:
					dolog("WritePslaveParam(): Printing %s.%s  %d", w, c, *(int *)pValue);
					fprintf (fp, "%s.%s\t%d\n", w, c, *(int *)pValue);
					return (1);
				case C_LIST:
					list = pc->opts;
					val = *(int *)pValue;

					// Special case to translate any type of Nis auth to actual local authtype
					switch (val)
					{
						case kPatNis:
						case kPatLocalNis:
						case kPatNisLocal:
						case kPatNisDownLocal:
							ReadWriteNisAuthType(&val, 1);
							if (!ServiceActive(NIS_SHELL, "ENABLE", kNo, 0)) {
								ServiceActive(NIS_SHELL,"ENABLE",kYes,1);
							}
							val = kPatLocal;
							executeFlg |= EXE_DAEMON_SH;
							break;
						default:
							if (ServiceActive(NIS_SHELL, "ENABLE", kNo, 0))	{
								ReadWriteNisAuthType(&local_type, 1);
								ServiceActive(NIS_SHELL, "ENABLE", kNo, 1);	
								executeFlg |= EXE_DAEMON_SH;
							}
							break;
					}
					for(i = 0; list[i].name; i++) 
					{
						if (list[i].value == val) 
						{
							dolog("WritePslaveParam(): Printing %s.%s  %s", w, c, list[i].name);
							PrintLinePslave(fp, w, c, list[i].name);			
							return (1);	
						}
					}
					if (list[i].name == NULL) 
					{
						//dolog("list name = null");
						dolog("WritePslaveParam(): Printing %s.%s  %s", w, c, list[0].name);
						PrintLinePslave(fp, w, c, list[0].name);			
					}
					return (1);
			}
		} 
	} // end of for loop
	return (0);
}

#define DHCPD_PID_FILE      "/etc/dhcpc/dhcpcd-eth0.pid"

static void kill_dhcp(int val)
{
	int pid;
	FILE *fp;

	if (val) return;
	if ((fp = fopen( DHCPD_PID_FILE, "r" )) == NULL) return;

	if ( fscanf( fp, "%d", &pid ) != 1 ) {
		//printf("Error: Can't read dhcpcd pid from %s\n", DHCPD_PID_FILE);
		fclose( fp );
		return;
	}

	fclose( fp );
	kill(pid, SIGKILL);
	while(kill(pid, 0) != -1) {
		sleep(1);
	}
}

//========================================================================
// WrtPslave - Main routine that manages the writing of parameters in
// pslave.conf
//========================================================================
static Result WrtPslave(CycCatKeyTable *pCkIndex, CycParam *paramList) 
{

	// OK I doubt that the following is the smartest and efficient way of 
	// writing to pslave... but this is what i've got for now.

	FILE *fp;
	unsigned char *a, *buf, *s, *t, *w, *c, *k;
	SInt8 *b=0, *bb=0, *d, *dd;
	void *pVal = NULL;
	char temp[5];
	int i, found; 
	int rdGlobalOnly = 0, tmp = 0, numOfPorts=0;
	ConfGroups *cG;

	//dolog("WrtPslave()");

	// Read the file pslave.conf and writes it to the buffer 
	if ((buf = ReadFile(pCkIndex->fileName, 1)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	// Open the file to begin writing
	if ((fp = fopen(pCkIndex->fileName, "w")) == NULL)
	{
		LogError(FILE_WRITE_ERROR, pCkIndex->fileName);	
		free(buf);
		return (kFileWriteError);
	}
	// Clear FLAG_READ
	if (pCkIndex->flag & FLAG_READ) 
	{
		pCkIndex->flag &= ~FLAG_READ;
  	}

	// check if portArray contains only -1. if so, 
	// set flag that says it's global param only
	if (portsArray != NULL && *portsArray == -1)
	{
		rdGlobalOnly = 1;
	} 
	else if (portsArray != NULL)
	{	
		d = portsArray;
		while (*portsArray != 0)
		{
			dolog("Ports passed in: %d", *portsArray);
			numOfPorts++;
			portsArray++;
		}
		if ((b = malloc(numOfPorts * sizeof(SInt8))) == NULL) 
		{
			LogError(MALLOC_FAIL, numOfPorts * sizeof(SInt8));
			return (kMemAllocationFailure);
		}
		if ((bb = malloc(numOfPorts * sizeof(SInt8))) == NULL) 
		{
			LogError(MALLOC_FAIL, numOfPorts * sizeof(SInt8));
			return (kMemAllocationFailure);
		}
		memcpy(b, d, sizeof(SInt8)*numOfPorts);
		memcpy(bb, d, sizeof(SInt8)*numOfPorts);
	}

	t = s = buf;
	pVal = paramList->value;

	while (*s) 
	{
		found = 0;
		while (*s && *s!='\n') s++;
		if (*s) *s++=0;

		//Parse and get word, command, argument
		switch (ParseLinePslave (t, &w, &c, &a)) 
		{
			case 2:
				*(s-2) = '\r';
				*(s-1) = '\n';
				break;

			case 1:
				k=w;	
				if (*w == '#') w++;
				//dolog("W: %s, C: %s, A: %s", w, c, a);
				if (!strcmp(w, "all") && !strcmp(c, pCkIndex->name) && rdGlobalOnly == 1) 
				{
					// if parsed command is the same as current command name
					if(WritePslaveParam(fp, w, c, pCkIndex->key, pVal, &line_cfg[0], (char *)&allconf))
					{
						// Set flag to READ
						pCkIndex->flag |= FLAG_READ;
						found = 1;
					}
				}
				else if (strcmp(w, "conf") == 0 && strcmp(c, pCkIndex->name) == 0)
				{
					if (!strcmp(c, "dhcp_client")) {
						kill_dhcp(*(int *)pVal);
					}
					if (!strcmp(c, "group"))
					{
						found = 1;
						if (!pCkIndex->flag & FLAG_READ)
						{
							cG = (ConfGroups *)pVal;
							pCkIndex->flag |= FLAG_READ;
							for (i=0; i<paramList->collectionSize; i++)
							{	
								fprintf(fp, "%s.%s\t%s: %s\n", w, c, cG->newGrpName, cG->usersInGrp);
								cG++;
							}
						}
					}
					else 
					{
						if (WritePslaveParam(fp, w, c, pCkIndex->key, pVal, &main_cfg[0], (char *)&mainconf))
						{
							pCkIndex->flag |= FLAG_READ;
							found = 1;
						}
					}
				}
				else if (*w == 's')
				{	// Found s<x>.tty
					if (!strcmp(c, "tty") && !rdGlobalOnly && strcmp(pCkIndex->defaultPrefix, "conf"))
					{	
						d = b;
						for (i=0; i<numOfPorts; i++)
						{	
							sprintf(temp, "s%d", *d);
							if (*d != -2 && !strcmp(w, temp))
							{
								dolog("Current line is the same as Temp: %s = %s", w, temp);
								if (pCkIndex->key == kTty)
								{
									if (*(int *)pVal)
									{
										dolog("key == tty. Printing out %s.%s %s", w, c, a);
										fprintf(fp, "%s.%s\tttyS%d\n", w, c, *d);
										*d = -2;	
										found = 1;
										break;
									}
								}
								else
								{
									dolog("Printing out %s.%s %s", w, c, a);
									PrintLinePslave(fp, w, c, a);	
									//dolog("Writing out parameters after tty: %s.%s %s", w, pCkIndex->name, pVal);
									if(WritePslaveParam(fp, w, pCkIndex->name, pCkIndex->key, pVal, &line_cfg[0], (char *)&allconf))
									{
										pCkIndex->flag |= FLAG_READ;
										// If found match, just set that port to -2, so later on
										// I will be able to tell which ports have already been read.
										*d = -2;		
										found = 1;
										if (pCkIndex->key == kSocketPort)
										{
											//dolog("Increment socket Port");
											*((int*)pVal)++;
										}
										break;
									}		
								}
							}
							d++;
						} // end of for loop
					} // end of command = tty
					else
					{ // Found s<x>.<pCkIndex->name>
						if (!strcmp(c, pCkIndex->name) && !rdGlobalOnly && strcmp(pCkIndex->defaultPrefix, "conf"))
						{
							dolog("WrtPslave(): Found 's*' and w = %s, c = %s, a = %s", w, c, a);
							// loop to see if word matches with any of the ports 
							// chosen to be modified
							d = b;
							dd = bb;
							for (i=0; i<numOfPorts; i++)
							{
								sprintf(temp, "s%d", *dd);
								if (!strcmp(w, temp)) {
									if (d[i] == -2)
									{
										found = 1;
										continue;
									}
									if(WritePslaveParam(fp, w, c, pCkIndex->key, pVal, &line_cfg[0], (char *)&allconf))
									{
										pCkIndex->flag |= FLAG_READ;
										// If found match, just set that port to -2, so later on
										// I will be able to tell which ports have already been read.
										d[i] = -2;		
										found = 1;
										if (pCkIndex->key == kSocketPort)
										{
											dolog("Increment socket Port 2");
											*((int *)pVal)++;
										}
									}		
								}
								dd++;
							}
						}
					} // end of if command not = tty
				}

				// Print out if current line doesn't match what 
				// we are looking for. 
				if (!found)
				{
					//Print out any new global configurations before port specific parameters 
					if (*w == 's' && !strncmp(c, "tty", 3) && !tmp && rdGlobalOnly)
					{
						if (!pCkIndex->flag & FLAG_READ)
						{
							if (WritePslaveParam(fp, pCkIndex->defaultPrefix, pCkIndex->name, pCkIndex->key, pVal, &line_cfg[0], (char *)&allconf))
							{
								tmp = 1;
							}
						}
					}
				//dolog("Finally Printing %s.%s  %s", k, c, a);
					PrintLinePslave(fp, k, c, a);
				}
				t = s;
				break;

			default:
				fprintf(fp, "%s\n", t);
				t = s;
				break;

		} // end of switch
	} // end of main while

	// Add any new 'conf' configurations
	if (!pCkIndex->flag & FLAG_READ && !strcmp(pCkIndex->defaultPrefix, "conf"))
	{
		cG = (ConfGroups *)pVal;
		if (pCkIndex->key == kConfGroup)
		{
			// Adding a brand new group
			for (i=0; i<paramList->collectionSize; i++)
			{
				dolog("Printing out the rest of groups: %s.%s\t%s: %s", pCkIndex->defaultPrefix, pCkIndex->name, cG->newGrpName, cG->usersInGrp);
				fprintf(fp, "%s.%s\t%s: %s\n", pCkIndex->defaultPrefix, pCkIndex->name, cG->newGrpName, cG->usersInGrp);
				cG++;
			}
		}
		else
		{
			WritePslaveParam(fp, pCkIndex->defaultPrefix, pCkIndex->name, pCkIndex->key, pVal, &main_cfg[0], (char *)&mainconf);
		}
	}

	fclose(fp);
	free(buf);
	if (b) free(b);

	return (kCycSuccess);
}

#ifdef BONDING_FEATURE
//**********************/
//****bonding start*****/
//**********************/

//========================================================================
// RdWrtBonding - Read/Write /etc/bonding.opts function
//
// ptr - not used, is here only for prototype compatibility in order to 
// allow this function to be inserted into the table at the beginning 
// of this file
// paramList - from this struct are read the fields key for the parameter
// to handle, and value for the parameter's value
// rdWrtFlg - if 0, it is a reading operation, otherwise, it is writting
//
// returns the (kCycSuccess) if successfull or the apropriate error code
// in case of failure 
//========================================================================
static Result RdWrtBonding(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	Result result = (kCycSuccess);
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	char paramname[20]; //just keeps the name for the bonding parameter being handled

	//lets make sure we have clean starting buffers
	bzero(paramname,20);

	//check for the param we are going to handle
	switch(paramList->key){
		case kBondingEnable: strncpy(paramname, "ENABLED", 19); break;
		case kBondingMiimon: strncpy(paramname, "MIIMONVALUE", 19); break;
		case kBondingUpdelay: strncpy(paramname, "UPDELAYVALUE", 19); break;
		default: return kInvalidKeyForCategory; //it cant be none of the above here
	}

	if(rdWrtFlg){ //write the file and hup cy_ras
		executeFlg |= EXE_SIGNAL_RAS;
		result = WrtBonding(pCkIndex->fileName, paramList, paramname);
	}
	else{ //read the configuration
		result = RdBonding(pCkIndex->fileName, paramList, paramname);
	}

	return result;
}

/*************************************************************************************************
 RdBonding - reads a parameter from the bonding.opts files and inserts it into the field value
 in paramList

 filename - name for the bonding configuration file, normally /etc/bonding.opts 
 paramList - this is a pointer for a structure from which we use the fields key to check which 
             parameter we are reading and value as a buffer where the read value will be stored
 parmname - name of the parameter into the configuration file

 Returns kCycSuccess if successfull or kFileReadError in case of no valid line for the parameter
 is found 
 ************************************************************************************************/
static Result RdBonding(char *filename, CycParam *paramList, char *parmname)   
{
	Result result = (kCycSuccess);
	char *p; //used whenever such a variable comes in handy :)
	char lineread[100]; //lines read from the bonding.opts configuration file
	int valueforparm = 0; //value found for parameter into the file
	FILE *fpb;

        bzero(lineread,100);
	//try to open the bonding configuration file
	if( (fpb = fopen( filename, "r")) == NULL){
		//could not open the file
		LogError(FILE_READ_ERROR, filename);
		return (kFileOpenError);
	}

	//read the file until the line with the desired parameter is found
	while(!feof(fpb)){
		fgets(lineread, 100, fpb);
		p = index(lineread, '#');
		if(p) *p = '\0'; //nulify commentaries in the same line

		if((p = strstr(lineread, parmname))) {
		//found the line with the desired parameter

			if(paramList->key == kBondingEnable){ //YES|NO value
				if(strstr(p, "YES")){
					*((int *)paramList->value) = kYes;
				}
				else if(strstr(p, "NO")){
					*((int *)paramList->value) = kNo;
				}
				//malformed line, must be YES or NO
				else result = kFileReadError; 
			}
			else{//integer value
				valueforparm = parseIntValue(lineread);
				if(valueforparm == -1) result = kFileReadError;//malformed line
					else *((int *)paramList->value) = valueforparm;
				}

		}//if(strstr(lineread, paramname))
	}//while(!feof(fpb))
	fclose(fpb);
	return result;
}

/***************************************************************************************************
 WrtBonding - writes the /etc/bonding.opts file with the parameter and value specified in 
 the paramList structure (fields key for the parameter name and value for its value). Only
 this parameter will be overwritten, the rest of the file will be preserved, including any
 commentaries found.

 filename - name for the bonding configuration file, normally /etc/bonding.opts 
 paramlist - structure containing the parameter to overwrite and the value
 parmname - string with the name of the parameter into the file

 Returns kCycSuccess if successfull, kFileWriteError in case of failure while writting the file 
 or kFileReadError in case it couldnt read the wholly original file to memory before changing
 the requested parameter. 
 **************************************************************************************************/
static Result WrtBonding( char *filename, CycParam *paramList, char *parmname)   
{
	char tempfilename[100]; 
	char fileline[100];
	char lineread[100];	
	char comand[100];

	char *p, *pp;
	//file pointers for the bonding file and temporary new file
	FILE *fpb, *fptemp;

	bzero(lineread,100);
	bzero(fileline,100);

	//the name for the temporary file will be /tmp/bonding.opts.PID
	sprintf(tempfilename, "/tmp/bonding.opts.%d", (int) getpid() );
	
	//try to open the bonding configuration file
	if( (fpb = fopen( filename, "r")) == NULL){
		//could not open the file
		LogError(FILE_READ_ERROR, filename);
		return (kFileOpenError);
	}

	//try to open the temporary file
	if( (fptemp = fopen( tempfilename, "w")) == NULL){
		//could not open the file
		LogError(FILE_READ_ERROR, tempfilename);
		return (kFileOpenError);
	}

	while(!feof(fpb)){
		if(!fgets(lineread,100,fpb)) break; 
		//make a backup from the original line read
		strncpy( fileline, lineread, 100 );

		//now lets check if this is the line we are going to change

		//first, eliminate everything starting from the # character (commentaries)
		if( (p = index(lineread,'#')) )	*p = '\0';

		if( strstr(lineread, parmname) ){ //change this line to a new value
			bzero(lineread,100);
			p = index(fileline,'#');
			if(p){
				//remove newline, this will be inserted afterwards
				//and we dont wish duplicity
				pp = index(p , '\n');
				if( pp ) *pp = '\0';
			}

			if(paramList->key == kBondingEnable){//YES|NO value
				snprintf(lineread, 100, "%s = %s %s\n", parmname, \
				*((int *)paramList->value) == kYes ? "YES" : "NO", \
				p ? p : ""); //insert again original commentary

			}
			else{
				snprintf(lineread, 100, "%s = %d %s\n", parmname, \
				*((int *)paramList->value), \
				p ? p : ""); //insert again original commentary
			}
			fputs(lineread, fptemp);
		}	
		else fputs(fileline, fptemp); //write the same line to the temp file

	}

	fclose(fpb);
	fclose(fptemp);

	snprintf( comand, 100, "cp %s %s", tempfilename, filename );
	system( comand );
	snprintf(comand, 100, "rm %s", tempfilename);
	system(comand);

	//overwrite the config file with the temp file
	return (kCycSuccess);	
}

/***************************************************************************************************
 parseIntValue - just parses a configline in the format parametername=value, reading only the value
 part, changing it to integer and returning it

 linefromfile - string in the format parametername = value (if there are spaces or not it wont
 matter

 returns the integer value that corresponds to the parameter, or -1 in case of error
 obs: this function was originally coded inside rwconf.c for use in cy_ras, and copied here 
 for convenience, since the same file (bonding.opts) is read here
 **************************************************************************************************/
int parseIntValue(char *linefromfile)
{
        //used to scan the limits for the integer value into the string
        char *p = linefromfile, *pf;

        //loof for the first digit
	while(!isdigit(*p) && (*p)) p++;
        if(!*p) return -1; //end of line and no number found

        pf = p; //ok, now look for the first non number to get the end of the value
	while( isdigit(*pf) && (*pf) ) pf++;
        *pf = '\0'; //mark here as the final of the string

        return atoi( p );
}

//*******************/
//****bonding end****/
//*******************/
#endif

//[RK]Dec/02/05 - Enable All Serial Ports
// EnableAllPorts - 
static Result EnableAllPorts(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	Result result = kCycSuccess;
	unsigned char *buf, *t, *s,cmd[100];
	FILE *fp;
	int port,not_ignore;
	
	if ((buf = ReadFile(pCkIndex->fileName, 1)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return result;
	}
	if ((fp = fopen(pCkIndex->fileName, "w")) == NULL) {
		LogError(FILE_WRITE_ERROR, pCkIndex->fileName);	
		free(buf);
		return result;
	}
	
	t = s = buf;

	while (*s) {
		while (*s && *s!='\n') s++;
		if (*s) *s++=0;
		not_ignore = 1;
		if (*t == '#') {
			if (sscanf(t+1,"s%d.%s ",&port,cmd) == 2) {
				if (!strcmp(cmd,"tty")) {
					if (port <= MAX_DEV) {
						fprintf(fp,"%s\n",t+1);
						not_ignore=0;
					}	
				}
			}
		}
		if (not_ignore) fprintf(fp,"%s\n",t);
		t = s;
	}
	
	free(buf);
	fclose(fp);

	executeFlg |= EXE_SIGNAL_RAS;

	return kCycSuccess;
}

//========================================================================
// RdWrtPslave - Read/Write /etc/portslave/pslave.conf function
//========================================================================
static Result RdWrtPslave(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	void *pVal = NULL;
	int port;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	Result result = kCycSuccess;

	if (rdWrtFlg && !portsArray  && !strcmp(pCkIndex->defaultPrefix, "all")) {
		dolog("RdWrtPslave() : ports array is NULL");
		return(kCycSuccess);
	}

	if (rdWrtFlg)
	{
		executeFlg |= EXE_SIGNAL_RAS; 
		// special case. If users enable data_buffering and syslog buf, skip
		// writing to pslave.conf. But if users disable db or syslog buf, then
		// write to pslave.conf
		if (paramList->key == kSyslogBuffEnable) {
			if (*(int *)paramList->value != 0) {
				dolog("Param value != 0");
				return result; 
			}
		}
		result = WrtPslave(pCkIndex, paramList);

		if (paramList->key == kUnitAuth) {
			executeFlg |= EXE_DAEMON_SH;
		}
	}
	else
	{
		pVal = paramList->value;
		
		/*while(*portsArray != 0)
    {
       dolog("Loop thru array Ports: %d", *portsArray++);
    } */
		// for conf group... should be in its own thing... need to get numofgroups. and have its own function
		// to search for all groups
		if (!strcmp(pCkIndex->defaultPrefix, "conf"))
		{
			//dolog("RdWrtPslave(): Current param is type CONF");
			if (!strcmp(pCkIndex->name, "group"))
			{
				ReadPslaveGroups(mainconf.groups, pVal, pCkIndex->key, paramList->collectionSize);
			}
			else
			{
				ReadPslaveParam(pCkIndex, pVal, &main_cfg[0], (char *)&mainconf);
			}
		}
		else 
		{	
			// Get values for each port and place into array. 
			// Most likely total number of ports for current box.
			if (portsArray == NULL) 
			{
				//dolog("RdWrtPslave(): portsArray is NULL");
				for (port=0; port<=paramList->collectionSize; port++, pVal+=pCkIndex->size)
				{
					ReadPslaveParam(pCkIndex, pVal, &line_cfg[0], (char *)&lineconf[port]);
				}
			}
			else 
			{
				//dolog("RdWrtPslave(): portsArray is NOT NULL");
				// Get "all.<command>" parameter values. 
				// Most likely called in wizard mode.
				if (*portsArray == -1)
				{
					//dolog("RdWrtPslave(): portsArray is -1");
					ReadPslaveParam(pCkIndex, pVal, &line_cfg[0], (char *)&allconf);
				}
				else
				{
					ReadPslaveParam(pCkIndex, pVal, &line_cfg[0], (char *)&lineconf[*portsArray-1]);
				}
			}
		} // end of section for non "conf" parameters
	}
	return (result);
}

static void WriteVirtualPorts(CycCatKeyTable *pCkIndex, CycParam *paramList, VirtualPortsInfo *pVPorts)
{
	unsigned char *buf, *t, *s,protocol[15];
	FILE *fp;
	VirtualPortsInfo *virtual;
	int port,i,j, not_ignore, firstp[20], lastp[20], action[20],localtcp, remotetcp, numVirtual;
	
	if ((buf = ReadFile(pCkIndex->fileName, 1)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return;
	}
	if ((fp = fopen(pCkIndex->fileName, "w")) == NULL) {
		LogError(FILE_WRITE_ERROR, pCkIndex->fileName);	
		free(buf);
		return;
	}
	
	numVirtual = paramList->collectionSize;
	virtual = (VirtualPortsInfo *)paramList->value;
	for (port=0; port < numVirtual; port++,virtual++) {
		action[port] = virtual->action;
		firstp[port] = virtual->firstLocalPort;
		lastp[port] = firstp[port] + virtual->numOfPorts;
	}

	t = s = buf;

	while (*s) {
		while (*s && *s!='\n') s++;
		if (*s) *s++=0;
		not_ignore = 1;
		if ((*t == 's') && (sscanf(t,"s%d.",&port) == 1)) {
			for (i=0; i < numVirtual; i++) {
				if ((port >=firstp[i]) && (port <= lastp[i])) {
					if (action[i] != kNone) not_ignore=0; // ignore the line
					break;
				}
			}
			if ((i == numVirtual) && lineconf[port-1].virtual) {
				not_ignore = 0; // ignore the line
			}
				
		}
		if (not_ignore) fprintf(fp,"%s\n",t);
		t = s;
	}
	
	virtual = (VirtualPortsInfo *)paramList->value;
	for (i=0; i < numVirtual; i++,virtual++) {
		if ((virtual->action != kAdd) && (virtual->action != kEdit)) {
		     continue;
	     	}
   		
		localtcp = virtual->localTcpPort;
		remotetcp = virtual->firstRemoteTcpPort;
		if (virtual->protocol == P_SOCKET_SERVER) {
			strcpy(protocol,"socket_server"); 
		} else {
			strcpy(protocol,"socket_ssh"); 
                }
	
		for (j=0,port=virtual->firstLocalPort;j < virtual->numOfPorts; 
						port++,j++) {
			fprintf(fp,"s%d.tty\t%s:%d\n",port,virtual->remoteIp,remotetcp++);
			//[RK]Sep/09/04 - Fixed bug#2434 : include IPNO parameter
			fprintf(fp,"s%d.ipno\t%s\n",port,virtual->remoteIp);
			fprintf(fp,"s%d.protocol\t%s\n", port,protocol);
			if (localtcp) {
		        	fprintf(fp,"s%d.socket_port\t%d\n", port, localtcp++);	
			}
			if (virtual->name[j][0]) {
				fprintf(fp,"s%d.alias\t%s\n",port,virtual->name[j]);
			}
		}
	}
	free(buf);
	fclose(fp);

	executeFlg |= EXE_SIGNAL_RAS; 
	pCkIndex->flag |= FLAG_READ;
}

//========================================================================
// RdWrtVirtualPorts - Read/Write virtual ports information
//========================================================================
static Result RdWrtVirtualPorts(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	char *p;
	int i, nVirtualPorts = 0, numports;
	struct line_cfg *pconf;
	char slavePortIp[25];
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	VirtualPortsInfo vPort, *pVPorts; 

	pVPorts = (VirtualPortsInfo *)paramList->value;

	dolog("RdWrtVirtualPorts()");

	if (rdWrtFlg) { 
		WriteVirtualPorts(pCkIndex, paramList, pVPorts);
	} else {
		memset((char*)&vPort,0,sizeof(VirtualPortsInfo));
		for (i=0, pconf=&lineconf[0]; i < MAXVLINES; i++, pconf++) 
		{
			if (pconf->this != i ||
				!pconf->tty || !*pconf->tty) {
				continue;
			}
	 
			if (pconf->protocol != P_SOCKET_SSH &&
				pconf->protocol != P_SOCKET_SERVER &&
				pconf->protocol != P_SOCKET_SERVER_RAW) {
				continue;
			}

			if (pconf->virtual) 
			{
				/* Parse current tty to obtain IP */
				strncpy(slavePortIp, pconf->tty, 25);
				if ((p=strchr(slavePortIp, ':')) != NULL) {
					*p++ = 0;
				}
				else
					continue;
				if (!strcmp(slavePortIp, vPort.remoteIp)) {
					// same slave IP
					if (pconf->alias && *pconf->alias) {
						strcpy(vPort.name[numports],pconf->alias);
					} else {
						memset(vPort.name[numports],0,kHostNameLength);
					}
					numports++;
					continue;
				}

				// new SLAVE IP
				if (nVirtualPorts) {
					if ((nVirtualPorts+1) > *(int*)paramList->collectionSize) {
						LogError("Caution: You have exceeded the number of slaves allowed.\n");
						return(kCycSuccess);
					}
					vPort.numOfPorts = numports;
					*pVPorts++ = vPort;
					memset((char*)&vPort,0,sizeof(VirtualPortsInfo));
				}
				 
				nVirtualPorts++; 
				vPort.action = kNone;
				strcpy(vPort.remoteIp, slavePortIp);
				vPort.firstRemoteTcpPort = atoi(p);
				vPort.localTcpPort = pconf->socket_port;
				vPort.protocol = pconf->protocol;
				vPort.firstLocalPort = i+1;
				numports = 1;	
				if (pconf->alias && *pconf->alias) {
					strcpy(vPort.name[0],pconf->alias);
				} else {
					memset(vPort.name[0],0,kHostNameLength);
				}
			}
		} // end of for loop

		if (nVirtualPorts) {
			vPort.numOfPorts = numports;
			numports = 0;	
			*pVPorts++ = vPort;
		}
		*(int*)paramList->collectionSize = nVirtualPorts;
	}
  return(kCycSuccess);
}

//========================================================================
// RdWrtCommentLineEntry:
//  Comment or UnComment lines when writing the values 0 or 1 to the file.
//  In the reading returns 0 or 1 if the line is commented or not.
//
//  the parameter ptr->name has a key/identification to the line.
//========================================================================
static Result RdWrtCommentLineEntry(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FileBuffer *buf;
	char *line;
	char val[BUF_CUSHION1];
	int yesNo;

	if (!rdWrtFlg) {
		*(int *)ParamList->value = 0;
	}

	if ((buf = read_file(pCkIndex->fileName)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		return (kFileReadError);
	}

	if ((line = search_var(buf, pCkIndex->name, 0)) == NULL) {
		line = search_var(buf, pCkIndex->name, 1);
	}

	if (line == NULL) {
		if (rdWrtFlg) {
			build_default_line(val, pCkIndex, ParamList);
			insert_line(NULL, buf, val, 2);
		}
	} else {
		if (rdWrtFlg) {
			yesNo = *(int *)ParamList->value;
			if (yesNo == kNo) {
				if (*line != '#') {
					insert_line(line, buf, "#", 0);
				}
			} else {
				if (*line == '#') {
					delete_chars(line, buf, 1);
				}
			}
		} else {
			get_value_from_line(line, buf, pCkIndex, ParamList);
		}
	}

	if (rdWrtFlg) {
		executeFlg |= EXE_DAEMON_SH;
		write_file(buf, pCkIndex->fileName);
	}
	free(buf);
	return (kCycSuccess);
}

static Result wrPublicKey(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int i;
	LoadKey *pk;
	int fd;
	char cmd[256];

	if (rdWrtFlg == 0) {
		return (kCycSuccess);
	}

	pk = (LoadKey *)paramList->value;

	for (i=0; i < paramList->collectionSize; pk++, i++) {
		snprintf(cmd, sizeof(cmd), "install -d %s/.ssh", pk->filePathName);
		system(cmd);
		snprintf(cmd, sizeof(cmd), "%s/.ssh/authorized_keys", pk->filePathName);
    	if ((fd = open (cmd, O_CREAT|O_RDWR|O_APPEND,
					S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) < 0) {
        	dolog("wePublicKey[%s]/open: %s", cmd, strerror(errno));
        	continue;
    	}

		if (write(fd, pk->PubKey, pk->size) != pk->size) {
			dolog("write_file[%s]/write: %s", cmd, strerror(errno));
		}
		close(fd);
	}

	return (kCycSuccess);
}

/* RdWrtKVM */
#define KVMD_CONF "/etc/kvmd.conf" 

#if defined(KVM) || defined(ONS)
#if 0
static Result RdWrtKVM(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	struct kvm_conf_def* conf_item;
	char result[256];
	char *kvmptr = (char *)(&kvmconf);

dolog("RdWrtKVM, pCkIndex->name = %s\n", pCkIndex->name);

	kvmreadcfg();

	for(conf_item = conf_cfg; conf_item->name; conf_item++){
		if(strcmp(conf_item->name, pCkIndex->name) == 0){
			int offset = conf_item->offs;
			int type = conf_item->type;
			char *ptr = &(kvmptr[offset]);

			switch(type){
			case KVM_C_LIST:
			case KVM_C_INT:
			{
				if(!rdWrtFlg) *(int *)(ParamList->value) = *((int *)(ptr));
				else *((int *)(ptr)) = *(int *)(ParamList->value);
				break;
			}
			case KVM_C_STR:
			{
				char *pp = ((char **)(ptr));
				if(!rdWrtFlg)
					strncpy((char *)(ParamList->value), *pp, ParamList->collectionSize);
				else{
				        if (*pp != NULL) {
						free(*pp);
						*pp = 0;
					}
					*pp = strdup((char *)(ParamList->value));
				}
				break;
			}
			}
			break;
		}
	}
	if(rdWrtFlg)
		kvmwritecfg();

	return (kCycSuccess);
}
#endif

static
int get_kvmd_keyval(char *p, char *key, char *value)
{
	char *q;

	q = key;
	while(*p && !isspace(*p) && *p != '#' && q < key+255)
		*(q++) = *(p++);
	if(!isspace(*p)) { return -1;}
	*q = 0;
	while(*p && isspace(*p)) p++; // skip spaces
	if(!*p) { return -1;}
	q = value;
	while(*p && !isspace(*p) && *p != '#' && q < value+255)
		*(q++) = *(p++);
	*q = 0;

	return 0;
}

static
int get_kvmd_list(struct kvm_lst_def *list, char *entry)
{
	struct kvm_lst_def *item;

	for(item = list; item->name; item++){
		if(strcmp(item->name, entry) == 0)
			return item->value;
	}
	return 0;
}

static
char *get_kvmd_list_entry(struct kvm_lst_def *list, int value)
{
	struct kvm_lst_def *item;

	for(item = list; item->name; item++){
		if(item->value == value)
			return item->name;
	}
	return 0;
}


static struct kvm_lst_def yesnolist[] = {
        {"yes", "Yes", 1},
        {"no", "No", 0},
        {"1", NULL, 1},
        {"0", NULL, 0},
        {NULL, NULL, 0}
};
/*
static struct kvm_lst_def enable_disable[] = {
        {"disable", "Disable", 0},
        {"enable", "Enable", 1},
        {NULL, NULL, 0}
};
*/
static struct kvm_lst_def authtypelist[] = {
	{"none", "None", 							AUTH_NONE},
    {"radius", "Radius", 						AUTH_RADIUS },
    {"tacplus", "TacacsPlus",   				AUTH_TacacsPlus  },
    {"remote", "Kerberos",      				AUTH_REMOTE  },
    {"local", "Local",          				AUTH_LOCAL  },
    {"radiuslocal",  "Radius/Local",			AUTH_RADIUS_LOCAL  },
    {"tacpluslocal", "Tacplus/Local", 			AUTH_TacacsPlus_LOCAL },
    {"localradius",  "Local/Radius",    		AUTH_LOCAL_RADIUS  },
    {"localtacplus", "Local/Tacplus",   		AUTH_LOCAL_TacacsPlus  },
    {"radiusdownlocal", "RadiusDownLocal",		AUTH_RADIUS_DOWN_LOCAL  },
    {"tacplusdownlocal", "TacplusDownLocal",	AUTH_TacacsPlus_DOWN_LOCAL  },
    {"kerberos", "Kerberos",					AUTH_KERBEROS },
    {"ldap", "Ldap",							AUTH_LDAP },
    {"kerberosdownlocal", "KerberosDownLocal",  AUTH_KERBEROS_DOWN_LOCAL },
    {"kerberoslocal", "Kerberos/Local",  		AUTH_KERBEROS_DOWN_LOCAL },
    {"ldapdownlocal", "LdapDownLocal",			AUTH_LDAP_DOWN_LOCAL },
    {"ldapdownlocal-radius", "LdapDownLocal-Radius",	AUTH_LDAP_DOWN_LOCAL_AND_RADIUS },
    {"ldaplocal", "Ldap/Local",					AUTH_LDAP_LOCAL },
    {"smb", "Windows NT/2k/2k3",				AUTH_SMB },
    {"smbdownlocal", "SmbDownLocal",			AUTH_SMB_DOWN_LOCAL },
    { "nis", "Nis",								AUTH_NIS },
    { "nislocal", "NisLocal",					AUTH_NIS_LOCAL },
    { "nisdownlocal", "NisDownLocal",			AUTH_NIS_DOWN_LOCAL },
    { "localnis", "Local/Nis",					AUTH_LOCAL_NIS },
	{NULL, NULL, 0}
};

static struct kvm_lst_def kbdtypelist[] = {
	{"us", "US", KBD_US},
	{"br-abnt", "BR-ABNT", KBD_ABNT},
	{"br-abnt2", "BR-ABNT2", KBD_ABNT2},
	{"jp", "Japanese", KBD_JP},
	{"de", "German", KBD_DE},
	{"it", "Italian", KBD_IT},
	{"fr", "French", KBD_FR},
	{"es", "Spanish", KBD_ES},
	{NULL, NULL, 0}
};
static
inline char *strrepl(char *str, char *oldstr, char *newstr)
{
        char *oldloc;
        char *s;

        /* find substring */
        oldloc = strstr(str, oldstr);
        if(!oldloc) return NULL;

        /* get new string */
        s = (char *)calloc(1,(strlen(str)-strlen(oldstr)+strlen(newstr))*sizeof(char));
        if(!s) return NULL;

        /* copy 1 */
        memcpy(s,str,oldloc-str);

        /* copy 2 */
        memcpy(oldloc-str+s,newstr,strlen(newstr));

        /* copy 3 */
        memcpy(oldloc-str+s+strlen(newstr),oldloc+strlen(oldstr),strlen(str)-(oldloc-str)-strlen(oldstr));

		if (str) {
			free(str);
			str = NULL;
		}
        return s;
}

/*****************************************************************
 * get_sequence - This routine converts a sequence to the format
 *  to be written in the configuration file.
 ****************************************************************/
static 
char *cvtsequence (char *ptr)
{
    unsigned char *newstr = NULL;

	newstr = calloc(1, (strlen(ptr) + 1));
	if (!newstr) {
		dolog("error in malloc of cvtsequence\n");
		return NULL;
	}
    strcpy(newstr, (unsigned char *)ptr);

    if ((strchr(newstr, '^') != NULL)) {
            newstr = strrepl(newstr, "^", "[CTRL]");
    }
    if ((strchr(newstr, '$') != NULL)) {
            newstr = strrepl(newstr, "$", "[ALT]");
    }
    if ((strchr(newstr, '#') != NULL)) {
            newstr = strrepl(newstr, "#", "[SHIFT]");
    }
    if ((strchr(newstr, '*') != NULL)) {
            newstr = strrepl(newstr, "*", "[WIN]");
    }

        return newstr;
}

static
int write_kvmd_cfg(KVMGeneralConfig *kvmconf,
                KVMStationConfig *kvmstationconf)
{
	FILE *fptr, *fptr2;
	unsigned char *newstr = NULL;

        dolog("write_kvmd_cfg()\n");
        if((fptr = fopen(KVMD_CONF".tmp", "w"))){
		int i;

		fprintf(fptr, "conf.authtype %s\n", get_kvmd_list_entry(authtypelist, kvmconf->authtype));
		fprintf(fptr, "conf.facility %d\n", kvmconf->facility);
		fprintf(fptr, "conf.ipsecurity %d\n", kvmconf->ipsecurity);
		fprintf(fptr, "conf.des %s\n", kvmconf->des ? "yes" : "no");
		fprintf(fptr, "conf.directacc %s\n", kvmconf->directacc ? "yes" : "no");
		if(kvmconf->escapeseq[0]) {
			newstr = cvtsequence(kvmconf->escapeseq);
			if (newstr && newstr[0]) {	
				fprintf(fptr, "conf.escapeseq %s\n", newstr);
				free (newstr);
				newstr = NULL;
			} else {
				// no conversion needed
				fprintf(fptr, "conf.escapeseq %s\n", kvmconf->escapeseq);
			}
		}
		if(kvmconf->sunmodifier[0]) {
			newstr = cvtsequence(kvmconf->sunmodifier);
			if (newstr && newstr[0]) {	
				fprintf(fptr, "conf.sunmodifier %s\n", newstr);
				free (newstr);
				newstr = NULL;
			} else {
				fprintf(fptr, "conf.sunmodifier %s\n", kvmconf->sunmodifier);
			}
		}
		if(kvmconf->viewerport[0])
			fprintf(fptr, "conf.viewerport %s\n", kvmconf->viewerport);

		for(i = 0; i < kMaxKVMStations+1; i++){
			fprintf(fptr, "s%d.idletimeout %d\n", i, kvmstationconf[i].idletimeout);
			fprintf(fptr, "s%d.screensavertime %d\n", i, kvmstationconf[i].screensavertime);
			fprintf(fptr, "s%d.cycletime %d\n", i, kvmstationconf[i].cycletime);
			fprintf(fptr, "s%d.kbdtype %s\n", i, get_kvmd_list_entry(kbdtypelist, kvmstationconf[i].kbdtype));
			if(kvmstationconf[i].quitseq[0])
				fprintf(fptr, "s%d.quitseq %s\n", i, kvmstationconf[i].quitseq);
			if(kvmstationconf[i].powerseq[0])
				fprintf(fptr, "s%d.powerseq %s\n", i, kvmstationconf[i].powerseq);
			if(kvmstationconf[i].srvsyncseq[0])
				fprintf(fptr, "s%d.srvsyncseq %s\n", i, kvmstationconf[i].srvsyncseq);
			if(kvmstationconf[i].videoconfseq[0])
				fprintf(fptr, "s%d.videoconfseq %s\n", i, kvmstationconf[i].videoconfseq);
			if(kvmstationconf[i].switchnextseq[0])
				fprintf(fptr, "s%d.switchnextseq %s\n", i, kvmstationconf[i].switchnextseq);
			if(kvmstationconf[i].switchprevseq[0])
				fprintf(fptr, "s%d.switchprevseq %s\n", i, kvmstationconf[i].switchprevseq);
			if(kvmstationconf[i].portinfoseq[0])
				fprintf(fptr, "s%d.portinfoseq %s\n", i, kvmstationconf[i].portinfoseq);
		}
		if((fptr2 = fopen(KVMD_CONF, "r"))){
			char buf[256];
			char *p;

			while(fgets(buf, 255, fptr2)){
				p = buf;
				while(*p && isspace(*p)) p++; // skip spaces
				if (strncmp(p, "conf.", 5) && *p != 's') {
					fprintf(fptr, buf);
				}
			}
			fclose(fptr2);
		}
		fclose(fptr);
		unlink(KVMD_CONF);
		rename(KVMD_CONF".tmp", KVMD_CONF);
		return 0;
	}
	return -1;
}

static
int read_kvmd_cfg(KVMGeneralConfig *kvmconf,
		KVMStationConfig *kvmstationconf)
{
	FILE *fptr;

	dolog("read_kvmd_cfg()\n");
	if((fptr = fopen(KVMD_CONF, "r"))){
		char key[256], value[256];
		char buf[256];
		char *p, *q;

		dolog("read_kvmd_cfg() 1\n");
		while(fgets(buf, 255, fptr)){
			p = buf;
			while(*p && isspace(*p)) p++; // skip spaces
			if(*p == '#' || !*p) continue; // skip comments and empty lines
			if(strncmp(p, "conf.", 5) == 0){
				/* kvm general */
				p += 5;
				if(get_kvmd_keyval(p, key, value) < 0)
					return -1;

				if(strcmp(key, "authtype") == 0){
					kvmconf->authtype = get_kvmd_list(authtypelist, value);
				}else if(strcmp(key, "facility") == 0){
					kvmconf->facility = atoi(value);
				}else if(strcmp(key, "ipsecurity") == 0){
					kvmconf->ipsecurity = atoi(value);
				}else if(strcmp(key, "des") == 0){
					kvmconf->des = get_kvmd_list(yesnolist, value);
				}else if(strcmp(key, "directacc") == 0){
					kvmconf->directacc = get_kvmd_list(yesnolist, value);
				}else if(strcmp(key, "escapeseq") == 0){
					strncpy(kvmconf->escapeseq, value, kKeySeqLength);
					kvmconf->escapeseq[kKeySeqLength-1] = 0;
				}else if(strcmp(key, "sunmodifier") == 0){
					strncpy(kvmconf->sunmodifier, value, kKeySeqLength);
					kvmconf->sunmodifier[kKeySeqLength-1] = 0;
				}else if(strcmp(key, "viewerport") == 0){
					strncpy(kvmconf->viewerport, value, kViewerPortLength);
					kvmconf->viewerport[kViewerPortLength-1] = 0;
				}

			}
#ifdef RDPenable
			else if(*p == 's' || *p == 'p' || *p == 'r')
#else
			else if(*p == 's' || *p == 'p')
#endif	//RDPenable
			{
				int n;
				char c, tmp[4];

				c = *p;
				q = tmp;
				p++;
				while(*p && isdigit(*p) && q < tmp+3) *(q++) = *(p++);
				*q = 0;
				if(*p != '.'){ fclose(fptr); return -1;}
				n = atoi(tmp);
				p++;
				if(!*p) { fclose(fptr); return -1;}

				if(get_kvmd_keyval(p, key, value) < 0)
					return -1;	
				if(c == 's'){
					/* kvm station conf */
					if((n < 0) || (n >= kMaxKVMStations+1)) {
						dolog("station # out of range: %d\n",n); 
						fclose(fptr); return -1;
					}

					if(strcmp(key, "idletimeout") == 0){
						kvmstationconf[n].idletimeout = atoi(value);
					}else if(strcmp(key, "screensavertime") == 0){
						kvmstationconf[n].screensavertime = atoi(value);
					}else if(strcmp(key, "cycletime") == 0){
						kvmstationconf[n].cycletime = atoi(value);
					}else if(strcmp(key, "kbdtype") == 0){
						kvmstationconf[n].kbdtype = get_kvmd_list(kbdtypelist, value);
					}else if(strcmp(key, "quitseq") == 0){
						strncpy(kvmstationconf[n].quitseq, value, kKeySeqLength);
						kvmstationconf[n].quitseq[kKeySeqLength-1] = 0;
					}else if(strcmp(key, "powerseq") == 0){
						strncpy(kvmstationconf[n].powerseq, value, kKeySeqLength);
						kvmstationconf[n].powerseq[kKeySeqLength-1] = 0;
					}else if(strcmp(key, "srvsyncseq") == 0){
						strncpy(kvmstationconf[n].srvsyncseq, value, kKeySeqLength);
						kvmstationconf[n].srvsyncseq[kKeySeqLength-1] = 0;
					}else if(strcmp(key, "videoconfseq") == 0){
						strncpy(kvmstationconf[n].videoconfseq, value, kKeySeqLength);
						kvmstationconf[n].videoconfseq[kKeySeqLength-1] = 0;
					}else if(strcmp(key, "switchnextseq") == 0){
						strncpy(kvmstationconf[n].switchnextseq, value, kKeySeqLength);
						kvmstationconf[n].switchnextseq[kKeySeqLength-1] = 0;
					}else if(strcmp(key, "switchprevseq") == 0){
						strncpy(kvmstationconf[n].switchprevseq, value, kKeySeqLength);
						kvmstationconf[n].switchprevseq[kKeySeqLength-1] = 0;
					}else if(strcmp(key, "portinfoseq") == 0){
						strncpy(kvmstationconf[n].portinfoseq, value, kKeySeqLength);
						kvmstationconf[n].portinfoseq[kKeySeqLength-1] = 0;
					}
				}
			}else{
				fclose(fptr); return -1;
			}
		}
		fclose(fptr);

		
		return 0;
	}
	return -1;
}

static
int set_kvmd_defaults(KVMGeneralConfig *kvmconf,
		KVMStationConfig *kvmstationconf)
{
	int i;

	memset(kvmconf, 0, sizeof(KVMGeneralConfig));
	memset(kvmstationconf, 0, sizeof(KVMStationConfig) * (kMaxKVMStations + 1));

	kvmconf->authtype = AUTH_LOCAL;
	kvmconf->facility = 3;
	strcpy(kvmconf->escapeseq, "[CTRL]K");
	strcpy(kvmconf->sunmodifier, "[WIN]");
	strcpy(kvmconf->viewerport, KVMIP_DEFAULT_VIEWER_PORT);

	for(i = 0; i < kMaxKVMStations+1; i++){
		kvmstationconf[i].idletimeout = 3;
		kvmstationconf[i].screensavertime = 10;
		kvmstationconf[i].cycletime = 5;
		kvmstationconf[i].kbdtype = 0;
		strcpy(kvmstationconf[i].quitseq, "q");
		strcpy(kvmstationconf[i].powerseq, "p");
		strcpy(kvmstationconf[i].srvsyncseq, "s");
		strcpy(kvmstationconf[i].videoconfseq, "v");
		strcpy(kvmstationconf[i].switchnextseq, ".");
		strcpy(kvmstationconf[i].switchprevseq, ",");
		strcpy(kvmstationconf[i].portinfoseq, "i");
	}

	return 0;
}	


static Result RdWrtKVMD(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
//	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	//to be used if necessary 
	KVMGeneralConfig *kvmconf = &((KVMDConfig *)(ParamList->value))->general;
	KVMStationConfig *kvmstationconf = ((KVMDConfig *)(ParamList->value))->stations;

	dolog("RdWrtKVMD kvmconf=%p\n", kvmconf);

	if(!rdWrtFlg){
		dolog("RdWrtKVMD 1\n");
		set_kvmd_defaults(kvmconf, kvmstationconf);
		read_kvmd_cfg(kvmconf, kvmstationconf);
	}else{
		dolog("RdWrtKVMD 2\n");
		write_kvmd_cfg(kvmconf, kvmstationconf);
		system("killall -HUP kvmd");
	}

	return kCycSuccess;
}

static void kvminitacclist(KVMUserPermConfig *puser)
{
	puser->defperm = 0;
	puser->nperms = 0;
}

static void
kvm_addperm(KVMUserPermConfig *puser, unsigned char *device, int port, int perm)
{
	if(puser->nperms >= puser->npermsalloc){
		return;
	}
	strncpy(puser->perms[puser->nperms].device, device, kCascNameLength-1);
	puser->perms[puser->nperms].device[kCascNameLength-1] = 0;
	puser->perms[puser->nperms].port = port;
	puser->perms[puser->nperms].value = perm;
	puser->nperms++;
}	


static void kvmreadacclist(KVMUserPermConfig *puser, FILE *fp, CycKey key)
{
	unsigned char *s, *t, buf[256], *a[3], device[kCascNameLength];
	int k, lineno, perm, port;

	lineno = 0;
	puser->nperms = 0;
	puser->defperm = 128;	//Christine Qiu: default permission is not define. 11/29/2005
	while(fgets(buf, sizeof(buf), fp)) {
		lineno ++;
		for (s = buf; *s && *s != '\r' && *s != '\n'; s ++);
		*s = 0;
		s = buf;
		k = 0;
		while (k < 3 && *s) {
			for (; isspace(*s); s++);
			a[k++] = s;
			for (; *s && ! isspace(*s); s ++);
			if (*s) {
				*s++ = 0;
			}
		}
		if (strcmp(a[0], "portaccess") == 0) {
			if (k < 3) {
				continue;
			}
			if (strcmp(a[1], "default") == 0) {
				port = 0;
			} else {
				if (key == kKVMPermEntries) {
					puser->nperms++;
					continue;
				}
				if ((t = strchr(a[1], '.')) != NULL) {
					strncpy(device, a[1], 
						kCascNameLength - 1);
					if (t - a[1] < kCascNameLength - 1) {
						*(device + (t - a[1])) = 0;
					}
					t ++;
				} else {
					device[0] = 0;
					t = a[1];
				}
				if (sscanf(t, "%d", &port) != 1) {
					continue;
				}
				if (port < 1 || port >= MAXKVMPORTS) {
					continue;
				}
			}
			perm = 0;
			if (strcmp(a[2], "none")) {
				t = s = a[2];
				while (t) {
					if ((t = strchr(s, '|')) != NULL) {
						*t = 0;
					}
					if (strcmp(s, "ro") == 0) {
						perm &= ~(PERM_WRITE);
						perm |= PERM_READ;
					} else if (strcmp(s, "rw") == 0) {
						perm |= PERM_READ | PERM_WRITE;
					} else if (strcmp(s, "pw") == 0) {
						perm |= PERM_POWER;
					} else {
						continue;
					}
					if (t != NULL) {
						s = t + 1;
					}
				}
			}
			if (port) {
				kvm_addperm(puser, device, port, perm);
			} else {
				puser->defperm = perm;

			}
		} else {
			continue;
		}
	}
}

static char *get_perm(int perm, unsigned char *buf)
{
	char flag = 0;
	if (perm & PERM_DEFAULT) {
		return NULL;
	}
	buf[0] = 0;
	if ((perm & (PERM_READ | PERM_WRITE | PERM_POWER)) == 0) {
		strcat(buf, "none");
		return buf;
	}
	if ((perm & (PERM_READ | PERM_WRITE)) == PERM_READ) {
		strcat(buf, "ro");
		flag = 1;
	} else if ((perm & (PERM_READ | PERM_WRITE)) == 
		(PERM_READ | PERM_WRITE)) {
		strcat(buf, "rw");
		flag = 1;
	}
	if (perm & PERM_POWER) {
		if (flag) {
			strcat(buf, "|");
		}
		strcat(buf, "pw");
		flag = 1;
	}
	return buf;
}


static void kvmwriteacclist(KVMUserPermConfig *puser, FILE *fp)
{
	char *s, buf[128];
	int k;
	if ((s = get_perm(puser->defperm, buf)) != NULL) {
		fprintf(fp, "portaccess default %s\n", s);
	}
	for (k = 0; k < puser->nperms; k ++) {
		if ((s = get_perm(puser->perms[k].value, buf)) != NULL) {
			if (puser->perms[k].device[0]) {
				fprintf(fp, "portaccess %s.%d %s\n",
					puser->perms[k].device, 
					puser->perms[k].port, s);
			} else {
				fprintf(fp, "portaccess %d %s\n",
					puser->perms[k].port, s);
			}
		}
	}
}

static Result RdWrtKVMAccList(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
	KVMUserAccessConfig *useracc = (KVMUserAccessConfig *)
		(ParamList->value);
	KVMUserPermConfig *puser;
	struct dirent **namelist;
	char *username, filename[128];
	int i, j, n, idx, group, userdefault;
	FILE *fp;

	/* to write configuration */

	if (rdWrtFlg) { /* write */
		/* remove all the files  */
		system ("rm -f /etc/kvm/* > /dev/null");
		//		system ("mkdir /etc/kvm");

		/* Write the default access list */
		fp = fopen("/etc/kvm/kvm.default", "w");
		kvmwriteacclist(&useracc->defuserperm, fp);
		fclose(fp);
		/* Write the user access lists in the table */
		for (j = 0; j < useracc->nacclists; j ++) {
			idx = (int)useracc->acclistList[j];
			if (idx == 0) {
				continue;
			}
			puser = &useracc->userperms[idx - 1];
// [LC]: Do not create the kvm user or group permission file if the user/group 
// does not exist in the local data base to avoid misconfiguration.
			{
				FileBuffer *buf = NULL;
				char *usrgrp = malloc(strlen(puser->name)+2);
				if (usrgrp == NULL) continue;

				strcpy(usrgrp, puser->name);
				strcat(usrgrp, ":");
				if (((buf = read_file((puser->usergroup)?
							GROUP_FILE:PASSWD_FILE)) == NULL) ||
					(search_var(buf, usrgrp, 0)) == NULL) {
					if (buf)
						free(buf);
					free(usrgrp);
					continue;
				}
				free(buf);
				free(usrgrp);
			}
			if (puser->usergroup) {
				sprintf(filename, "/etc/kvm/kvmgroup.%s", 
					puser->name);
			} else {
				sprintf(filename, "/etc/kvm/kvm.%s", 
					puser->name);
			}
			fp = fopen(filename, "w");
			kvmwriteacclist(puser, fp);
			fclose(fp);
		}
	} else {
		/* To read configuration */

		puser = &useracc->defuserperm;
		kvminitacclist(puser);
		idx = 0;
		if ((n = scandir ("/etc/kvm", &namelist, 0, alphasort)) > 0) {
			for (i = 0; i < n; i ++) {
				userdefault = 0;
				if (strncmp(namelist[i]->d_name, "kvm.", 4) == 
					0) {
					group = 0;
					username = namelist[i]->d_name + 4;
					if (strcmp(username, "default") == 0) {
						userdefault = 1;
					}
				} else if (strncmp(namelist[i]->d_name, 
					"kvmgroup.", 9) == 0) {
					group = 1;
					username = namelist[i]->d_name + 9;
				} else {
					continue;
				}
				sprintf(filename, "/etc/kvm/%s", 
					namelist[i]->d_name);
				if (ParamList->key == kKVMAccEntries) {
					if (!userdefault) {
						idx ++;
						if (idx == kMaxAccLists) {
							break;
						}
					}
					continue;
				} else if (userdefault) {
					puser = &useracc->defuserperm;
				} else {
					puser = &(useracc->userperms[idx]);
				}
				strncpy(puser->name, username, kUserNameLength);
				puser->usergroup = group;
				kvminitacclist(puser);
				fp = fopen(filename, "r");
				if (fp == NULL) {
					continue;
				}
				kvmreadacclist(puser, fp, ParamList->key);
				fclose(fp);
				if (!userdefault) {
					if (ParamList->key == kKVMAccList) {
						useracc->acclistList[idx] = idx + 1;
					}
					idx ++;
					if (idx == kMaxAccLists) {
						break;
					}
				}
			}
			if (ParamList->key == kKVMAccEntries) {
				useracc->nacclists = idx;
			}
			for (i = 0; i < n; i ++) {
				free(namelist[i]);
			}
			free(namelist);
		}
	}
	return (kCycSuccess);
}
/**
 * kvm_read_cycling_file - This function reads a cycling
 * configuration file for a user (which is a list of systems that
 * user will cycle through) and returns a list of systems.
 */ 
int kvm_read_cycling_file(char * pathname, char list[][kSystemNameLength])
{
	FILE *fp;
	char linebuf[64];
	char * nameptr,		/* pointer to system name */
	     * eolptr;		/* pointer to End-Of-Line */
	int n = 0;		/* number of systems to cycle through */

	if ((fp = fopen(pathname, "r")) == NULL) {
		printf("Could not open cycling file %s: %s\n", pathname, strerror(errno));
		return -1;
	}

	while (fgets(linebuf, sizeof(linebuf), fp) != NULL) {
		/* skip over leading blanks (if any) */
		for (nameptr = linebuf; isspace(*nameptr); nameptr++)
		    ;
		/* if its a blank line, skip it */
		if (*nameptr == '\0')
			continue;

		eolptr = strchr(nameptr, '\n');
		*eolptr = '\0';

		if (strlen(nameptr) > 30) {
			printf("system name is longer than 30 characters: %s\n", linebuf);
			return -2;
		}

		strcpy(list[n++], nameptr);
	}

	fclose(fp);

	return n;
}

/**
 * kvm_write_cycling_file - This function takes a list of systems
 * to cycle through and writes them in a text file; one name per line.
 * Returns 0 on succes,; A negative integer on failure 
 */ 
int kvm_write_cycling_file(char * pathname, char list[][kSystemNameLength], int n)
{
	FILE *fp;
	int i;
	
	if (n == 0) {
//		printf("Removing cycling file: %s\n", pathname);
		unlink(pathname);
		return 0;
	}

	if ((fp = fopen(pathname, "w")) == NULL) {
		printf("Could not open file %s for writing: %s\n", pathname, strerror(errno));
		return -1;
	}

	for (i = 0; i < n; i++) {
		fprintf(fp, "%s\n", list[i]);
	}

	fclose(fp);

	return 0;
}

int selectcyclingfile(const struct dirent * entry)
{
    if (strchr(entry->d_name, '.') != NULL)
	return 0;
    
    return 1;    
}

static Result RdWrtKVMCyclingList(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
	KVMCyclingConfig * cfg = (KVMCyclingConfig *) (ParamList->value);
	char filename[128];
	int i, n;
	struct dirent ** namelist;

//	printf("RdWrtKVMCyclingList(rdWrtFlg=%d)\n", rdWrtFlg);

	if (rdWrtFlg) {		/* to write configuration */
		/* remove all the files  */
		system ("rm -f /etc/kvm/cycle/* > /dev/null");

		/* Write the user cycling lists in the table */
		for (i = 0; i < cfg->nCyclingAlloc; i++) {
			if (!cfg->userscycling[i].active)
				continue;
			//printf("Writing cycling configuration for user %s\n", cfg->userscycling[i].username);

			sprintf(filename, "/etc/kvm/cycle/%s", cfg->userscycling[i].username);

			kvm_write_cycling_file(filename, cfg->userscycling[i].cycling_list, cfg->userscycling[i].nSystems);
		}
	} else {	/* To read configuration */
		if ((n = scandir ("/etc/kvm/cycle/", &namelist, selectcyclingfile, alphasort)) > 0) {
			if (ParamList->key == kKVMCyclingEntries) {
				cfg->nCyclingLists = MIN(n, kMaxAccLists);
				//printf("number of cycling files: %d\n", cfg->nCyclingLists);
				return kCycSuccess;
			}
		    
			for (i = 0; i < cfg->nCyclingLists; i++) {
				strncpy(cfg->userscycling[i].username, namelist[i]->d_name, kUserNameLength);

				sprintf(filename, "/etc/kvm/cycle/%s", namelist[i]->d_name);
				cfg->userscycling[i].nSystems = kvm_read_cycling_file(filename, cfg->userscycling[i].cycling_list);
				cfg->userscycling[i].active = 1;
			}

			for (i = 0; i < n; i ++) {
				free(namelist[i]);
			}
			free(namelist);
		}
	}
	return (kCycSuccess);
}

/*
 * When a group is deleted, an access file may be left over
 *  for that group. This function takes csare of that.
 */
static void clearout_groups_accesslist(CycParam *paramList)
{
	DIR *dir;
	int i;

	dir = opendir("/etc/kvm/");
	if (dir) {
		struct dirent *dentry;
		while( (dentry = readdir(dir)) != NULL ){
			char *p;

			p = dentry->d_name + strlen(dentry->d_name);

			if (strncmp(dentry->d_name, "kvmgroup", 8) != 0)
				continue;

			while ((p >= dentry->d_name) && (*p != '.')) p--;
			if (*p == '.'){
				ConfGroups *pGroup = (ConfGroups *)paramList->value;

				p++;
				/* p now points to grp name */
				for (i = 0; i < paramList->collectionSize; i++, pGroup++){
					if(strcmp(p, pGroup->newGrpName) == 0)
						break;
				}
				if (i >= paramList->collectionSize){ /* not found */
					char fname[256];
					snprintf(fname, 255, "/etc/kvm/%s", dentry->d_name);
					unlink(fname);
				}
			}
		}
		closedir(dir);
	}
}

//========================================================================
// ParseGroupsEntry - Parse each line in the /etc/groups file
//========================================================================
static void *ParseKVMGroupsEntry (unsigned char *s, CycParam *paramList, 
	void *ptr)
{
	/* this function has two purposes:
		- get the number of entries, indicated by pGroup = 0. We
		increment paramList->value for each valid entry.
		- read the entries, and put data into structure pointed
		to by pGroup
	*/
	ConfGroups * pGroup = (ConfGroups *)ptr;
	ConfGroups group;	
	unsigned char *p, *q, buf[256];
	int gid;

	memset(&group, 0, sizeof(ConfGroups));

	/* get group name */
	p = s; q = buf;
	while(*p && *p != ':' && (q < buf+255)) *q++ = *p++;
	if(!*p) return NULL;
	*q = 0; p++;
	strncpy(group.newGrpName, buf, kGroupNameLength);

	/* skip password: */
	while(*p && *p != ':') p++;
	if(!*p) return NULL;
	p++;

	/* get gid: */
	q = buf;
	while(*p && *p != ':' && (q < buf+255)) *q++ = *p++;
	if(!*p) return NULL;
	*q = 0; p++;
	gid = atoi(buf);	

	/* get users: */
	if(gid >= 1000){
		q = buf;
		while(*p && (*p != '\n') && (q < buf+255)) *q++ = *p++;
		*q = 0;
		strncpy(group.usersInGrp, buf, kListLength);

		if (pGroup != NULL)
		{
			dolog("Set current pGroup to the host gotten and increment pGroup");
			// !!! error check to see if param value has exceeded space allocated
			if (((ConfGroups *)paramList->value + paramList->collectionSize) == pGroup)
			{
				dolog("Error: Exceeded number of possible entries. Should exit.");
			}
			*pGroup++ = group;
		} else {
			(*(int *)paramList->value)++;
			dolog("Increment num of entries: %d", *(int *)paramList->value);
		}
		return pGroup;
	}
	return pGroup;
}

//========================================================================
// WriteKVMGroupsEntry - Write a User Group entry. 
//========================================================================
static Result WriteKVMGroupsEntry (unsigned char *filename, CycParam *paramList)
{
	ConfGroups *pGroup = (ConfGroups *)paramList->value;
	int i;
	FILE *fin = NULL, *fout = NULL;
	char tmpname[256];
	char buf[256], line[256];
	char *p, *q;

	snprintf(tmpname, 255, "%s-", filename);

	if((fin = fopen(filename, "r")) && (fout = fopen(tmpname, "w"))){

		while(fgets(line, 255, fin)){
			int gid;
			/* entries in /etc/group with gid < 1000 are not our
			business. Copy entries. We parse each line until we
			know its gid. If that is < 1000, we copy the whole line. */

			/* get group name */
			p = line; q = buf;
			while(*p && *p != ':' && (q < buf+255)) *q++ = *p++;
			if(!*p) return kFileReadError;
			*q = 0; p++;

			/* skip password: */
			while(*p && *p != ':') p++;
			if(!*p) return kFileReadError;
			p++;

			/* get gid: */
			q = buf;
			while(*p && *p != ':' && (q < buf+255)) *q++ = *p++;
			if(!*p) return kFileReadError;
			*q = 0; p++;
			gid = atoi(buf);	

			if(gid < 1000)
				fputs(line, fout);
		}
		/* now the entries from the list: */
		for (i = 0; i < paramList->collectionSize; i++, pGroup++) {
			/* seems that sometimes we get an empty grp name.
			   We fix that here, and btw also trim leading
			   and trailing spaces. */
			p = pGroup->newGrpName; q = buf;
			while(*p && isspace(*p)) p++;
			while(*p && !isspace(*p) && q < buf+255) *q++ = *p++;
			*q = 0;
			if(buf[0] != 0){
				/* FIXME: we should remember the gid. */
				fprintf(fout, "%s:x:%d:%s\n",
					buf, i+1000, pGroup->usersInGrp);
			}
		}
		fclose(fin);
		fclose(fout);
		rename(tmpname, filename);

		clearout_groups_accesslist(paramList);

	}else{
		if(fin) fclose(fin);
		if(fout) fclose(fout);
		return kFileWriteError;
	}
	return kCycSuccess;
}

//========================================================================
// KVM uC reset and microcode update functions
//========================================================================

/* Function to create command to control uC related actions
 * Return is done using variable command...
 */
static void CreateKVMuCCommand(KVMMicrocode *uCInfo,
			       unsigned char *port,
			       unsigned char *filename,
			       unsigned char *command)
{
	unsigned char buffer[64] = "";
	unsigned char action[32];

#ifdef OEM3
	unsigned char rp1str[] = "ce1";
	unsigned char rp2str[] = "ce2";
	unsigned char termstr[] = "srvmod";
#else
	unsigned char rp1str[] = "rp1";
	unsigned char rp2str[] = "rp2";
	unsigned char termstr[] = "term";
#endif

	/* Setting actions properly */
	if (uCInfo->action == 0)
		sprintf(action, "reset");
	else if (uCInfo->action == 1) {
		sprintf(action, "upload");
		/* Creating whole file name plus '-f' key*/
		snprintf(buffer, 63, "-f /tmp/%s", filename);
		buffer[63] = 0;
	} else
		return;

	/* Actual command creation */
	switch (uCInfo->targetType) {
 	case 0:	// Terminator
		snprintf(command, 249, "/bin/kvm %s -t %s -p %s %s",action, termstr,
			port, buffer);
 		break;
 	case 1: // Switch (command for all 3 internal KVM/Net uCs at once)
		if (port) {
			snprintf(command, 249, "/bin/kvm %s -t switch -r -s %s %s", 
						action, port, buffer);
		} else {
			snprintf(command, 249, "/bin/kvm %s -t switch %s", action, buffer);
		}
 		break;
 	case 2: // RP main
		snprintf(command, 249, "/bin/kvm %s -t %s -s 2 %s",
			action, rp1str, buffer);
 		break;
 	case 3: // RP local
		snprintf(command, 249, "/bin/kvm %s -t %s -s 2 %s",
			action, rp2str, buffer);
		break;
 	case 4:	// PEM
		snprintf(command, 249, "/bin/kvm %s -t pem -p %s %s",action,
			port, buffer);
 		break;
	case 5: // IP daughter cards
		if (!uCInfo->action) //reset
			snprintf(command, 249, "/bin/vcard_reboot.exp");
		else //upload
			snprintf(command, 249, "/bin/vcard_upgrade.exp /tmp/%s", filename);
 	}
	command[249] = 0;
}


/* Function to control uC related actions like uC resets
 * and microcode updates.
 */
static void ControlKVMuC(KVMMicrocode *uCInfo,
	unsigned char *filename, error_vector *pkvmPortVector, 
	error_vector *pkvmErrVector)
{
 	int ret; // Variable to catch reset return (error) code
	unsigned char command[250] = {0};
	unsigned char *port = NULL;
	int entry;

	// Initialize everything to NULL
	memset(pkvmErrVector, 0, sizeof(error_vector));
	memset(pkvmPortVector, 0, sizeof(error_vector));

	// If target type is switch, send command for each possible uC
	if (uCInfo->targetType == 1) {
		unsigned char *st, station[3] = {0};
		int ix, numstations, shift;

		if ((mt.board_type == BOARD_KVMP16) || 
			(mt.board_type == BOARD_KVMP32)) {
			numstations = 4;
			shift = 2;
		} else {
			numstations = 2;
			shift = 0;
		}

		entry = 0;
		for (ix = 0; ix <= numstations; ix++) {
			if (ix)	{
				snprintf(station, 2, "%d", ix + shift);
				st = station;
			} else {
				st = NULL;
			}
			CreateKVMuCCommand(uCInfo, st, filename, command);
			if (command[0]) {
				ret = WEXITSTATUS(system(command));
			} else {
				ret = errInconsistentRequest;
			}
			// Insert error code returned into kvmErrVector
			if (ret) {
				ret = (ret>=100)?(ret-100):ret;
				ret = (ret < 0 || ret >= kvmErrMessages_max)?
						kvmErrMessages_unknown:ret;

				(*pkvmErrVector)[entry] = kvmErrMessages[ret];
				dolog("Message: %s, cod %d\n",  kvmErrMessages[ret], ret);
				entry ++;
				if (entry == uCNumErrors - 1) {
					(*pkvmErrVector)[entry] = "Too many errors. Aborting transfer.";
					break;
				}
			}
		}
		return; // Return error vector
	}

	// If target type is not terminator, send command and grab error code
        if (uCInfo->targetType != 0 && uCInfo->targetType != 4) {
                // Create command for switch, RP main/local and VCMs
                CreateKVMuCCommand(uCInfo, port, filename, command);
                // Call command and get error code into 'ret'
				if (command[0]) {
//					ret = errInconsistentRequest;
					ret = WEXITSTATUS(system(command));
				}
				else
					ret = errInconsistentRequest;
                // Insert error code returned into kvmErrVector
				if (ret) {
					ret = (ret>=100)?(ret-100):ret;
					ret = (ret < 0 || ret >= kvmErrMessages_max)?kvmErrMessages_unknown:ret;
					(*pkvmErrVector)[0] = kvmErrMessages[ret];
				}
				return; // Return error vector
        }

	port = uCInfo->targetPort; // Referencing string through a pointer
				   // to make things more comfortable

	// Running through all port numbers on port number list
	entry = 0;
	while(*port) {
		char *nextport;
		
		nextport = strchr(port, ' ');     // Find separator
		*nextport = '\0';         // Prepare port number
		nextport++;               // Point to the next port number
		// Create command only for the current port number
		CreateKVMuCCommand(uCInfo, port, filename, command);
		// Call command and get error code into 'ret'
		if (command[0])
//				{
//					ret = errInconsistentRequest;
//				}
			ret = WEXITSTATUS(system(command)); // Command call
		else
			ret = errInconsistentRequest;
		// Create error vector (error codes start from 100)
		dolog("\n**********\n%s, ret %d\n**********\n", command, ret);
		if (ret) {
			(*pkvmPortVector)[entry] = port;
			ret = (ret>=100)?(ret-100):ret;
			ret = (ret < 0 || ret >= kvmErrMessages_max)?kvmErrMessages_unknown:ret;
			(*pkvmErrVector)[entry] = kvmErrMessages[ret];
			dolog("Message: %s, cod %d\n",  kvmErrMessages[ret], ret);
			entry ++;
			if (entry == uCNumErrors - 1) {
				(*pkvmErrVector)[entry] = "Too many errors. Aborting transfer.";
				break;
			}
		}
		// Throw used port number away
		port = nextport;
	}

 	return;
}


/* KVM Microcontroller Reset */
void ResetKVMuC(KVMMicrocode *uCInfo, error_vector *pkvmPortVector, 
	error_vector *pkvmErrVector)
{
 	ControlKVMuC(uCInfo, NULL, pkvmPortVector, pkvmErrVector); // We don't need a file name when doing reset
}

//========================================================================
// FTP down/upload auxiliary functions
//========================================================================

/* Function to create file to control ftp file transfer */
static void CreateFtpControlFile(char *ControlFileName,
				 ftpInfo ftpData, ftpAction action,
				 ftpMode mode) {
	FILE *ControlFile;
	unsigned char file[32];
	
	ControlFile = fopen(ControlFileName, "w"); // Open file
	sprintf(file, "/tmp/%s", ftpData.filename);
	
	/* Creating control file of ftp file transfer process */
	ControlFile = fopen("/tmp/ftp.tmp", "w");
	fprintf(ControlFile, "user %s %s\n" "bin\n",
		ftpData.username, ftpData.password); // login and transfer mode
	if (*ftpData.directory) 
		fprintf(ControlFile, "cd %s\n", ftpData.directory); // change into dir
	fprintf(ControlFile, "hash\n"); // activate hash down/upload meter

	/* FTP mode handling */
        switch (mode) {
	case NORMAL: // Normal mode is the default
		break;
	case PASSIVE: // Changing into passive mode
		fprintf(ControlFile,"passive\n");
	}
	
	/* Specifying down/upload in control file */
	switch (action) {
	case DOWNLOAD:
		fprintf(ControlFile, "get %s %s\n" "exit\n",
			ftpData.filename, file); // get file & exit
		break;	
	case UPLOAD:
		fprintf(ControlFile, "put %s\n" "exit\n",
			ftpData.filename); // get file & exit
	}
	
	fclose(ControlFile); // Close control file
}


/* Function to call ftp command */
static void FtpCall(char *buffer, char *ftpserver,
		    char *ControlFileName, char *LogFileName) {
	snprintf(buffer, 1023, "ftp -nv %s <%s >%s", ftpserver,
		 ControlFileName, LogFileName); // Building ftp command
	system(buffer); // System call using ftp command
}

/* Function to control whole ftp process */
static void FtpControl(ftpInfo ftpData, ftpAction action) {
	unsigned char buffer[1024];
	unsigned char ControlFileName[32] = "/tmp/ftp.tmp";
	unsigned char LogFileName[32] = "/tmp/ftp.log";
	unsigned char file[32];
	FILE *TransferredFile;
	
	CreateFtpControlFile(ControlFileName, ftpData, action, NORMAL);
	FtpCall(buffer, ftpData.ftpserver, ControlFileName,LogFileName);	

	/* Checking whether we had download problems */
	if(action == DOWNLOAD) {
		snprintf(file, 31, "/tmp/%s", ftpData.filename);
		file[31] = 0;
		TransferredFile = fopen(file, "r");
		if (TransferredFile == NULL) { // Try passive mode
			CreateFtpControlFile(ControlFileName, ftpData,
					     action, PASSIVE);
			FtpCall(buffer, ftpData.ftpserver, ControlFileName,
				LogFileName);	
		}
		else fclose(TransferredFile); // Close file if check is OK
	}
	
	unlink("/tmp/ftp.tmp"); // deleting ftp control file
}

/* KVM Microcontroller Firmware Update Function
 * Here we download the firmware via FTP using the set
 * of FTP functions and call the function to upload the
 * firmware into the respective uC
 */
void UpdateKVMuC(KVMMicrocode *uCInfo, error_vector *pkvmPortVector, 
	error_vector *pkvmErrVector)
{
	struct stat st;
	unsigned char file[32];

	// Download microcode from ftp server
	FtpControl(uCInfo->ftpData, DOWNLOAD);

	snprintf(file, 31, "/tmp/%s", uCInfo->ftpData.filename);
	file[31] = 0;
	if (stat(file, &st)) {
		memset(pkvmErrVector, 0, sizeof(error_vector));
		(*pkvmErrVector)[0] = "Download error. File not available to update device.";
		//printf("Update Error Vector: %s\n", pkvmErrVector);
		return;
	}

	// Upload firmware into uC
	ControlKVMuC(uCInfo, uCInfo->ftpData.filename, pkvmPortVector, 
		pkvmErrVector);

	//printf("Update Error Vector: %s\n", pkvmErrVector);
	return;
}

//========================================================================
#endif // KVM

//========================================================================
// RdWrtShellVar:
//  Reading and writing shell variables in a shell script file. The
//  parameter ptr->name has the name of the shell variable.
//========================================================================
static Result RdWrtShellVar(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FileBuffer *buf;
	char *line;
	char val[BUF_CUSHION1];
	int flgIns;

	dolog("RdWrtShellVar()");

	if (!rdWrtFlg) {
		*(int *)ParamList->value = 0;
	}

	if ((buf = read_file(pCkIndex->fileName)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		return (kFileReadError);
	}

	if ((line = search_var(buf, pCkIndex->name, 0)) == NULL) {
		if (rdWrtFlg) {
			flgIns = 0;
			if ((line = search_var(buf, "DPARM", 0)) == NULL) {
				line = buf->buf;
				flgIns=1;
			}
			build_default_line(val, pCkIndex,ParamList);
			insert_line(line, buf, val, flgIns);
		}
	} else {
		if (rdWrtFlg) {
			get_val_from_param(val,pCkIndex,ParamList);
			replace_Value(line, buf, val,0);
		} else {
			get_value_from_line(line, buf, pCkIndex,ParamList);
		}
	}

	if (rdWrtFlg) {
		executeFlg |= EXE_DAEMON_SH;
		write_file(buf, pCkIndex->fileName);
	}

	free(buf);
	return (kCycSuccess);
}

//========================================================================
// RdWrtWebUiShell:
//  Enabling/disabling HTTP and HTTPS
//  Define ports to HTTP and HTTPS
//  Enabling/disabling redirect
//  Define SSL version
//========================================================================
static Result RdWrtWebUiShell(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
        CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

        dolog("RdWrtWebUiShell()");

        //Write value of web inside of config file
        if(!rdWrtFlg){
                if(GetWebValues(pCkIndex->fileName, ParamList))
                        return (kCannotAccess);
        }else {
                if(SetWebValues(pCkIndex->fileName, ParamList))
                        return (kCannotSet);
        }

        return (kCycSuccess);
}

//========================================================================
// RdWrtSshShell:
//  Enabling/disabling HTTP and HTTPS
//  Define ports to HTTP and HTTPS
//  Enabling/disabling redirect
//  Define SSL version
//========================================================================
static Result RdWrtSshShell(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
        CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

        dolog("RdWrtSshShell()");

        //Write value of web inside of config file
        if(!rdWrtFlg){
                if(GetSshValues(pCkIndex->fileName, ParamList))
                        return (kCannotAccess);
        }else {
                if(SetSshValues(pCkIndex->fileName, ParamList))
                        return (kCannotSet);
        }

        return (kCycSuccess);
}
		
//========================================================================
// RdWrtListEntries - Read/Write files with several entries such as 
// /etc/hosts 
//========================================================================
static Result RdWrtListEntries(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	Result result = kCycSuccess;

	if (rdWrtFlg)
	{
	  result = (*(pCkIndex->write))(pCkIndex->fileName, paramList); 
	}
	else 
	{
		result = ReadEntries(pCkIndex, paramList, 0);
	}
	return (result);
}

//========================================================================
// RdWrtDateTime - Read/Set system date and time
//========================================================================
static Result RdWrtDateTime(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	FILE *fp;
	unsigned char buffer[256];
	DateTime dt = {0}, *pDt;

	if (rdWrtFlg)
	{
		pDt = (DateTime *)paramList->value;
		sprintf(buffer, "date %02d%02d%02d%02d%04d.%02d >/tmp/webtemp", 
		pDt->month, pDt->day, pDt->hour, pDt->min, pDt->year, pDt->sec);
		//dolog("DateTime Buffer: %s", buffer);
		system(buffer);
		cy_shm->web_date_set = time(NULL);
		fp = fopen("/tmp/webtemp", "r");
		fgets(buffer+strlen(buffer), 256-strlen(buffer), fp);
		fclose(fp);
		dolog("DateTime Result: %s", buffer);
		strcpy(pDt->sysMsg, buffer);
		system("rm -f /tmp/webtemp");
	}
	else
	{
		system("date > /tmp/timedate");
		fp = fopen("/tmp/timedate", "r");
		fscanf(fp, "%s %s %d %d:%d:%d %s %d",
			   (buffer+4), buffer, &dt.day, &dt.hour, &dt.min, &dt.sec, dt.tzacronym, &dt.year);
		fclose(fp);
		switch (buffer[0]+buffer[1]+buffer[2]) {
		case ('J'+'a'+'n'): dt.month = 1; break;
		case ('F'+'e'+'b'): dt.month = 2; break;
		case ('M'+'a'+'r'): dt.month = 3; break;
		case ('A'+'p'+'r'): dt.month = 4; break;
		case ('M'+'a'+'y'): dt.month = 5; break;
		case ('J'+'u'+'n'): dt.month = 6; break;
		case ('J'+'u'+'l'): dt.month = 7; break;
		case ('A'+'u'+'g'): dt.month = 8; break;
		case ('S'+'e'+'p'): dt.month = 9; break;
		case ('O'+'c'+'t'): dt.month = 10; break;
		case ('N'+'o'+'v'): dt.month = 11; break;
		case ('D'+'e'+'c'): dt.month = 12; break;
		}
		memcpy(paramList->value, &dt, sizeof(dt));
		system("rm -f /tmp/timedate");
	}
	
	return (kCycSuccess);
}

//========================================================================
// RdWrtTimezone - Read/Set/Apply customized timezone parameters
//========================================================================
static Result RdWrtTimezone(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	FILE *fp;
	unsigned char buffer[120] = {0};
	TimezoneData tz = {{0}}, *tzp = (TimezoneData *)&(((TimeDate *)(paramList->value))->tz);
    CycCatKeyTable mytableline = {0, 0, ((CycCatKeyTable *)ptr)->fileName, NULL, NULL, NULL, NULL,
								  ((CycCatKeyTable *)ptr)->name, ((CycCatKeyTable *)ptr)->type, 0, NULL, 0, 0};
    CycParam myparam = {0, 0, buffer, 0, 0, 0};
	char months[] = "Jan\0Feb\0Mar\0Apr\0May\0Jun\0Jul\0Aug\0Sep\0Oct\0Nov\0Dec";
	Result result;

	if (rdWrtFlg)
	{
		if (strcmp(((TimeDate *)(paramList->value))->timezone, "Custom")) { //not Custom

			strcpy(buffer+50, ((TimeDate *)(paramList->value))->timezone+3);
			sprintf(buffer, "GMT%s", buffer+50);

			//just prepare struct for localtime compilationn
			strcpy(tzp->acronym, buffer);
			tzp->GMToff.hour = (buffer+50) ? atoi(buffer+50) : 0;
			tzp->GMToff.min = 0;
			tzp->DSTactive = 0;
			tzp->DSTstartDate.month = 1;
			tzp->DSTstartDate.day = 1;
			tzp->DSTstartTime.hour = 0;
			tzp->DSTstartTime.min = 0;
			tzp->DSTendDate.month = 1;
			tzp->DSTendDate.day = 1;
			tzp->DSTendTime.hour = 0;
			tzp->DSTendTime.min = 0;

		} else {

			sprintf(buffer,"%s:%s:%d:%d:%d:%s:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
					tzp->zlabel,
					tzp->acronym,
					tzp->GMToff.hour,
					tzp->GMToff.min,
					tzp->DSTactive,
					tzp->DSTacronym,
					tzp->DSTsave.hour,
					tzp->DSTsave.min,
					tzp->DSTstartDate.month,
					tzp->DSTstartDate.day,
					tzp->DSTstartTime.hour,
					tzp->DSTstartTime.min,
					tzp->DSTendDate.month,
					tzp->DSTendDate.day,
					tzp->DSTendTime.hour,
					tzp->DSTendTime.min);

			//write TZPARAMS to ntpclient.conf
			if ((result = RdWrtShellVar(&mytableline, &myparam, 1)) != kCycSuccess)
				return result;

		}
		mytableline.name = "TIMEZONE";
		mytableline.type = TYPE_STRVAR;
		myparam.value = ((TimeDate *)(paramList->value))->timezone;
		//write TIMEZONE to ntpclient.conf
		if ((result = RdWrtShellVar(&mytableline, &myparam, 1)) != kCycSuccess)
			return result;

		//prepares tzsource to compile
		if ((fp = fopen("/tmp/tzsource", "w"))) {
			sprintf(buffer, "Rule CycladesTZ minimum maximum - %s %d %d:%d %d:%d -\n",
					months + (tzp->DSTstartDate.month-1)*4,
					tzp->DSTstartDate.day,
					tzp->DSTstartTime.hour,
					tzp->DSTstartTime.min,
					(tzp->DSTactive ? tzp->DSTsave.hour : 0),
					(tzp->DSTactive ? tzp->DSTsave.min : 0));
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "Rule CycladesTZ minimum maximum - %s %d %d:%d 0 -\n",
					months + (tzp->DSTendDate.month-1)*4,
					tzp->DSTendDate.day,
					tzp->DSTendTime.hour,
					tzp->DSTendTime.min);
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "Zone newlocaltime %d:%d CycladesTZ %s/%s\n",
					tzp->GMToff.hour,
					tzp->GMToff.min,
					tzp->acronym,
					(tzp->DSTactive ? tzp->DSTacronym : tzp->acronym));
			fwrite(buffer, strlen(buffer), 1, fp);
			fclose(fp);
        } else
			return kCannotSet;

		//compiles tzsource
		if (system("/usr/sbin/zic -d /tmp /tmp/tzsource"))
			return kCannotSet;

		//install and clean up
		if ((fp = fopen("/tmp/tzsource", "w"))) {
			sprintf(buffer, "mv /tmp/newlocaltime /etc/localtime\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "sed \"s/TZ=.*/unset TZ/\" /etc/profile > /tmp/profile\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "rm -f /etc/TIMEZONE > /dev/null 2>&1\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "grep -v TIMEZONE /etc/config_files > /tmp/config_files 2>&1\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "grep \"/etc/localtime\" /etc/config_files > /dev/null 2>&1 || echo \"/etc/localtime\" >> /tmp/config_files\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "grep \"/etc/profile\" /etc/config_files > /dev/null 2>&1 || echo \"/etc/profile\" >> /tmp/config_files\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			sprintf(buffer, "mv /tmp/config_files /tmp/profile /etc; rm -f /tmp/tzsource\n");
			fwrite(buffer, strlen(buffer), 1, fp);
			fclose(fp);
			chmod("/tmp/tzsource", 0777);
		} else
			return kCannotSet;

		system("/tmp/tzsource");

		//unset TZ (environment variable...)
		if (unsetenv("TZ"))
			return kCannotSet;

		return result;
	}
	else
	{
		if ((result = RdWrtShellVar(&mytableline, &myparam, 0)) != kCycSuccess)
			return result;

		sscanf(buffer, "%15[^:]%*[:]%6[^:]%*[:]%d:%d:%d:%6[^:]%*[:]%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
			   tz.zlabel,
			   tz.acronym,
			   &tz.GMToff.hour,
			   &tz.GMToff.min,
			   &tz.DSTactive,
			   tz.DSTacronym,
			   &tz.DSTsave.hour,
			   &tz.DSTsave.min,
			   &tz.DSTstartDate.month,
			   &tz.DSTstartDate.day,
			   &tz.DSTstartTime.hour,
			   &tz.DSTstartTime.min,
			   &tz.DSTendDate.month,
			   &tz.DSTendDate.day,
			   &tz.DSTendTime.hour,
			   &tz.DSTendTime.min);

		memcpy(&(((TimeDate *)(paramList->value))->tz), &tz, sizeof(tz));
	}
	
	return (kCycSuccess);
}

//========================================================================
// CheckSpeedConsole - Match up the speed configured with the one in
// /etc/getty_ttyS0
//========================================================================
static void CheckSpeedConsole(int consoleSpeed)
{
  FILE *fp;
  int fileSpeed = 0;
        int speedList[] = {4800, 9600, 19200, 38400, 57600, 115200};

  if ((fp = fopen("/etc/getty_ttyS0", "r")) != NULL) {
    fscanf(fp, "%d", &fileSpeed);
  }

  if (speedList[consoleSpeed] != fileSpeed) {
    fp = freopen("/etc/getty_ttyS0", "w+", fp);
    fprintf(fp, "%d", speedList[consoleSpeed]);
  }
  fclose(fp);
}

#ifdef UBOOT_PARAM
static int TransOptGetValue(HASH_LIST *h, char *str)
{
   for( ; h->name!=NULL; h++) {
      if (!strcmp(h->name, str)) {
         return(h->value);
      }
   }

   return(-1);
}

char* TransOptGetString(HASH_LIST *h, int value)
{
   for( ; h->name!=NULL; h++) {
      if (h->value == value) {
         return(h->name);
      }
   }

   return(-1);
}

char seek_val(int flag_seek, char val, char *op)
{
        char *p = op;

        while (*p != 0xff) {
                if (p[flag_seek] == val) {
                        op = p;
                        break;
                }
                p+=2;
        }
        return(flag_seek ? op[0] : op[1]);
}

int GetSetUBootConfiguration(char *buf, int rw)
{
        int     fd, count, ret = 1;
        int flags = rw ? O_WRONLY : O_RDONLY;

        if ((fd = open(BOOT_CONF_FILE, flags)) == -1)
                return (0);

        if (rw) {
                count = write(fd, buf, FLASH_BLOCK);
        } else {
                count = read(fd, buf, FLASH_BLOCK);
        }

        if (count != FLASH_BLOCK) {
                ret = 0;
        }

        close(fd);
        return (ret);
}

void TokenizeUBootConfiguration(char *env)
{
        char str[1024];
        char *p;
        int i = 0;
        while(*env) {
                strcpy(str, env);
                p = NULL;
                p = strtok(str, "=");
                i = TransOptGetValue(CmdValList, p);
                if (i == -1) {//handle error
                }
                else {
                        if(NameValList[i].name != NULL) {
                                free(NameValList[i].name);
                        }
                        if((NameValList[i].name = (char*)malloc((strlen(p)+ 1)* sizeof(char))) == NULL) 
			{
				LogError("Boot configuration failed. Unable to allocate memory.");			
			        return;
			}
                        else {
                                strcpy(NameValList[i].name, p);
                                p = strtok(NULL, "=");
                                if(NameValList[i].value != NULL) {
                                        free(NameValList[i].value);
                                }

                                if((NameValList[i].value = (char*)malloc((strlen(p)+ 1)* sizeof(char))) == NULL)
				{
					LogError("Boot configuration failed. Unable to allocate memory.");							        return;
				}
                                else {
                                        strcpy(NameValList[i].value, p);
                                }
                        }
                }
                env += strlen(env) + 1;
        }
}

void CheckUBootConfig() 
{
	int i = 0;
        for( i = 0; i < NUM_VARIABLES; i ++) {
                if(NameValList[i].name == NULL) {
                        if((NameValList[i].name = malloc((strlen(NameValListDefault[i].name)+ 1)
                                * sizeof(char))) == NULL)
			{
 				LogError("Boot configuration failed. Unable to allocate memory.");                                                              return;
			}
                        else
                                strcpy(NameValList[i].name, NameValListDefault[i].name);

                }
                if(NameValList[i].value == NULL) {
                        if((NameValList[i].value = malloc((strlen(NameValListDefault[i].value)+ 1)
                                * sizeof(char))) == NULL)
			{
 				LogError("Boot configuration failed. Unable to allocate memory.");                                                              return;
			}
                        else
                                strcpy(NameValList[i].value, NameValListDefault[i].value);

                }
        }
}
//========================================================================
// SaveUBootConf - Save the boot configuration into appropriate structure
//========================================================================
static void SaveUBootConf(CycParam *paramList)
{
        BootConf *bconf = (BootConf *)paramList->value;
        int ivalue, value;
        char displayChar;
        FileBuffer *buf;
		char *p;

        strncpy(bconf->ipAddr, NameValList[IPADDR].value, strlen(NameValList[IPADDR].value));
        dolog("BootConf IP: [%s]\n", bconf->ipAddr);

        displayChar = TransOptGetValue(WdtList, NameValList[WDT].value);
        ivalue = seek_val(0, displayChar, wdt_op);
        bconf->wdTimer = ivalue;

        displayChar = TransOptGetValue(BootcmdList, NameValList[BOOTCMD].value);
        ivalue = seek_val(0, displayChar, boot_op);
        bconf->uBoot = ivalue;

        strncpy(bconf->bootFilename,NameValList[BOOTFILE].value, strlen(NameValList[BOOTFILE].value));
        strncpy(bconf->serverIpAddr, NameValList[SERVERIP].value, strlen(NameValList[SERVERIP].value));

        ivalue = TransOptGetValue(BaudrateList, NameValList[BAUDRATE].value);
        bconf->speed = ivalue;

        value = TransOptGetValue(FecmodeList, NameValList[FECMODE].value);
        ivalue = seek_val(0, (char)value, mii_op);
        bconf->fastEthernet = ivalue;

        bconf->maxEvent = atoi(NameValList[MAXINT].value);
        bconf->currentImage = *NameValList[CURR_IMG].value;

		system("/bin/get_image_names");
		strcpy(bconf->image1Filename, "image1:none");
		strcpy(bconf->image2Filename, "image2:none");
		if ((buf = read_file("/tmp/image_files")) == NULL) {
			return;
		}
		p = strtok(buf->buf, "\r\n"); 
		if (p) strcpy(bconf->image1Filename, p);
		p = strtok(NULL, "\r\n"); 
		if (p) strcpy(bconf->image2Filename, p);
		free(buf);
}

//========================================================================
// WriteUBootConf - Obtain the boot configuration and stores it into the
// appropriate structure and save it to flash
//========================================================================
static Result WriteUBootConf(CycParam *paramList)
{
        int writeErr, retValue;
        BootConf *pBootConf;
        char *p;
        char temp[32];
	int c;
        HASH_LIST *hashList;

        pBootConf = (BootConf *)paramList->value;

        GetSetUBootConfiguration(om_buf, 0);
        p = cyc_set_env_ptr(om_buf + sizeof(om_buf));
        TokenizeUBootConfiguration(p);

        if (*(pBootConf->ipAddr))
        {
                strcpy(NameValList[IPADDR].value, pBootConf->ipAddr);
        }
        else
        {
                LogError("Boot configuration failed. Missing IP address");
                return (kMissingIpAddress);
        }

	c = seek_val(1, (char)pBootConf->wdTimer, wdt_op);
        strcpy(NameValList[WDT].value, TransOptGetString(WdtList, c));

    *NameValList[CURR_IMG].value = pBootConf->currentImage;

	c = seek_val(1, (char)pBootConf->uBoot, boot_op);
        strcpy(NameValList[BOOTCMD].value, TransOptGetString(BootcmdList, c));

	if(NameValList[BOOTFILE].value != NULL) {
		free(NameValList[BOOTFILE].value);
	}
	if((NameValList[BOOTFILE].value = malloc((strlen(pBootConf->bootFilename)+ 1)
		* sizeof(char))) == NULL) {
		LogError("Boot configuration failed. Unable to allocate memory.");
		return(kCannotWriteToFlash);
	}
	else
		strcpy(NameValList[BOOTFILE].value, pBootConf->bootFilename);

        if (*(pBootConf->serverIpAddr))
        {
                strcpy(NameValList[SERVERIP].value, pBootConf->serverIpAddr);
        }
	else
        {
                LogError("Boot configuration failed. Missing server IP address");
                return (kMissingIpAddress);
        }
	
        strcpy(NameValList[BAUDRATE].value, TransOptGetString(BaudrateList, pBootConf->speed));

	c = seek_val(1, (char)pBootConf->fastEthernet, mii_op);
        strcpy(NameValList[FECMODE].value, TransOptGetString(FecmodeList, c));

        sprintf(temp, "%d", pBootConf->maxEvent);
        strcpy(NameValList[MAXINT].value, temp);

        //Write from structure to buffer file
        hashList = &CmdValList;
        for( ; hashList->name!=NULL; hashList++) {
                retValue = cyc_setenv(NameValList[hashList->value].name, NameValList[hashList->value].value);
                if(retValue != 0) {
                        LogError("Boot configuration could not be written to flash.");
                        return (kCannotWriteToFlash);
                }
        }

        // Save configuration in flash
        writeErr = GetSetUBootConfiguration(om_buf, 1);

        // Check Console Speed in /etc/getty_ttyS0
        CheckSpeedConsole(TransOptGetValue(BaudrateList, NameValList[BAUDRATE].value));

        if (writeErr == 0) {
                LogError("Boot configuration could not be written to flash.");
                return (kCannotWriteToFlash);
        }
        return (kCycSuccess);
}

//========================================================================
// SetDefaultConfig - Sets default UBoot Configuration
//========================================================================
static void SetDefaultConfig() 
{
	int i;
	for( i = 0; i < NUM_VARIABLES; i++) {
		if(NameValList[i].name != NULL) {
                                free(NameValList[i].name);
                }
                if((NameValList[i].name = (char*)malloc((
		strlen(NameValListDefault[i].name)+ 1)* sizeof(char))) == NULL)
		{
			 LogError("Boot configuration failed. Unable to allocate memory.");                                                              return;
                }        
		else
			strcpy(NameValList[i].name, NameValListDefault[i].name);			

		if(NameValList[i].value != NULL) {
                                free(NameValList[i].value);
                }
                if((NameValList[i].value = (char*)malloc((
                strlen(NameValListDefault[i].value)+ 1)* sizeof(char))) == NULL)
		{
			 LogError("Boot configuration failed. Unable to allocate memory.");                                                              return;
		}
                else
                        strcpy(NameValList[i].value, NameValListDefault[i].value);

	}	
}

//========================================================================
// RdWrtBootConf - Read/Write UBootConf
//========================================================================
static Result RdWrtBootConf(void *ptr, CycParam *paramList, int rdWrtFlg)
{
        char *p;
        int readErr, writeErr;
        Result result = kCycSuccess;

        dolog("RdWrtBootConf()");

        if (rdWrtFlg)
        {
                result = WriteUBootConf(paramList);
        }
        else
        {
                readErr = GetSetUBootConfiguration(om_buf, 0);
		if (readErr == 0) {
                        LogError("Boot configuration could not be read from flash.");
			 SetDefaultConfig();
                }
	        p = cyc_set_env_ptr(om_buf + sizeof(om_buf));
		if(cyc_check_crc()) {
               		TokenizeUBootConfiguration(p);
			CheckUBootConfig();	
		}
		else {
			cyc_set_default_env(NameValListDefault);
	               	writeErr = GetSetUBootConfiguration(om_buf, 1);
			 if (writeErr == 0) {
		                LogError("Boot configuration could not be written to flash.");
                		return (kCannotWriteToFlash);
		        }

                	TokenizeUBootConfiguration(p);
			CheckUBootConfig();	
		}
                SaveUBootConf(paramList);
        }
        return (result);
}

#else // NOT ONS
//========================================================================
// CalculateCrc - Calculate the crc
//========================================================================
static unsigned short CalculateCrc(unsigned long byte_n, unsigned short crc, char *buffer)
{
  int j;

  while (byte_n--) {
    crc = (((crc >> 8) ^ *buffer++) << 8) | (0xFF & crc) ;
    for(j = 0; j < 8; j++) {
      if (crc & 0x8000)  {
        crc <<= 1;
        crc ^= 0x1021;
      } else {
        crc <<= 1;
      }
    }
  }
  return(crc);
}

//========================================================================
// AccessType - Get type of flash?
//========================================================================
static char *AccessType(char *buf, int type)
{
  FLASH_CONFIG_VECTOR_HEADER  *p = (FLASH_CONFIG_VECTOR_HEADER *)buf;

  while (p->type != 9999) {
    FLASH_CONFIG_VECTOR_HEADER  *p = (FLASH_CONFIG_VECTOR_HEADER *)buf;
    if (p->type == 9999) {
      break;
    }
    if (p->crc != CalculateCrc(p->size, 0, p->data)) {
      break;
    }
    if (p->type == type) {
      return(p->data);
    }
    buf += p->size + 6;
  }
  return(NULL);
}

//========================================================================
// GetBootConfiguration - Read in the boot configuration 
//========================================================================
static int GetBootConfiguration(struct HW_SETUP *hwsetup, struct BOOT_MASK *boot_mask)
{
  unsigned char *buffer, *s1, *s2, *s3;
  int fd, ret=0;

  memset((unsigned char *)hwsetup, 0, sizeof(struct HW_SETUP));
  memset((unsigned char *)boot_mask, 0, sizeof(struct BOOT_MASK));
  if ((buffer = malloc(FLASH_BLOCK)) != NULL) {
    if ((fd = open(BOOT_CONF_FILE, O_RDONLY|O_CREAT)) != -1) {
      if (read(fd, buffer, FLASH_BLOCK)>0) {
        if ((s1 = AccessType(buffer, TYPE0000)) != NULL &&
          (s2 = AccessType(buffer, TYPE0068)) != NULL &&
          (s3 = AccessType(buffer, TYPE0015)) != NULL) {

          memcpy((unsigned char *)hwsetup, s2, sizeof(struct HW_SETUP));
          memcpy((unsigned char *)boot_mask, s3, sizeof(struct BOOT_MASK));
          ret = 1;
        }
      }
      close(fd);
    }
    free(buffer);
  }
  return ret;
}

//========================================================================
// SetDefaultConfig - Set boot configuration to defaults 
//========================================================================
static void SetDefaultConfig(struct HW_SETUP *hw_setup, struct BOOT_MASK *boot_mask)
{
  unsigned char macaddr[6];
	unsigned char def_hwmac[6] = {0x00, 0x60, 0x2e, 0x00, 0x00, 0x01};
	unsigned char def_ethip[4] = {192, 162, 160,10};
	unsigned char def_srvip[4] = {192, 162, 160,1};

  if (memcmp(def_hwmac, hw_setup->physical_addr, 3)) {
    memcpy(macaddr, def_hwmac, 6);
  } else {
    memcpy(macaddr, hw_setup->physical_addr, 6);
  }

  memset(hw_setup, 0, sizeof(struct HW_SETUP));
  memcpy(hw_setup->physical_addr, macaddr, 6);
  *(unsigned long *)hw_setup->itf_ip_addr = *(unsigned long *)def_ethip;
    hw_setup->enable_wdt = 1;
  hw_setup->console_speed = 1;
  hw_setup->op_code_crc = 1;
  hw_setup->mem_test = 2;
  hw_setup->boot_option = 0;
  strcpy(hw_setup->tftp_path, DEFAULT_TFTP_PATH);

  memset(boot_mask, 0, sizeof(struct BOOT_MASK));
  boot_mask->boot_type = 2;
  *(unsigned long *)boot_mask->bootserver = *(unsigned long *)def_srvip;
}

//========================================================================
// SaveBootConf - Save the boot configuration into appropriate structure 
//========================================================================
static void SaveBootConf(CycParam *paramList, struct HW_SETUP *hw_setup, struct BOOT_MASK *boot_mask)
{
	BootConf bconf = {{0}};

	strcpy(bconf.ipAddr, inet_ntoa(*(struct in_addr *) hw_setup->itf_ip_addr));
	dolog("BootConf IP: [%s]\n", bconf.ipAddr);
	bconf.wdTimer = hw_setup->enable_wdt;
	bconf.uBoot = hw_setup->boot_option;
	bconf.bType = boot_mask->boot_type;
	strcpy(bconf.bootFilename, hw_setup->tftp_path);
	strcpy(bconf.serverIpAddr, inet_ntoa(*(struct in_addr *) boot_mask->bootserver));
	bconf.speed = hw_setup->console_speed;
	bconf.flashTest = hw_setup->op_code_crc;
  bconf.ramTest = hw_setup->mem_test;
  bconf.fastEthernet = hw_setup->mii_operation;
  bconf.maxEvent = hw_setup->max_int_work; 
	
	memcpy(paramList->value, &bconf, sizeof(bconf));
}

//========================================================================
// SetBootConfiguration - saves the boot configuration into flash
//========================================================================
static int SetBootConfiguration(struct HW_SETUP *hw_setup, struct BOOT_MASK *boot_mask)
{
  unsigned char *buffer, *s;
  FLASH_CONFIG_VECTOR_HEADER  *v;
  int ret = 0, fd;
  if ((buffer = malloc(FLASH_BLOCK)) != NULL) {
    s = buffer;

    // TYPE0000
    v = (FLASH_CONFIG_VECTOR_HEADER *)s;
    v->type = TYPE0000;
    v->size = sizeof(struct type0000);
    memset(v->data, 0, v->size);
    strcpy(v->data, "CYCLADES");
    v->crc = CalculateCrc(v->size, 0, v->data);
    s += 6 + v->size;

    // TYPE0068
    v = (FLASH_CONFIG_VECTOR_HEADER *)s;
    v->type = TYPE0068;
    v->size = sizeof(struct HW_SETUP);
    memcpy(v->data, (unsigned char *)hw_setup, v->size);
    v->crc = CalculateCrc(v->size, 0, v->data);
    s += 6 + v->size;

    // TYPE0015
    v = (FLASH_CONFIG_VECTOR_HEADER *)s;
    v->type = TYPE0015;
    v->size = sizeof(struct BOOT_MASK);
    memcpy(v->data, (unsigned char *)boot_mask, v->size);
    v->crc = CalculateCrc(v->size, 0, v->data);
    s += 6 + v->size;

    v = (FLASH_CONFIG_VECTOR_HEADER *)s;
    v->type = 9999;
    v->size = 0;
    v->crc = 0;
    s += 6 + v->size;

    if ((fd = open(BOOT_CONF_FILE, O_WRONLY|O_CREAT)) != -1) {
      if (write(fd, buffer, s-buffer)==s-buffer) {
        ret = 1;
      }
      close(fd);
    }
    free(buffer);
  }
  return ret;
}

//========================================================================
// WriteBootConf - Obtain the boot configuration and stores it into the
// appropriate structure and save it to flash
//========================================================================
static Result WriteBootConf(CycParam *paramList)
{
  int writeErr;
	struct HW_SETUP hw_setup;
  struct BOOT_MASK boot_mask;
	BootConf *pBootConf;

	pBootConf = (BootConf *)paramList->value;

	GetBootConfiguration(&hw_setup, &boot_mask);
	if (*(pBootConf->ipAddr))
	{
		inet_aton(pBootConf->ipAddr, (struct in_addr *)(hw_setup.itf_ip_addr));
	}
	else 
	{
		LogError("Boot configuration failed. Missing IP address");
		return (kMissingIpAddress);	
	}

	hw_setup.enable_wdt = pBootConf->wdTimer;
	hw_setup.boot_option = pBootConf->uBoot;
	boot_mask.boot_type = pBootConf->bType;
	strncpy(hw_setup.tftp_path, pBootConf->bootFilename, PATH_LEN-1);
	hw_setup.tftp_path[PATH_LEN-1] = 0;
	if (*(pBootConf->ipAddr))
	{
		inet_aton(pBootConf->serverIpAddr, (struct in_addr *)(boot_mask.bootserver));
	}
	else
	{
		LogError("Boot configuration failed. Missing server IP address");
		return (kMissingIpAddress);	
	}
	hw_setup.console_speed = pBootConf->speed;
	hw_setup.op_code_crc = pBootConf->flashTest;
	hw_setup.mem_test = pBootConf->ramTest;
	hw_setup.mii_operation = pBootConf->fastEthernet;
	hw_setup.max_int_work = pBootConf->maxEvent;

	/*if (readerr) {
		ShowBootPage(wp, &hw_setup, &boot_mask, 0, readerr);
		return;
	} */

	// Save configuration in flash 

	writeErr = (SetBootConfiguration(&hw_setup, &boot_mask));
	// Check Console Speed in /etc/getty_ttyS0 
	CheckSpeedConsole(hw_setup.console_speed);

	if (writeErr == 0) {
		LogError("Boot configuration could not be written to flash.");
		return (kCannotWriteToFlash);
	} 
	return (kCycSuccess);
}

//========================================================================
// RdWrtBootConf - Read/Write BootConf
//========================================================================
static Result RdWrtBootConf(void *ptr, CycParam *paramList, int rdWrtFlg)
{
        struct HW_SETUP hw_setup;
        struct BOOT_MASK boot_mask;
        int flash_ok;
        Result result = kCycSuccess;

        dolog("RdWrtBootConf()");

        if (rdWrtFlg)
        {
                result = WriteBootConf(paramList);
        }
        else
        {
                flash_ok = GetBootConfiguration(&hw_setup, &boot_mask);
                if (!flash_ok)
                {
                        SetDefaultConfig(&hw_setup, &boot_mask);
                }
                SaveBootConf(paramList, &hw_setup, &boot_mask);
        }
        return (result);
}
#endif

//========================================================================
// RdWrtIpSecEntries - Read/Write Ipsec entries
//========================================================================
static Result RdWrtIpSecEntries(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	Result result = kCycSuccess;

	if (rdWrtFlg)
	{
		result = (*(pCkIndex->write))(pCkIndex->fileName, paramList); 
		result = WriteIpSecSecret(paramList);
		executeFlg |= EXE_DAEMON_SH; //mp: Bug Fix 1852
		system("rm -Rf /var/run/.ipsec.sh.tmp"); //mp: Bug Fix 1852
	} 
	else
	{
		result = ReadIpSecEntries(pCkIndex, paramList, 0);
	}
	return (result);
}

//========================================================================
// RdWrtIpSecRSA - Read/Write Ipsec srecrets RSA pub key
//========================================================================
static Result RdWrtIpSecRSA(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	Result result = kCycSuccess;
	struct stat st;
	FILE *fp;
	unsigned char *buf, *s, *v;

// Only read available. RSA key created by script (ipsec.init).
// Only one RSA key created. In the future should be extended for one RSA 
// key per connection.
	if (!rdWrtFlg)
	{
		if (stat(IPSEC_SECRET_FILE, &st)) return (kFileReadError);

		fp = fopen (IPSEC_SECRET_FILE, "r");
		if (!fp) return (kFileReadError);

		buf= (unsigned char *)malloc(st.st_size+1);
		if (!buf) return (kMemAllocationFailure);

		s = buf;
		memset(paramList->value, 0, kRsaKeyLength);
		while(fgets(s, st.st_size, fp)) {
			if ((v = strstr(s, "#pubkey="))) {
				int len = strlen(v) - 8 - 1; // string - "#pubkey=" - \n (EOL)
				if (len >= kRsaKeyLength) {
					syslog(LOG_INFO,"IPSEC RSA pubkey too long: %d\n", len);
				} else {
					strncpy(paramList->value, v+8, len);
				}
				break;
			}
		}
		fclose(fp);
		free(buf);
	}
	return (result);
}

//========================================================================
// RdWrtSysInfoSnmpdConf - Read/Set snmpd conf
//========================================================================
static Result RdWrtSysInfoSnmpdConf(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	FILE *fp;
	unsigned char *a, *buf, *s, *t, *w, *k;
	int found; 
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	dolog("RdWrtSysInfoSnmpdConf()");

	// Read the file snmpd.conf and writes it to the buffer 
	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	// Open the file to begin writing
	if (rdWrtFlg)
	{
		if ((fp = fopen(pCkIndex->fileName, "w")) == NULL)
		{
			LogError(FILE_READ_ERROR, pCkIndex->fileName);
			free(buf);
			return (kFileReadError);
		}
	}

	t = s = buf;

	while (*s) 
	{
		found = 0;
		while (*s && *s!='\n') s++;
		if (*s) *s++=0;

		//Parse and get word, command, argument
		switch (ParseLineSnmpd(t, &w, &a)) 
		{
			case 1:
				k=w;
        if (*w == '#') w++;
				//dolog("W: %s, A: %s", w, a);
				if (!strcmp(w, pCkIndex->name)) 
				{
					if (rdWrtFlg)
					{
						dolog("FOUND Printing: %s  %s", w, (char *)paramList->value);
						fprintf(fp, "%s %s\n", w, (char *)paramList->value);
						found = 1;
					}
					else
					{
						strcpy((char *)paramList->value, a);
					}
				}
				// Print out if current line doesn't match what 
				// we are looking for. 
				if (!found && rdWrtFlg)
				{
					dolog("Printing if not found: %s  %s", w, a);
					fprintf(fp, "%s %s\n", k, a);
				}
				t = s;
				break;

			default:
				if (rdWrtFlg)
				{
					dolog("Printing default %s", t);
					fprintf(fp, "%s\n", t);
				}
				t = s;
				break;

		} // end of switch
	} // end of main while

	if (rdWrtFlg) {
		fclose(fp);
		executeFlg |= EXE_DAEMON_SH;
	}

	free(buf);

	return (kCycSuccess);
}

//========================================================================
// RdWrtConfigSnmpdConf - Read/Write snmpd configurations
//========================================================================
static Result RdWrtConfigSnmpdConf(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	FILE *fp, *fp2;
	unsigned char *a, *buf, *s, *t, *w, *k;
	unsigned char *rwcommunity = "rwcommunity";
	unsigned char *rocommunity = "rocommunity";
	unsigned char *rwuser = "rwuser";
	unsigned char *rouser = "rouser";
	unsigned char currLine[400] = {0};
	int found, entry=0, flgv12; 
	void *p=NULL;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;

	dolog("RdWrtConfigSnmpdConf()");

	// Read the file snmpd.conf and writes it to the buffer 
	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	// Open the file to begin writing
	if (rdWrtFlg)
	{
		if ((fp = fopen(pCkIndex->fileName, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			free(buf);
			return (kFileWriteError);
		}
		if (pCkIndex->key == kSnmpv3Info)
		{
			if ((fp2 = fopen(SNMPD_LOCAL_FILE, "w")) == NULL)
			{
				LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
				return (kFileWriteError);
			}
		}
	}

	if ((pCkIndex->key == kNumCommunityEntries) || 
	    (pCkIndex->key == kCommunityInfo)) {
		flgv12 = 1; // SNMP v1 or v2
	} else {
		flgv12 = 0; // SNMP v3
	}
	
	if (pCkIndex->key == kCommunityInfo || 
		pCkIndex->key == kSnmpv3Info)
	{
		p = paramList->value;
	}

	t = s = buf;

	while (*s) 
	{
		found = 0;
		while (*s && *s!='\n') s++;
		if (*s) *s++=0;
		strcpy(currLine, t);
		//Parse and get word, command, argument
		switch (ParseLineSnmpd(t, &w, &a)) 
		{
			case 1:
				k=w;
        			if (*w == '#') w++;
				//dolog("W: %s, A: %s", w, a);
				if (flgv12 && 
				    (!strcmp(w, rwcommunity) || !strcmp(w, rocommunity))) {
					if (pCkIndex->key == kNumCommunityEntries) { 
						(*(int *)paramList->value)++;
					} else {
						if (!rdWrtFlg && (entry < paramList->collectionSize)) {
							p = (*(pCkIndex->parser))(currLine, paramList, p);
							entry++;
						}
					}
					t = s;
					break;
				}
				if (!flgv12 && (!strcmp(w, rwuser) || !strcmp(w, rouser))) {
					if (pCkIndex->key == kNumSnmpv3Entries) {
						(*(int *)paramList->value)++;
					} else {
						if (!rdWrtFlg && (entry < paramList->collectionSize)) {
							p = (*(pCkIndex->parser))(currLine, paramList, p); 
							entry++;
						}
					}
					t = s;
					break;
				}
				// Print out if current line doesn't match what 
				// we are looking for. 
				if (rdWrtFlg) {
					fprintf(fp, "%s %s\n", k, a);
				}
				t = s;
				break;

			default:
				if (rdWrtFlg) {
					fprintf(fp, "%s\n", t);
				}
				t = s;
				break;
		} // end of switch
	} // end of main while

	// Print out remaining configurations
	if (rdWrtFlg)
	{
		Snmpv3Info *pv3;
		CommunityInfo *pv2;

		if (flgv12) {
			pv2 = (CommunityInfo *)(paramList->value);
		} else {
			pv3 = (Snmpv3Info *) (paramList->value);
		}
		
		for (entry = 0; entry < paramList->collectionSize; entry++) {
			if (flgv12) {
				WriteCommunityInfo(fp, paramList, pv2);
				pv2++;
			} else {
				WriteSnmpv3Info(fp, fp2, paramList, pv3);
				pv3++;
			}
		}
		fclose(fp);
		if (pCkIndex->key == kSnmpv3Info)
			fclose(fp2);
		executeFlg |= EXE_DAEMON_SH;
	}

	free(buf);

	return (kCycSuccess);
}

//========================================================================
// ReadWriteNisDomainName - Read or write the Nis domain name
//========================================================================
Result ReadWriteNisDomainName(NisInfo *pNis, int rdWrtFlg)
{
  FILE *fp;
  char domainName[kDomainNameLength];
	unsigned char *s;

	if (rdWrtFlg)
	{
    if ((fp = fopen(DOMAINNAME_CONF_FILE, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, DOMAINNAME_CONF_FILE);
			return (kFileWriteError);
		}
    fprintf(fp,"%s", pNis->domainName);
	}
	else
	{
    if ((fp = fopen(DOMAINNAME_CONF_FILE, "r")) == NULL)
		{
			LogError(FILE_READ_ERROR, DOMAINNAME_CONF_FILE);
			return (kFileReadError);
		}
	memset(domainName,0,sizeof(domainName));
	if (fgets(domainName, sizeof(domainName), fp) != NULL) {
		s = domainName;
		while (*s && !isspace(*s)) s++;
		*s=0;
	}
	strcpy(pNis->domainName, domainName);
    //dolog("RdWrtNisDomainName(): DomainName: [%s]", pNis->domainName);
	}
	fclose(fp);

	return(kCycSuccess);
}

//========================================================================
// WriteNisServer - Writes the Nis server to /etc/yp.conf. If a specific
// server is configured, than always write that out. 
//========================================================================
Result WriteNisServer(NisInfo *pNis, int ipServer)
{
  FILE *fp;

  if ((fp = fopen(YP_CONF_FILE, "w")) == NULL)
	{
		LogError(FILE_WRITE_ERROR, YP_CONF_FILE);
		return (kFileWriteError);
	}

	if (ipServer)
	{
    fprintf(fp,"ypserver %s", pNis->serverIp);
	}
	else
	{
		if (*(pNis->domainName))
		{
			fprintf(fp,"domain %s broadcast", pNis->domainName);
		}
	}
	fclose(fp);

	return(kCycSuccess);
}

//========================================================================
// ReadNisServer - Reads the Nis server ip. If not found, then if
// domain line is set, then return ip as broadcast
//========================================================================
Result ReadNisServer(NisInfo *pNis)
{
  FILE *fp;
	unsigned char buffer[100];
	unsigned char *s, *a;

	memset(pNis->serverIp, 0, kIpLength);

	if ((fp = fopen(YP_CONF_FILE, "r")) == NULL)
	{
		LogError(FILE_READ_ERROR, YP_CONF_FILE);
		return (kFileReadError);
	}

	while (fgets(buffer, sizeof(buffer), fp))
	{
		a = s = buffer; 
		while (isspace(*s)) s++;
		a = s;
		while(*s && !isspace(*s)) s++;
		if (*s) *s++=0;
		while(*s && isspace(*s)) s++;
		if (!strncmp(a, "ypserver", 8))
		{
			strcpy(pNis->serverIp, s);
		}
//		else
//		{
//			strncpy(pNis->serverIp, "broadcast", 9);
//		}
	}
  fclose(fp);
	
	return(kCycSuccess);	
}
//========================================================================
// ReadWriteNisAuthType - Function that reads or writes the Nis auth
// type
//========================================================================
static Result ReadWriteNisAuthType(int *pauthType, int rdWrtFlg)
{
	FILE *fp;
  unsigned char *a, *buf, *s, *t, *w;
  int type=0;
  int foundPasswd=0, foundShadow=0, foundGroup=0,found=0;

	dolog("ReadWriteNisAuthType");

	if ((buf = ReadFile(NSSWITCH_CONF_FILE, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, NSSWITCH_CONF_FILE);	
		return(kFileReadError);
	}

	if (rdWrtFlg)
	{
		if ((fp = fopen(NSSWITCH_CONF_FILE, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, NSSWITCH_CONF_FILE);
			free(buf);
			return (kFileWriteError);
		}
	}

	t = s = buf;

	while (*s)
  {
    while (*s && *s!='\n') s++;
    if (*s) *s++=0;

    //Parse and get word, argument
    switch (ParseLineNis(t, &w, &a))
    {
      case 1:
		//dolog("Word: [%s], Rest of the line: [%s]", w, a);
				if (!strcmp(w, "passwd"))
				{
					if (rdWrtFlg)
					{
						fprintf(fp, "%s:    %s\n", w, TransOptGetStr(NisAuthOptions, SIZE_NisAuthOptions, *pauthType)); 
						foundPasswd = 1;
					}
					else
					{
						if ((type = DetermineNisType(a)) != -1)
						{
							*pauthType = type;	
							//dolog("Type found: %d", pNis->authType);
						}
					}
					found = 1;
				}
				if (!strcmp(w, "shadow") && rdWrtFlg)
				{
			 		fprintf(fp, "%s:    %s\n", w, TransOptGetStr(NisAuthOptions, SIZE_NisAuthOptions, *pauthType));
					found = foundShadow = 1;
				}
				if (!strcmp(w, "group") && rdWrtFlg)
				{
					fprintf(fp, "%s:    %s\n", w, TransOptGetStr(NisAuthOptions, SIZE_NisAuthOptions, *pauthType));
					found = foundGroup = 1;
				}

				if (!found && rdWrtFlg)
				{
					fprintf(fp,"%s: %s\n",w,a);
				}
				found = 0;
				t = s;
        break;

      default:
        if (rdWrtFlg)
        {
          fprintf(fp, "%s\n", t);
        }
        t = s;
        break;
		} // end of switch
	}
	
	if (rdWrtFlg)
	{
		if (!foundPasswd)
			fprintf(fp, "passwd:    %s\n", TransOptGetStr(NisAuthOptions, SIZE_NisAuthOptions, *pauthType));
		if (!foundShadow)
			fprintf(fp, "shadow:    %s\n", TransOptGetStr(NisAuthOptions, SIZE_NisAuthOptions, *pauthType));
		if (!foundGroup)
			fprintf(fp, "group:    %s\n", TransOptGetStr(NisAuthOptions, SIZE_NisAuthOptions, *pauthType));
		fclose(fp);
	}

	free(buf);

	return (kCycSuccess);
}


//========================================================================
// RdWrtNisConfiguration - Read/Write Nis configuration
//========================================================================
static Result RdWrtNisConfiguration(void *ptr, CycParam *paramList, int rdWrtFlg) 
{
	int ipServer = 0;
	NisInfo *pNis;

  dolog("RdWrtNisConfiguration()");

	pNis = (NisInfo *)paramList->value;

	ReadWriteNisDomainName(pNis, rdWrtFlg);

  if (rdWrtFlg)
  {
		if (*(pNis->serverIp) && strncmp(pNis->serverIp, "broadcast", 9))
		{
			ipServer = 1;
		}
		WriteNisServer(pNis, ipServer);
/*
        ReadWriteNisAuthType(&pNis->authType, rdWrtFlg);
        if (pNis->authType == kNatLocalOnly) {
            ServiceActive(NIS_SHELL,"ENABLE",kNo,rdWrtFlg);
        } else {
            ServiceActive(NIS_SHELL,"ENABLE",kYes,rdWrtFlg);
        }
		executeFlg |= EXE_DAEMON_SH;
*/
#if defined(KVM) || defined(ONS)
		executeFlg |= EXE_SIGHUP_KVM;
#endif
  }
  else
  {
		ReadNisServer(pNis);
//		ReadWriteNisAuthType(&pNis->authType, rdWrtFlg);
  }

	/* return success even though any of the above 
		functions may have failed. Any failure is logged. */
  return (kCycSuccess);
}


//=======================================================================
// Syslog-ng Routines
//=======================================================================

//==============================================================================
// ParseSyslogServerEntry - Parse a remote syslog server entry.
// The syntax of remote syslog server entry line is :
// 	destination dremserverN { udp("<RemoteServerName>" port(514)); };
//==============================================================================
static void *ParseSyslogServerEntry(unsigned char *s,  CycParam *paramList, void *p)
{
	int ServerId;

	if (sscanf(s,"destination dremserver%d",&ServerId)) {
		(*(int *)paramList->value)++;
		dolog("Increment num of entries: %d", *(int *)paramList->value);
	}
	return (0);
}

/*
 * SyslogServerPos : it finds the register in SyslogServerInfo array
 * that has field ServerId equal the parameter ServerId. 
 * Return the pointer to register or NULL when array is full.
 */
static SyslogServerInfo * SyslogServerPos(SyslogServerInfo *array,
		int ServerId, int max_entries)
{
	SyslogServerInfo *entry = array;
	int i;

	for (i=0; i < max_entries ; i++, entry++) {
		if (entry->ServerId == ServerId) {
			dolog("SyslogServerPos found");
			return entry;
		}
	}
	dolog("SyslogServerPos return NULL");
	return NULL;
}

static void WriteSyslogServerEntries(FILE *fp, unsigned char *conf, 
				SyslogServerInfo *entries, int num_entries)
{
	int ServerId, j, last_ServerId;
	unsigned char *inl, *s, *sl;
	SyslogServerInfo *info;

	dolog("WriteSyslogServerEntries num_entries=%d",num_entries);

	last_ServerId = 0;
	inl= s = conf;
	while (*s) {
		
		while (*s && isspace(*s)) s++;
		if (*s == 0x0A) {
			s++;
			continue;
		}
		inl = s;
		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			fwrite(inl, (s-inl)+1,1,fp);
			if (*s) s++;
			continue;
		}
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s) return;
		*s++ = 0x00;

		if (sscanf(sl,"destination dremserver%d",&ServerId)) {
			info = SyslogServerPos(entries,ServerId,num_entries);
			if (info) {
				if (info->action == kEdit) {
					fprintf(fp,"destination dremserver%d { udp(\"%s\" port(514)); };\n",
						info->ServerId,info->SyslogServer);
					if (last_ServerId < info->ServerId)
						last_ServerId = info->ServerId;
				}
				if (info->action) {
					while (*s && *s!='\n') s++;
					if (*s) s++;  
					continue;
				}
			} 
			if (last_ServerId < ServerId)
				last_ServerId = ServerId;			
		}

		*(s-1) = 0x7d;
		while (*s && *s!='\n') s++;
		fwrite(inl, (s-inl)+1,1,fp);
		
		if (*s) s++;  // s pointer to next register
	}

	// add new entries
	for (j=0, info=entries; j < num_entries; j++, info++) {
		if ((info->action == kAdd) && !info->ServerId) {
			info->ServerId = ++last_ServerId;
			fprintf(fp,"destination dremserver%d { udp(\"%s\" port(514)); };\n",
				info->ServerId,info->SyslogServer);
		}			
	}
}

static void ReadSyslogServerEntries(unsigned char *conf, SyslogServerInfo *entries, int max_entries)
{
	int ServerId, numserver=0;
	unsigned char *s, *sl, ServerName[kServerLength];
	SyslogServerInfo *info = entries;
	
	dolog("ReadSyslogServerEntries max_entries=%d",max_entries);
	
	s=conf;
	while (*s) {
		while (*s && isspace(*s)) s++;

		if (*s == 0x0A) {
			s++;
			continue;
		}

		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			if (*s) s++;
			continue;
		}
		
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s) return;
		*s++ = 0x00; // end of one register in syslog-ng.conf
		if (sscanf(sl, "destination dremserver%d { udp(\"%s\"",
			&ServerId,ServerName)) {
			dolog("read Id[%d] Server[%s]",ServerId,ServerName);
			info->ServerId = ServerId;
			ServerName[strlen(ServerName)-1]=0x00;
			strcpy(info->SyslogServer,ServerName);
			info->action = kNone;
			info++;
			numserver++;
			if (numserver > max_entries) return;
		}
		while (*s && *s!='\n') s++;
		if (*s) s++;  // s pointer to next register
	}
}

//=============================================================================
// RdWrtSyslogServerEntry - Read/Write remote syslog server in 
// /etc/syslog-ng/syslog-ng.conf
//=============================================================================
static Result RdWrtSyslogServerEntry(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp;	// /etc/syslog-ng/syslog-ng.conf
	unsigned char *buf;

	dolog("RdWrtSyslogServerEntry");

	/* we will first read the file in a buffer */
	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		fp = fopen (pCkIndex->fileName, "w");
		WriteSyslogServerEntries(fp, buf,(SyslogServerInfo *)paramList->value,
				paramList->collectionSize);	
		fclose(fp);
		executeFlg |= EXE_DAEMON_SH;
	} else {  
		ReadSyslogServerEntries(buf, (SyslogServerInfo *)paramList->value,
				paramList->collectionSize);	
	}
	free(buf);
	return (kCycSuccess);	
}


//=============================================================================
// RdWrtSyslogDestEnable - Read/Write remote syslog destinations in 
// /etc/syslog-ng/syslog-ng.conf
//=============================================================================

static void ReadSyslogDestEntries(unsigned char *conf, int *value)
{
	int ServerId;
	unsigned char *s, *sl, dest[4];
	
	dolog("ReadSyslogDestEntries");

	*value = 0;

	s=conf;
	while (*s) {
		while (*s && isspace(*s)) s++;

		if (*s == 0x0A) {
			s++;
			continue;
		}

		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			if (*s) s++;
			continue;
		}
		
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s) return;
		*s++ = 0x00; // end of one register in syslog-ng.conf

		if (sscanf(sl,"log { source(src_dev_log); source(s_kernel); filter(frem%3clevel);", dest)) {
			if (strstr(sl, "destination(d_console)")) {
				*value |= 1;
			}
			if (strstr(sl, "destination(d_userroot)")) {
				*value |= 2;
			}
			if (strstr(sl, "destination(dremserver")) {
				*value |= 4;
			}
		} else if (sscanf(sl,"log { source(src_dev_log); filter(fremserver); destination(dremserver%d)", &ServerId)) {
				*value |= 4;
		} else if (strstr(sl, "destination(console)")) {
			*value |= 2; // previous version named "console" to issue root sessions
		}
		while (*s && *s!='\n') s++;
		if (*s) s++;  // s pointer to next register
	}
}

static void WriteSyslogDestEntries(FILE *fp, unsigned char *conf, int *value)
{
	unsigned char *inl, *s, *sl, dest[4];
	int ServerId;
	int fKVM = 0, fCAS = 0, fBuf = 0, fWeb = 0, fSys = 0;
	int dconsole = 0, droot = 0;
	int dserver[32], ix, nserver = 0;

	dolog("WriteSyslogDestEntries");

	inl= s = conf;
	while (*s) {
		
		while (*s && isspace(*s)) s++;
		if (*s == 0x0A) {
			s++;
			continue;
		}
		inl = s;
		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			fwrite(inl, (s-inl)+1,1,fp);
			if (*s) s++;
			continue;
		}
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s)	return;
		*s++ = 0x00;

		if (sscanf(sl,"log { source(src_dev_log); source(s_kernel); filter(frem%3clevel);", dest)) {
			if (strstr(sl, "destination(d_console)")) {
				while (*s && *s!='\n') s++;   // Do not write it.
				if (*s) s++;
				continue;
			}
			if (strstr(sl, "destination(d_userroot)")) {
				while (*s && *s!='\n') s++;   // Do not write it.
				if (*s) s++;
				continue;
			}
			if (strstr(sl, "destination(dremserver")) {
				while (*s && *s!='\n') s++;   // Do not write it.
				if (*s) s++;
				continue;
			}
		} else if (sscanf(sl,"log { source(src_dev_log); filter(fremserver); destination(dremserver%d)", &ServerId)) {
			while (*s && *s!='\n') s++;   // Do not write it.
			if (*s) s++;
			continue;
		} else if (strstr(sl,"destination(console)")) {
			while (*s && *s!='\n') s++;   // Do not write it.
			if (*s) s++;
			continue;
		} else if (strncmp(sl,"destination console", 19)==0) {
			while (*s && *s!='\n') s++;   // Do not write it.
			if (*s) s++;
			continue;
		} else if (strncmp(sl,"filter fremserver",17)==0) {
			while (*s && *s!='\n') s++;   // Do not write it.
			if (*s) s++;
			continue;
		} else if (strncmp(sl,"filter fremkvmlevel",19)==0) {
#if (defined(KVM) || defined(ONS))
			fKVM = 1;
#else		
			while (*s && *s!='\n') s++;   // Do not write it.
			if (*s) s++;
			continue;
#endif
		} else if (strncmp(sl,"filter fremcaslevel",19)==0) {
			fCAS = 1;
		} else if (strncmp(sl,"filter frembuflevel",19)==0) {
			fBuf = 1;
		} else if (strncmp(sl,"filter fremweblevel",19)==0) {
			fWeb = 1;
		} else if (strncmp(sl,"filter fremsyslevel",19)==0) {
			fSys = 1;
		} else if (strncmp(sl,"destination d_console", 21)==0) {
			dconsole = 1;
		} else if (strncmp(sl,"destination d_userroot",22)==0) {
			droot = 1;
		} else if (sscanf(sl,"destination dremserver%d", &ServerId)) {
			if (nserver < 31) 
				dserver[nserver++] = ServerId;
		} 

		*(s-1) = 0x7d;
		while (*s && *s!='\n') s++;
		fwrite(inl, (s-inl)+1,1,fp);

		if (*s) s++;  // s pointer to next register
	}


	if ((*value & 1) && (!dconsole)) {
		fprintf(fp,"destination d_console { file(\"/dev/ttyS0\"); };\n");
	}
	if ((*value & 2) && (!droot)) {
		fprintf(fp,"destination d_userroot { usertty(\"root\"); };\n");
	}

	if (*value && fCAS) {
		fprintf(fp,"log { source(src_dev_log); source(s_kernel); filter(fremcaslevel); %s %s ",
			(*value&1)?"destination(d_console);":"",
			(*value&2)?"destination(d_userroot);":"");
		if ((*value&4) && nserver) {
			for (ix = 0; ix < nserver; ix++) {
				fprintf(fp,"destination(dremserver%d); ", dserver[ix]);
			}
		}
		fprintf(fp, "};\n");
	}
	if (*value && fKVM) {
		fprintf(fp,"log { source(src_dev_log); source(s_kernel); filter(fremkvmlevel); %s %s ",
			(*value&1)?"destination(d_console);":"",
			(*value&2)?"destination(d_userroot);":"");
		if ((*value&4) && nserver) {
			for (ix = 0; ix < nserver; ix++) {
				fprintf(fp,"destination(dremserver%d); ", dserver[ix]);
			}
		}
		fprintf(fp, "};\n");
	}
	if (*value && fBuf) {
		fprintf(fp,"log { source(src_dev_log); source(s_kernel); filter(frembuflevel); %s %s ",
			(*value&1)?"destination(d_console);":"",
			(*value&2)?"destination(d_userroot);":"");
		if ((*value&4) && nserver) {
			for (ix = 0; ix < nserver; ix++) {
				fprintf(fp,"destination(dremserver%d); ", dserver[ix]);
			}
		}
		fprintf(fp, "};\n");
	}
	if (*value && fWeb) {
		fprintf(fp,"log { source(src_dev_log); source(s_kernel); filter(fremweblevel); %s %s ",
			(*value&1)?"destination(d_console);":"",
			(*value&2)?"destination(d_userroot);":"");
		if ((*value&4) && nserver) {
			for (ix = 0; ix < nserver; ix++) {
				fprintf(fp,"destination(dremserver%d); ", dserver[ix]);
			}
		}
		fprintf(fp, "};\n");
	}
	if (*value && fSys) {
		fprintf(fp,"log { source(src_dev_log); source(s_kernel); filter(fremsyslevel); %s %s ",
			(*value&1)?"destination(d_console);":"",
			(*value&2)?"destination(d_userroot);":"");
		if ((*value&4) && nserver) {
			for (ix = 0; ix < nserver; ix++) {
				fprintf(fp,"destination(dremserver%d); ", dserver[ix]);
			}
		}
		fprintf(fp, "};\n");
	}
}

static Result RdWrtSyslogDestEnable(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp;	// /etc/syslog-ng/syslog-ng.conf
	unsigned char *buf;

	dolog("RdWrtSyslogDestEnable");

	/* we will first read the file in a buffer */
	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		fp = fopen (pCkIndex->fileName, "w");
		WriteSyslogDestEntries(fp, buf, (int *)paramList->value);	
		fclose(fp);
		executeFlg |= EXE_DAEMON_SH;
	} else {  
		ReadSyslogDestEntries(buf, (int *)paramList->value);
	}
	free(buf);
	return (kCycSuccess);	
}

//=======================================================================
// Syslog-ng Routines to add/delete processes filters for syslog servers
//=======================================================================

static void ReadSyslogFilterEntry(unsigned char *conf, 
									FilterLevels *filter)
{
    unsigned char *s, *sl, *plvl, *level=NULL;
    int lenlvl = 240;

    dolog("ReadSyslogFilterEntry");

	level = (unsigned char *)malloc(lenlvl);
	if (level == NULL) {
		dolog("ReadSyslogFilterEntry error: Memory alloc fail.");
		return;
	}

    s=conf;

    while (*s) {
        while (*s && isspace(*s)) s++;

        if (*s == 0x0A) {
            s++;
            continue;
        }

        if (*s == 0x23) { // # comments
            while (*s && *s!='\n') s++;
            if (*s) s++;
            continue;
        }

        while (*s && isspace(*s)) s++;
        sl = s;
        s = strstr(sl,"};");
        if (!s) {
			free(level);
			return;
		}
        *s++ = 0x00; // end of one register in syslog-ng.conf

		if (lenlvl < strlen(sl)) {
			lenlvl = strlen(sl);
			free(level);
			level = (unsigned char *)malloc(lenlvl);
			if (level == NULL) {
				dolog("ReadSyslogFilterEntry error: Memory alloc fail.");
				return;
			}
		}

		if ((strstr(sl, "filter fremcaslevel")) &&
			(plvl = strstr(sl, "level("))) {
			if (sscanf(plvl, "level(%s)", level)) {
				filter->CASlevel = 0;
				if (strstr(level, "emerg"))		filter->CASlevel |= 0x01;
				if (strstr(level, "alert"))		filter->CASlevel |= 0x02;
				if (strstr(level, "crit"))		filter->CASlevel |= 0x04;
				if (strstr(level, "err"))		filter->CASlevel |= 0x08;
				if (strstr(level, "warn"))		filter->CASlevel |= 0x10;
				if (strstr(level, "notice"))	filter->CASlevel |= 0x20;
				if (strstr(level, "info"))		filter->CASlevel |= 0x40;
				if (strstr(level, "debug"))		filter->CASlevel |= 0x80;
			}
		}

#if defined(KVM) || defined(ONS)
		if ((strstr(sl, "filter fremkvmlevel")) &&
			(plvl = strstr(sl, "level("))) {
			if (sscanf(plvl, "level(%s)", level)) {
				filter->KVMlevel = 0;
				if (strstr(level, "emerg"))		filter->KVMlevel |= 0x01;
				if (strstr(level, "alert"))		filter->KVMlevel |= 0x02;
				if (strstr(level, "crit"))		filter->KVMlevel |= 0x04;
				if (strstr(level, "err"))		filter->KVMlevel |= 0x08;
				if (strstr(level, "warn"))		filter->KVMlevel |= 0x10;
				if (strstr(level, "notice"))	filter->KVMlevel |= 0x20;
				if (strstr(level, "info"))		filter->KVMlevel |= 0x40;
				if (strstr(level, "debug"))		filter->KVMlevel |= 0x80;
			}
		}
#else
		filter->KVMlevel = 0;
#endif

		if ((strstr(sl, "filter frembuflevel")) &&
			(plvl = strstr(sl, "level("))) {
			if (sscanf(plvl, "level(%s)", level)) {
				filter->Buflevel = 0;
				if (strstr(level, "emerg"))		filter->Buflevel |= 0x01;
				if (strstr(level, "alert"))		filter->Buflevel |= 0x02;
				if (strstr(level, "crit"))		filter->Buflevel |= 0x04;
				if (strstr(level, "err"))		filter->Buflevel |= 0x08;
				if (strstr(level, "warn"))		filter->Buflevel |= 0x10;
				if (strstr(level, "notice"))	filter->Buflevel |= 0x20;
				if (strstr(level, "info"))		filter->Buflevel |= 0x40;
				if (strstr(level, "debug"))		filter->Buflevel |= 0x80;
			}
		}

		if ((strstr(sl, "filter fremweblevel")) &&
			(plvl = strstr(sl, "level("))) {
			if (sscanf(plvl, "level(%s)", level)) {
				filter->Weblevel = 0;
				if (strstr(level, "emerg"))		filter->Weblevel |= 0x01;
				if (strstr(level, "alert"))		filter->Weblevel |= 0x02;
				if (strstr(level, "crit"))		filter->Weblevel |= 0x04;
				if (strstr(level, "err"))		filter->Weblevel |= 0x08;
				if (strstr(level, "warn"))		filter->Weblevel |= 0x10;
				if (strstr(level, "notice"))	filter->Weblevel |= 0x20;
				if (strstr(level, "info"))		filter->Weblevel |= 0x40;
				if (strstr(level, "debug"))		filter->Weblevel |= 0x80;
			}
		}

		if ((strstr(sl, "filter fremsyslevel")) &&
			(plvl = strstr(sl, "level("))) {
			if (sscanf(plvl, "level(%s)", level)) {
				filter->Syslevel = 0;
				if (strstr(level, "emerg"))		filter->Syslevel |= 0x01;
				if (strstr(level, "alert"))		filter->Syslevel |= 0x02;
				if (strstr(level, "crit"))		filter->Syslevel |= 0x04;
				if (strstr(level, "err"))		filter->Syslevel |= 0x08;
				if (strstr(level, "warn"))		filter->Syslevel |= 0x10;
				if (strstr(level, "notice"))	filter->Syslevel |= 0x20;
				if (strstr(level, "info"))		filter->Syslevel |= 0x40;
				if (strstr(level, "debug"))		filter->Syslevel |= 0x80;
			}
		}

		if ((strstr(sl, "log { source(src_dev_log);")) &&
			(strstr(sl, "destination(console);"))) {
			filter->CASlevel = 0x7e;
#if defined(KVM) || defined(ONS)
			filter->KVMlevel = 0x7e;
#else
			filter->KVMlevel = 0;
#endif
			filter->Buflevel = 0x7e;
			filter->Weblevel = 0x7e;
			filter->Syslevel = 0x7e;
		}

		if ((strstr(sl, "log { source(s_kernel);")) &&
			(strstr(sl, "destination(console);"))) {
			filter->Syslevel = 0x0e;
		}

        while (*s && *s!='\n') s++;
        if (*s) s++;  // s pointer to next register
    }

	free(level);
	return;	
}
                                                                                
static void WriteSyslogFilterEntry(FILE *fp, unsigned char *conf, 
										FilterLevels *filter)
{
    unsigned char *inl, *s, *sl;
    int ix, first;
	unsigned char *levels[] = {"emerg","alert","crit","err",
								"warn","notice","info","debug"};  

    dolog("WriteSyslogFilterEntry");

    inl = s = conf;
    while (*s) {
        while (*s && isspace(*s)) s++;
        if (*s == 0x0A) {
            s++;
            continue;
        }
        inl = s;
        if (*s == 0x23) { // # comments
            while (*s && *s!='\n') s++;
            fwrite(inl, (s-inl)+1,1,fp);
            if (*s) s++;
            continue;
        }
        while (*s && isspace(*s)) s++;

        sl = s;
        s = strstr(sl,"};");
        if (!s) return;
        *s++ = 0x00;

        if (!strncmp(sl, "filter fremserver", 17)) {
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
        }

		if ((strstr(sl, "filter fremcaslevel")) &&
			(strstr(sl, "level"))) {
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
		}
		else if ((strstr(sl, "filter fremkvmlevel")) &&
				 (strstr(sl, "level"))) {
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
		}
		else if ((strstr(sl, "filter frembuflevel")) &&
				 (strstr(sl, "level"))) {
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
		}
		else if ((strstr(sl, "filter fremweblevel")) &&
				 (strstr(sl, "level"))) {
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
		}
		else if ((strstr(sl, "filter fremsyslevel")) &&
				 (strstr(sl, "level"))) {
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
		}
		else if (strstr(sl,"filter(fremserver)")){
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
		}
		else if (strstr(sl,"filter(fremcaslevel)")){
			if (!filter->CASlevel) {
				while (*s && *s!='\n') s++;		// Do not write it
				if (*s) s++;
				continue;
			}
		}
		else if (strstr(sl,"filter(fremkvmlevel)")){
#if defined(KVM) || defined(ONS)
			if (!filter->KVMlevel)
#endif
			{
			while (*s && *s!='\n') s++;		// Do not write it
			if (*s) s++;
			continue;
			}
		}
		else if (strstr(sl,"filter(frembuflevel)")){
			if (!filter->Buflevel) {
				while (*s && *s!='\n') s++;		// Do not write it
				if (*s) s++;
				continue;
			}
		}
		else if (strstr(sl,"filter(fremweblevel)")){
			if (!filter->Weblevel) {
				while (*s && *s!='\n') s++;		// Do not write it
				if (*s) s++;
				continue;
			}
		}
		else if (strstr(sl,"filter(fremsyslevel)")){
			if (!filter->Syslevel) {
				while (*s && *s!='\n') s++;		// Do not write it
				if (*s) s++;
				continue;
			}
		}

        *(s-1) = 0x7d;
   	    while (*s && *s!='\n') s++;
       	fwrite(inl, (s-inl)+1,1,fp);

        if (*s) s++;  // s pointer to next register
    }

	if (filter->CASlevel) {
		fprintf(fp,"filter fremcaslevel { not program(KVMD) and not program(Data.Buffering) and facility(local%d) and level(", filter->CASfacility);
		first = TRUE;
		for (ix=0; ix < 8; ix++) {
			if (filter->CASlevel & (1<<ix)) {
				fprintf(fp,"%s%s", (first)?"":",", levels[ix]);
				first = FALSE;
			}
		}
		fprintf(fp,"); };\n");
	}

#if defined(KVM) || defined(ONS)
	if (filter->KVMlevel) {
		fprintf(fp,"filter fremkvmlevel { program(KVMD) and level(");
		first = TRUE;
		for (ix=0; ix < 8; ix++) {
			if (filter->KVMlevel & (1<<ix)) {
				fprintf(fp,"%s%s", (first)?"":",", levels[ix]);
				first = FALSE;
			}
		}
		fprintf(fp,"); };\n");
	}
#endif

	if (filter->Buflevel) {
		fprintf(fp,"filter frembuflevel { program(Data.Buffering) and level(");
		first = TRUE;
		for (ix=0; ix < 8; ix++) {
			if (filter->Buflevel & (1<<ix)) {
				fprintf(fp,"%s%s", (first)?"":",", levels[ix]);
				first = FALSE;
			}
		}
		fprintf(fp,"); };\n");
	}

	if (filter->Weblevel) {
		fprintf(fp,"filter fremweblevel { program(AcsWeb) and level(");
		first = TRUE;
		for (ix=0; ix < 8; ix++) {
			if (filter->Weblevel & (1<<ix)) {
				fprintf(fp,"%s%s", (first)?"":",", levels[ix]);
				first = FALSE;
			}
		}
		fprintf(fp,"); };\n");
	}

	if (filter->Syslevel) {
		fprintf(fp,"filter fremsyslevel { not facility(local0,local1,local2,local3,local4,local5,local6,local7) and not program(AcsWeb) and level(");
		first = TRUE;
		for (ix=0; ix < 8; ix++) {
			if (filter->Syslevel & (1<<ix)) {
				fprintf(fp,"%s%s", (first)?"":",", levels[ix]);
				first = FALSE;
			}
		}
		fprintf(fp,"); };\n");
	}
}

//=============================================================================
// RdWrtSyslogFilterEntry - Read/Write filter for remote syslog server in
// /etc/syslog-ng/syslog-ng.conf
//=============================================================================
static Result RdWrtSyslogFilterEntry(void *ptr, CycParam *paramList, int rdWrtFlg)
{
    CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
    FILE *fp;   // /etc/syslog-ng/syslog-ng.conf
    unsigned char *buf;

    dolog("RdWrtSyslogFilterEntry");

    /* we will first read the file in a buffer */
    if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL)
    {
        LogError(FILE_READ_ERROR, pCkIndex->fileName);
        return(kFileReadError);
    }

    /* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
    if (rdWrtFlg) {
        fp = fopen (pCkIndex->fileName, "w");
        WriteSyslogFilterEntry(fp, buf, (FilterLevels *)paramList->value);
        fclose(fp);
	    executeFlg |= EXE_DAEMON_SH;
    } else {
        ReadSyslogFilterEntry(buf, (FilterLevels *)paramList->value);
    }
    free(buf);
    return (kCycSuccess);
}

/*=============================================================================
 * The Notification #N in syslog-ng.conf have the following syntax :
 * 1) source name is srv_dev_log that is defined by default 
 *  		source src_dev_log { unix-stream("/dev/log"); };
 *		
 * 2) filter name is fnotif_match#N :
 *     filter fnotif_match#N { level(info) and match("ALARM") and 
 *            match("<trigger>"); };
 *            
 * 3) destination name is dnotif_<event>#N. 
 *   email 
 *   	destination dnotif_email#N { pipe("/dev/cyc_alarm" 
 *   		template("sendmail -t <toAddress> -f <fromAddress> -s \\
 *   		\"<subject>\" -m \"<body>\" -h serverIp -p serverPort"));};
 *		  
 *  pager
 *   	destination dnotif_pager#N { pipe("/dev/cyc_alarm" 
 *   		template("sendsms -d <phoneNum> -m \"<text>\" \\
 *   		-u \"<smsUserName>\" -p <smsPort> <smsServerIp>)); };
 *
 *  snmptrap
 *   	destination dnotif_snmptrap#N { pipe("/dev/cyc_alarm" 
 *   		template("snmptrap -v 1 -c <community> <serverIp> \\
 *   		\"\" \"\" <trapNumber> 0 \"\" <oid> \\
 *   		s \"<body>\")); };
 *
 * 4) log :
 *	log { source(src_dev_log); filter(fnotif_match#N);destination(dnotif_<event>#N);};
 *   	 
 *=============================================================================
 */


//=============================================================================
// GetNumNotificationEntries : get the number of notifications configured in
// syslog-ng.conf. 
//=============================================================================
static void GetNumNotificationEntries(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	FILE *fp;	// /etc/syslog-ng/syslog-ng.conf
	struct stat st;
	unsigned char *buf, *s;

	dolog("GetNumNotificationEntries");

	/* we will first read the file in a buffer */
	if (stat(pCkIndex->fileName, &st)) return;
	buf = (unsigned char *)malloc(st.st_size+1);
	if (!buf) return;
	fp = fopen (pCkIndex->fileName, "r");
	if (!fp) {
		free(buf);
		return;
	}
	fread(buf, 1, st.st_size, fp);
	*(buf+st.st_size) = 0;
	fclose(fp);

	s=buf;
	while (*s) {
		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			continue;
		}
		while (*s && isspace(*s)) s++;
		if (!strncmp("log { source(src_dev_log); filter(fnotif_match",
					s, 46)) {
			(*(int *)paramList->value)++;
			dolog("Increment num of entries: %d", *(int *)paramList->value);
		}
		while (*s && *s!='\n') s++;
	}
	free(buf);
}

/*
 * trigger_notifications_pos : it finds the register in NotificationInfo array
 * that has field triggerId equal the parameter triggerId. 
 * Return the pointer to register or NULL when array is full.
 */
static NotificationInfo * trigger_notifications_pos(NotificationInfo *array,
		int triggerId, int max_entries, int flg_read)
{
	NotificationInfo *entry = array;
	int i;

	dolog("trigger_notifications_pos()");

	for (i=0; i < max_entries ; i++, entry++) {
		if ((entry->triggerId == triggerId) ||
		    (flg_read && !entry->triggerId)) {
			dolog("trigger_notifications_pos found");
			dolog("Entry triggerID: %d", entry->triggerId);
			return entry;
		}
	}
	dolog("trigger_notifications_pos return NULL");
	return NULL;
}

static void WriteEventNotificationEntry(FILE *fp,NotificationInfo *info)
{
	switch (info->type) { // parse the correct info
		case kNtEmail :	
			fprintf(fp,"destination dnotif_email%d { pipe(\"/dev/cyc_alarm\" \
template(\"sendmail -t %s -f %s -s \\\"%s\\\" -m \\\"%s\\\" -h %s -p %d \")); }; \n",
				info->triggerId,info->event.email.toAddress, 
				info->event.email.fromAddress, info->event.email.subject,
				info->event.email.body, info->event.email.serverIp, 
				info->event.email.serverPort);
			break;
		case kNtPager :
			fprintf(fp,"destination dnotif_pager%d { pipe(\"/dev/cyc_alarm\" \
template(\"sendsms -d %s -m \\\"%s\\\" -u \\\"%s\\\" -p %d %s \")); }; \n",
				info->triggerId,info->event.pager.phoneNum, 
				info->event.pager.text, info->event.pager.smsUserName,
				info->event.pager.smsPort, info->event.pager.smsServerIp);
			break;
		case kNtSnmpTrap :
			fprintf(fp,"destination dnotif_snmptrap%d { pipe(\"/dev/cyc_alarm\" \
template(\"snmptrap -v 1 -c %s %s \\\"\\\" \\\"\\\" %d 0 \\\"\\\" %s s \\\"%s\\\" \")); };\n",
				info->triggerId,info->event.snmptrap.community, 
				info->event.snmptrap.serverIp, 
				info->event.snmptrap.trapNumber,info->event.snmptrap.oid, 
				info->event.snmptrap.body);
			break;
	}
}

static void WriteNotificationEntries(FILE *fp, unsigned char *conf, 
				NotificationInfo *entries, int num_entries)
{
	int triggerId, j, last_triggerId;
	unsigned char *inl, *s, *sl;
	unsigned char strev[30];
	NotificationInfo *info;
	
	dolog("WriteNotificationEntries num_entries=%d", num_entries);
	
	last_triggerId = 0;
	inl= s = conf;
	while (*s) {
		
		inl = s;
		while (*s && isspace(*s)) s++;

		if (*s == 0x0A) {
			s++;
			continue;
		}

		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			fwrite(inl, (s-inl)+1,1,fp);
			if (*s) s++;
			continue;
		}
		
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s) return;
		*s++ = 0x00;

		//check is filter's notification
		if (sscanf(sl,"filter fnotif_match%d",&triggerId)) {
			// it is filter's notification
			dolog("filter - triggerId = %d",triggerId);
			info = trigger_notifications_pos(entries,triggerId,num_entries,0);
			if (!info || (info->triggerId != triggerId)) {
				if (last_triggerId < triggerId) 
					last_triggerId = triggerId;
				goto CYC_WRITE_NOTIF_REGISTER;
			}
			if (info->action != kDelete) { //[RK]Oct/22/03
				fprintf(fp,"filter fnotif_match%d { level(info) and match(\"ALARM\") and match(\"%s\"); };\n", 
						triggerId,info->trigger);
				if (last_triggerId < triggerId) 
					last_triggerId = triggerId;
			}
			while (*s && *s!='\n') s++;
			if (*s) s++;
			continue;
		}

		//check is destination's notification
		if (sscanf(sl,"destination dnotif_%s",strev)) {
			// it is destination's notification
			if (!sscanf(strev,"email%d",&triggerId)) {
				if (!sscanf(strev,"pager%d",&triggerId)) {
					if (!sscanf(strev,"snmptrap%d",&triggerId)) {
						// it is not destination's notification
						goto CYC_WRITE_NOTIF_REGISTER;
					}
				}
			}
			dolog("destination - event=[%s] triggerId=%d",strev,triggerId);
					
			info = trigger_notifications_pos(entries,triggerId,num_entries,0);

			if (!info || (info->triggerId != triggerId)) {
					goto CYC_WRITE_NOTIF_REGISTER;
			}

			if (info->action != kDelete) { //[RK]Oct/22/03
				WriteEventNotificationEntry(fp,info);
			}
			while (*s && *s!='\n') s++;
			if (*s) s++;
			continue;
		}
		
		// check log 
		if (sscanf(sl,"log { source(src_dev_log); filter(fnotif_match%d)",&triggerId)) {
			// it is log's notification
			dolog("log - triggerId = %d",triggerId);
			info = trigger_notifications_pos(entries,triggerId,num_entries,0);
			if (!info || (info->triggerId != triggerId)) {
				goto CYC_WRITE_NOTIF_REGISTER;
			}
			if (info->action == kDelete) {
				dolog("ACTION = kDelete");
				while (*s && *s!='\n') s++;
				if (*s) s++;
				continue;
			}
		}
						
CYC_WRITE_NOTIF_REGISTER :
		//dolog("At CYC_WRITE_NOTIF_REGISTER");
		*(s-1) = 0x7d;
		while (*s && *s!='\n') s++;
		fwrite(inl, (s-inl)+1,1,fp);
		
		if (*s) s++;  // s pointer to next register
	}

	// add new entries
	for (j=0, info=entries; j < num_entries; j++, info++) {
		if ((info->action == kAdd) && (info->triggerId <= 0)) {
		//if (!info->triggerId) {
			dolog("kAdd -> triggerID %d trigger [%s]",last_triggerId,info->trigger);
			info->triggerId = ++last_triggerId;
			// add filter
			fprintf(fp,"filter fnotif_match%d { level(info) and match(\"ALARM\") and match(\"%s\"); };\n", 
				info->triggerId,info->trigger);
			// add destination
			WriteEventNotificationEntry(fp,info);
			// add log
			switch (info->type) {
				case kNtEmail : strcpy(strev,"email"); break;
				case kNtPager : strcpy(strev,"pager"); break;
				case kNtSnmpTrap : strcpy(strev,"snmptrap");break;
			}
			fprintf(fp,"log { source(src_dev_log); filter(fnotif_match%d); destination(dnotif_%s%d); }; \n",
				info->triggerId,strev,info->triggerId);
		}			
	}
}

/*
 * ParseFilterNotificationEntry - to find the trigger match in the line
 * return the trigger size
 */
static int ParseFilterNotificationEntry(unsigned char *line, unsigned char **trigger)
{
	unsigned char *s = line, *m;
	int len;

	dolog("ParseFilterNotificationEntry()");

	m = strstr(s,"match("); // match("ALARM");
	if (!m) return 0;
	s = m + 6;	
	m = strstr(s,"match("); // match("<trigger>");
	if (!m) return 0;
	s = m + 7;
	m = strstr(s,"\");");
	if (!m) return 0;
	*m = 0x00;
	//strcpy(trigger, s);
	*trigger = s;
	len = m - s;
	return len;
}

/*
 * ParseEventEMailEntry - to find the e-mail event parameters
 *   	destination dnotif_email#N { pipe("/dev/cyc_alarm" 
 *    		template("sendmail -t <toAddress> -f <fromAddress> -s \\
 *   		\"<subject>\" -m \"<body>\" -h serverIp -p serverPort")); };
 */
static int ParseEventEMailEntry(unsigned char *line, Events *event)
{
	unsigned char *s = line, *t;
	EmailEntry *email = (EmailEntry *)event;

	dolog("ParseEventMailEntry()");

	t = strstr(s,"-t ");
	if (!t) return 0;
	
	s = t + 3;
	t = strstr(s," -f ");
	if (!t) return 0;
	*t = 0x00;
	strcpy(email->toAddress,s); 

	s = t + 4;
	t = strstr(s," -s ");
	if (!t) return 0;
	*t = 0x00;
	strcpy(email->fromAddress,s);

	s = t + 6;
	t = strstr(s," -m ");
	if (!t) return 0;
	*(t-2) = 0x00;
	strcpy(email->subject,s);

	s = t + 6;
	t = strstr(s," -h ");
	if (!t) return 0;
	*(t-2) = 0x00;
	strcpy(email->body,s);

	s = t + 4;
	t = strstr(s," -p ");
	if (!t) return 0;
	*t = 0x00;
	strcpy(email->serverIp,s);
	
	s = t += 4;
	while (*s && isdigit(*s)) s++;
	*s = 0x00;
	email->serverPort = atoi(t);

	return 1;
}

/*
 * ParseEventPagerEntry - to find the pager event parameters
 *    	destination dnotif_pager#N { pipe("/dev/cyc_alarm" 
 *    		template("sendsms -d <phoneNum> -m \"<text>\" \\
 *    		-u \"<smsUserName>\" -p <smsPort> <smsServerIp>)); };
 */
static int ParseEventPagerEntry(unsigned char *line, Events *event)
{
	unsigned char *s = line, *t;
	Pager *pager = (Pager *)event;

	dolog("ParseEventPagerEntry()");

	t = strstr(s,"-d ");
	if (!t) return 0;
	
	s = t + 3;
	t = strstr(s," -m ");
	if (!t) return 0;
	*t = 0x00;
	strcpy(pager->phoneNum,s);

	s = t + 6;
	t = strstr(s, " -u ");
	if (!t) return 0;
	*(t-2) = 0x00;
	strcpy(pager->text,s);

	s = t + 6;
	t = strstr(s, " -p ");
	if (!t) return 0;
	*(t-2) = 0x00;
	strcpy(pager->smsUserName,s);

	s = t += 4;
	while (*s && isdigit(*s)) s++;
	*s++ = 0x00;
	pager->smsPort = atoi(t);

	t = strstr(s,"));");
	if (!t) return 0;
	*(t-2) = 0x00;
	strcpy(pager->smsServerIp,s);

	return 1;
}


/*
 * ParseEventSnmpTrapEntry - to find the snmptrap event parameters
 *    	destination dnotif_snmptrap#N { pipe("/dev/cyc_alarm" 
 *    		template("snmptrap -v 1 -c <community> <serverIp> \\
 *    		\"\" \"\" <trapNumber> 0 \"\" <oid> \\
 *    		s \"<body>\")); };
 */
static int ParseEventSnmpTrapEntry(unsigned char *line, Events *event)
{
	unsigned char *s = line, *t;
	SnmpTrap *trap = (SnmpTrap *)event;

	dolog("ParseEventSnmpTrapEntry()");

	t = strstr(s,"-c ");
	if (!t) return 0;
	s = t += 3;
	while (*t && !isspace(*t)) t++;
	if (!*t) return 0;
	*t++ = 0x00;
	strcpy(trap->community, s);

	s = t;
	while (*t && !isspace(*t)) t++;
	if (!*t) return 0;
	*t++ = 0x00;
	strcpy(trap->serverIp,s);
	
	while (*t && !isdigit(*t)) t++;
	if (!*t) return 0;
	s = t;
	while (*t && isdigit(*t)) t++;
	if (!*t) return 0;
	*t++ = 0x00;
	trap->trapNumber = atoi(s);

	s = t += 7;
	t = strstr(s," s ");
	if (!t) return 0;
	*t = 0x00;
	strcpy(trap->oid,s);

	s = t + 5;
	t = strstr(s,"));");
	if (!t) return 0;
	*(t-4) = 0x00;
	
	strcpy(trap->body,s);

	return 1;
}

static void ReadNotificationEntries(unsigned char *conf, NotificationInfo *entries, int max_entries)
{
	int triggerId, len;
	unsigned char *s, *sl, *trigger;
	unsigned char strev[50];
	CycNotificationType type;
	NotificationInfo *info;
	Events event;
	
	dolog("ReadNotificationEntries max_entries=%d",max_entries);
	
	s=conf;
	while (*s) {
		while (*s && isspace(*s)) s++;
		if (*s == 0x0A) {
			s++;
			continue;
		}

		if (*s == 0x23) { // ## comments
			while (*s && *s!='\n') s++;
			if (*s) s++;
			continue;
		}
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s) return;
		*s++ = 0x00; // end of one register in syslog-ng.conf

		while (*s && *s!='\n') s++;
		if (*s) s++;  // s pointer to next register
		//check is filter's notification
		if (sscanf(sl,"filter fnotif_match%d", &triggerId)) { 
			// it is filter's notification
			dolog("filter - triggerId = %d",triggerId);
			len = ParseFilterNotificationEntry(sl, &trigger);
			if (!len) continue;
			info = trigger_notifications_pos(entries,triggerId,max_entries,1);
			if (info) {
				info->triggerId = triggerId;
				strncpy(info->trigger, trigger, len);
			}
			continue;
		}

		//check is destination's notification
		if (sscanf(sl,"destination dnotif_%s",strev)) {
			// it is destination's notification
			if (sscanf(strev,"email%d",&triggerId)) {
					type = kNtEmail;
			} else {
				if (sscanf(strev,"pager%d",&triggerId)) {
					type = kNtPager;
				} else {
					if (sscanf(strev,"snmptrap%d",&triggerId)) {
						type = kNtSnmpTrap;
					} else {
						continue; 	// it is not destination's notification
					}
				}
			}
					
			dolog("destination - event=[%s] triggerId = %d",strev,triggerId);

			switch (type) { // parse the correct info
				case kNtEmail :
					len = ParseEventEMailEntry(sl,&event);
					break;
				case kNtPager :
					len = ParseEventPagerEntry(sl,&event);
					break;
				case kNtSnmpTrap :
					len = ParseEventSnmpTrapEntry(sl,&event);
					break;
			}
			
			if (!len) continue;
			
			info = trigger_notifications_pos(entries,triggerId,max_entries,1);
			if (info) { 
				info->triggerId = triggerId;
				info->type = type;
				info->event = event;
			}
			memset((char *)&event,0,sizeof(Events));
		}
	}
}

static Result RdWrtNotificationEntry(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp;	// /etc/syslog-ng/syslog-ng.conf
	unsigned char *buf;

	dolog("RdWrtNotificationEntry collectionSize=%d",paramList->collectionSize);

	/* we will first read the file in a buffer */
	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}
	
	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		fp = fopen (pCkIndex->fileName, "w");
		//WriteNotificationEntries(fp, buf,(NotificationInfo *)paramList->value,
	//			paramList->collectionSize/sizeof(NotificationInfo));	
		WriteNotificationEntries(fp, buf,(NotificationInfo *)paramList->value,
				paramList->collectionSize);	
		fclose(fp);
		executeFlg |= EXE_DAEMON_SH;
	} else {  
		//ReadNotificationEntries(buf, (NotificationInfo *)paramList->value,
		//		paramList->collectionSize/sizeof(NotificationInfo));	
		ReadNotificationEntries(buf, (NotificationInfo *)paramList->value,
				paramList->collectionSize);	
	}
	free(buf);
	return (kCycSuccess);	
}

//=======================================================================
// IP Tables Routines
//=======================================================================

//=============================================================================
// GetIpTableChainNum : get the number of chains of the Filter Table.
// table : system "iptables -t <table>  --list > WEB_TEMP_FILE" 
// Chain <chain name>
// target .....
// <rules>
// Chain <chain name>
// target ....
// <rules:
//
//=============================================================================
static void GetIpTableChainNum(CycCatKeyTable *pCkIndex, CycParam *paramList, char * table)
{
	unsigned char buffer[250];
	int chains=0;
	FILE *fp;

	sprintf(buffer,"iptables -t %s --list > %s",table,pCkIndex->fileName);
	system(buffer);
	if ((fp = fopen(pCkIndex->fileName, "ro")) != NULL) {
		while (fgets(buffer, sizeof(buffer), fp)) {
			if (!strncmp(buffer, "Chain ",6)) {
				chains++;
				continue;
			}
		}
		fclose(fp);
	}
	sprintf(buffer,"rm -f %s",pCkIndex->fileName);
	system(buffer);
	dolog("GetIpChainNum table=%s chains=%d ",table,chains);
	*(int *)paramList->value = chains;
}

static void RdIpTablesChain(CycParam *paramList, char *tablename)
{
	FILE *fp;
	unsigned char buffer[250];
	unsigned char val1[50],val2[50],val3[50],val4[50];
	int num;
	ChainInfo *chain = 0;

	// Read the Table information 
	sprintf(buffer,"iptables -t %s --list --num -v > %s",tablename,WEB_TEMP_FILE);
	system(buffer);
	if ((fp = fopen(WEB_TEMP_FILE, "ro")) == NULL) {
		sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
		system(buffer);
		return ;	
	}
	
	chain = (ChainInfo *) paramList->value;
	memset(chain, 0, paramList->collectionSize * sizeof(ChainInfo));
	num = 0;	

	while (fgets(buffer, sizeof(buffer), fp)) {
		// Reset the values
		sprintf(val1, "%s", "-");
		sprintf(val2, "%s", "-");
		sprintf(val3, "%s", "-");
		sprintf(val4, "%s", "-");

		if (sscanf(buffer,"Chain %s (policy %s %s packets, %s bytes)",
			val1, val2, val3, val4)) {
			strcpy(chain->name,val1);
			strcpy(chain->policy,val2);
			strcpy(chain->packets,val3);
			strcpy(chain->bytes, val4);
			num = 0;
			continue;
		}
		if (strlen(buffer) <= 2) {
			chain->numrules = num;
			chain++;
			continue;
		}

		if (!strncmp(buffer," pkts",5)) continue;
		num++;
		chain->numrules = num;
	}
	fclose(fp);
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
	system(buffer);
}

static void WrtIpTablesChain(CycParam *paramList, char *tablename)
{
	unsigned char buffer[250], param[100];
	int numchain, maxchains;
	ChainInfo *chain;

	chain = (ChainInfo *)paramList->value;
	//maxchains = paramList->collectionSize/sizeof(ChainInfo);	
	maxchains = paramList->collectionSize;	
	
	for (numchain=0; numchain < maxchains; numchain++,chain++) {
		memset(buffer, 0, sizeof(buffer));
		memset(param,0,sizeof(param));
		switch (chain->action) {
			case kDelete :
				sprintf(buffer, "iptables --table %s -F %s >%s 2>&1", tablename, chain->name, WEB_TEMP_FILE);
				system(buffer);
				memset(buffer, 0, sizeof(buffer));
				sprintf(param,"--delete-chain %s ",chain->name);
				break;
			case kAdd :
				sprintf(param,"--new-chain %s",chain->name);
				break;
			case kEdit :
				sprintf(param,"--policy %s %s",chain->name,chain->policy);
				break;
			case kActionIgnore : 
				/*WebApi.c:14015: warning: enumeration 
				value `kActionIgnore' not handled in switch*/
			default :
				break;
		}
		if (param[0]) {
			sprintf(buffer,"iptables --table %s %s >%s 2>&1",
				tablename,param,WEB_TEMP_FILE);
			system(buffer);
			executeFlg |= EXE_FIREWALL;
		}
	}
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
}

static Result RdWrtFilterChainInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	dolog("RdWrtFilterChainInfo rdWrtFlg=%d",rdWrtFlg);

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		WrtIpTablesChain(paramList,"filter");
	} else {
		RdIpTablesChain(paramList,"filter");
	}
	return (kCycSuccess);
}

static Result RdWrtNatChainInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	dolog("RdWrtNatChainInfo rdWrtFlg=%d",rdWrtFlg);

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		WrtIpTablesChain(paramList,"nat");
	} else {
		RdIpTablesChain(paramList,"nat");
	}
	return (kCycSuccess);
}

#ifdef NATTABLE
/*
WebApi.c:14075: warning: `ParseIpTablesRulesMasq' defined but not used
*/
static void ParseIpTablesRulesMasq(char *pbuf, IpTablesRules *rule)
{
	char *aux, *p1,*p2;

	aux = strstr(pbuf,"ports");
	if (!aux) return;
	
	p1 = p2 = 0;
	
	while (*aux && !isdigit(*aux)) aux++;
	
	p1 = aux;
	while (*aux) {
		if (*aux =='-'){
			*aux = 0x00;
			p2 = aux + 1;
		}
		if ((*aux == ' ') || (*aux == 0x0a)) {
			*aux = 0x00;
			break;
		}
		aux++;
	}
		
	if (p1) strcpy(rule->NatToPort, p1);
	if (p2) strcpy(rule->NatToLastPort, p2);
}

/*
WebApi.c:14103: warning: `ParseIpTablesRulesNAT' defined but not used
*/
static void ParseIpTablesRulesNAT(char *pbuf, IpTablesRules *rule)
{
	char *aux, *ip, *ipl,*p1,*p2;

	aux = strstr(pbuf,"to:");
	if (!aux) return ;
	
	ipl = p1 = p2 = 0;
	
	while (*aux && !isdigit(*aux)) aux++;
	
	ip = aux;
	while (*aux) {
		if (*aux =='-'){
			*aux = 0x00;
			if (!ipl) {
			       ipl = aux + 1;
			} else {
				p2 = aux + 1;
			}
		}
		if (*aux == ':') {
			*aux = 0x00;
			p1 = aux + 1;
		}
		if ((*aux == ' ') || (*aux == 0x0a)) {
			*aux = 0x00;
			break;
		}
		aux++;
	}

	strcpy(rule->NatToIp,ip);
	if (ipl) strcpy(rule->NatToLastIp,ipl);
	if (p1) strcpy(rule->NatToPort, p1);
	if (p2) strcpy(rule->NatToLastPort, p2);
}
#endif

static void ParseIpTablesRulesLog(char *pbuf, IpTablesRules *rule)
{
	char * aux, *aux1, pref[50];
	int val1;
		
	aux = strstr(pbuf,"LOG");
	if (!aux) return;
	
	if ((aux1=strstr(aux,"level"))) {
		sscanf(aux1,"level %d",&val1);
		rule->LogLevel = val1;
	}
	if ((aux1 = strstr(aux,"flags"))) {
		sscanf(aux1,"flags %d",&val1);
		rule->LogTcpOptions = val1;
	} 			
	if ((aux1 = strstr(aux,"prefix"))) {
		sscanf(aux1,"prefix %s",pref);
		pref[strlen(pref) - 1] = 0x00;
		strcpy(rule->LogPrefix,&pref[1]);
	}		
}

unsigned char *ICMPTypeList[] = {
	"echo-reply",	// type 0
	"",		// type 1
	"",		// type 2
	"destination-unreachable",	// type 3
	"source-quench",	// type 4
	"redirect",		// type 5
	"",		// type 6
	"",		// type 7
	"echo-request",	// type 8
	"router-advertisement", // type 9
	"router-solicitation",	// type 10
	"time-exceeded",	// type 11
	"parameter-problem",	// type 12
	"timestamp-request",	// type 13
	"timestamp-reply",	// type 14
	"address-mask-request",	// type 15
	"address-mask-reply"	// type 16
};

unsigned char *ICMPType3Code[] = {
	"network-unreachable",         // code 0
	"host-unreachable",		// code 1
	"protocol-unreachable",		// code 2
	"port-unreachable",		// code 3
	"fragmentation-needed",		// code 4
	"source-route-failed",		// code 5
	"network-unknown",		// code 6
	"host-unknown",			// code 7
	"network-prohibited",		// code 8
	"host-prohibited",		// code 9
	"TOS-network-unreachable",	// code 10
	"TOS-host-unreachable",		// code 11
	"communication-prohibited",	// code 12
	"host-precedence-violation",	// code 13
	"precedence-cutoff",		// code 14
};

unsigned char *ICMPType5Code[] = {
	"network-redirect",	// code 0
	"host-redirect",	// code 1
	"TOS-network-redirect", // code 2
	"TOS-host-redirect",	// code 3
};

unsigned char *ICMPType11Code[] = {
	"ttl-zero-during-transit",	// code 0
	"ttl-zero-during-reassembly",	// code 1
};

unsigned char *ICMPType12Code[] = {
	"ip-header-bad",	// code 0
	"required-option-missing", // code 1
};

static char * ParseIpTablesRulesExt(char *buffer, IpTablesRules *rule)
{
	char * aux, *aux1, range, *pbuf=buffer;
	int val1, val2, prot;
		
	if (rule->protocol == kNumeric) {
		prot = rule->protocolNumber;
	} else {
		prot = rule->protocol;
	}

	// UDP or TCP : Source Port / Destination Port
	if ((prot == kTcp) || (prot == kUdp)) {
		if ((aux = strstr(pbuf,"spt"))) { // Source port
			aux += 3;
			if (*aux == 's') {
				range=1;
				aux++;
			} else {
				range = 0;
			}
			aux++; // skip :
			if (*aux == '!') { // invert
				rule->SourcePortInvert = kInverted;
				aux++;
			} 	
			aux1 = aux;
			while (*aux && isdigit(*aux)) aux++;
			if (*aux) *aux++ = 0x00;
			strcpy(rule->SourcePort, aux1);

			if (range) {
				aux1 = aux;
				while (*aux && isdigit(*aux)) aux++;
				if (*aux) *aux++ = 0x00;
				strcpy(rule->LastSourcePort, aux1);
			}
			pbuf = aux;
		}
		if ((aux = strstr(pbuf,"dpt"))) { // Destination port
			aux += 3;
			if (*aux == 's') {
				range=1;
				aux++;
			} else {
				range = 0;
			}
			aux++; // skip :
			if (*aux == '!') { // invert
				rule->DestinationPortInvert = kInverted;
				aux++;
			} 	
			aux1 = aux;
			while (*aux && isdigit(*aux)) aux++;
			if (*aux) *aux++ = 0x00;
			strcpy(rule->DestinationPort, aux1);
			if (range) {
				aux1 = aux;
				while (*aux && isdigit(*aux)) aux++;
				if (*aux) *aux++ = 0x00;
				strcpy(rule->LastDestinationPort, aux1);
			}
			pbuf = aux;
		}
		// TCP : Flags
		if (prot == kTcp) {
			if ((aux = strstr(pbuf,"flags:"))) { 
				aux += 6;
				if (*aux == '!') { // invert
					rule->TcpFlagsInvert = kInverted;
					aux++;
				} 	
				sscanf(aux,"%x/%x", &val1,&val2);
				rule->TcpFlags = val1;
				rule->TcpFlagsSet = val2;
			}
		}
	} else {
		if (prot == kIcmp) {
			if ((aux = strstr(pbuf,"icmp "))) { 
				aux += 5;
				if (*aux == '!') { // invert
					rule->ICMPTypeInvert = kInverted;
					aux++;
				} 	
				sscanf(aux,"type %d",&val1);
				if ((aux = strstr(aux,"code"))) {
					sscanf(aux,"code %d",&val2);
					switch (val1) {
						case 3 :
							strcpy(rule->ICMPType,ICMPType3Code[val2]);
							break;
						case 5 :
							strcpy(rule->ICMPType,ICMPType5Code[val2]);
							break;
						case 11 :
							strcpy(rule->ICMPType,ICMPType11Code[val2]);
							break;
						case 12 :
							strcpy(rule->ICMPType,ICMPType12Code[val2]);
							break;
					}
				} else {
					strcpy(rule->ICMPType,ICMPTypeList[val1]);
				}	
			}
		}
	}

	return(pbuf);
}

static void RdIpTablesRules(ChainInfo *pChain, char *tablename)
{
	FILE *fp;
	unsigned char buffer[250] = {0}, *pbuf;
	unsigned char val1[50],val2[50],val3[50],val4[50],val5[50];
	unsigned char val6[50],val7[50],val8[50],val9[50];
	unsigned char *aux,*aux1;
	int numrules;
	IpTablesRules *rule;
	unsigned int maskcnt, mask, maskbase;

	if (!pChain->numrules) return;

	// Read the Table information 
	sprintf(buffer,"iptables -t %s --list %s --num -v > %s",
					tablename,pChain->name,WEB_TEMP_FILE);
	system(buffer);
	
	if ((fp = fopen(WEB_TEMP_FILE, "ro")) == NULL) {
		sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
		system(buffer);
		return ;	
	}
	
	rule = pChain->rules;

	numrules = 0;	

	while (fgets(buffer, sizeof(buffer), fp)) {
		if (!strncmp(buffer,"Chain",5) ||
			!strncmp(buffer," pkts",5)) {
			continue;	
		}
		
		// parse rule
		sscanf(buffer," %s %s %s %s %s %s %s %s %s ",
			val1, // pkts
			val2, // bytes
			val3, // target
			val4, // prot
			val5, // opt
			val6, // in-interf
			val7, // out-inter
			val8, // source
			val9 // destination
		      );
		
		strcpy(rule->packets,val1);
		strcpy(rule->bytes,val2);
		strcpy(rule->target,val3);
		
		if (val4[0] == 0x21) { // inverted
			rule->protocolInvert = kInverted;
			aux = &val4[1];
		} else {
			if (val4[0] != 0x2a) {
				rule->protocolInvert = knotInverted;
				aux = &val4[0];
			} else {
				aux = 0;
			}
		}
		
		if (!aux) {
			rule->protocol = 0;
			rule->protocolNumber = 0;
		} else { 
			if (!strcmp(aux,"tcp")) {
				rule->protocol = kTcp;
			} else {
				if (!strcmp(aux,"udp")) {
					rule->protocol = kUdp;
				} else {
					if (!strcmp(aux,"icmp")) {
						rule->protocol = kIcmp;
					} else {
						if (!strcmp(aux,"all")) {
							rule->protocol = kAll;
						} else {
							rule->protocol = kNumeric;
							rule->protocolNumber = atoi(aux);
						}
					}
					
				}
			}
		}
		
		if (!strcmp(val5,"--")) {
			rule->fragment = kallPackets;
		} else {
			if (!strcmp(val5,"-f")) {
				rule->fragment = konlyFragments;
			} else {
				if (!strcmp(val5,"!f")) {
					rule->fragment = knoFragFirstFrag;
				} else {
					rule->fragment = 0;
				}
			}
		}
		
		if (val6[0] == 0x21) { // inverted
			rule->inInterfaceInvert = kInverted;
			if (val6[1] != '*') 
				strcpy(rule->inInterface,&val6[1]);
		} else {
			rule->inInterfaceInvert = knotInverted;
			if (val6[0] != '*') 
				strcpy(rule->inInterface,val6);
		}
		if (val7[0] == 0x21) { // inverted
			rule->outInterfaceInvert = kInverted;
			if (val7[1] != '*') 
				strcpy(rule->outInterface,&val7[1]);
		} else {
			rule->outInterfaceInvert = knotInverted;
			if (val7[0] != '*') 
				strcpy(rule->outInterface,val7);
		}
		aux = strstr(val8,"/");
		if (aux) *aux++ = 0x00;
		if (val8[0] == 0x21) { // inverted
			rule->sourceIpInvert = kInverted;
			strcpy(rule->sourceIp,&val8[1]);
		} else {
			rule->sourceIpInvert = knotInverted;
			strcpy(rule->sourceIp,val8);
		}
		if (aux && sscanf(aux,"%d",&maskcnt) &&
		    (maskcnt >=0) && (maskcnt <+32)) {
			for (mask=0, maskbase=(unsigned int)0x80000000L;
				maskcnt > 0;
				mask|=maskbase,maskbase/=2,maskcnt--);
			sprintf(rule->sourceIpMask,"%d.%d.%d.%d",
				mask>>24,mask>>16 & 0xff,
				mask>>8 & 0xff,mask&0xff);
		} else {
			rule->sourceIpMask[0] = 0x00;
		}
		
		aux = strstr(val9,"/");
		if (aux) *aux++ = 0x00;
		if (val9[0] == 0x21) { // inverted
			rule->destinationIpInvert = kInverted;
			strcpy(rule->destinationIp,&val9[1]);
		} else {
			rule->destinationIpInvert = knotInverted;
			strcpy(rule->destinationIp,val9);
		}
		if (aux && sscanf(aux,"%d",&maskcnt) &&
		    (maskcnt >=0) && (maskcnt <+32)) {
			for (mask=0, maskbase=(unsigned int)0x80000000L;
				maskcnt > 0;
				mask|=maskbase,maskbase/=2,maskcnt--);
			sprintf(rule->destinationIpMask,"%d.%d.%d.%d",
				mask>>24,mask>>16 & 0xff,
				mask>>8 & 0xff,mask&0xff);
		} else {
		       rule->destinationIpMask[0] = 0x00;
		}	       
		
		if (strlen(buffer) > 80) {
			pbuf = &buffer[80];
			pbuf = ParseIpTablesRulesExt(pbuf,rule);
			if (!strcmp(rule->target,"LOG")) {
				// target LOG
				ParseIpTablesRulesLog(pbuf, rule);
			} else {
				if (!strcmp(rule->target,"REJECT")) {
					// target REJECT
					if ((aux = strstr(pbuf,"reject-with"))) {
						aux1 = aux += 12;
						while (*aux && !isspace(*aux)) aux++;
						if (*aux) *aux = 0x00;
						strcpy(rule->RejectWith,aux1);
					}
#ifdef NATTABLE
				} else {
					if (!strcmp(rule->target,"SNAT") ||
						!strcmp(rule->target,"DNAT") ) {
						ParseIpTablesRulesNAT(pbuf,rule);
					} else {
						if (!strcmp(rule->target,"MASQUERADE") ||
						    !strcmp(rule->target,"REDIRECT")) {
								if ((rule->protocol == kTcp) || (rule->protocol == kUdp)) {
								ParseIpTablesRulesMasq(pbuf,rule);
							}
						}
					}
#endif
				}
			}
		}
		numrules++;
		dolog("NumRules: %d", numrules);
		rule++;
	}
	pChain->numrules = numrules;
	fclose(fp);
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
	system(buffer);
	return;
}

static void IpTablesExpandTcpFlags(int flags, char * buf)
{
	char sep;
	
	sep = 0x00;
	if (flags & 0x01) {
		strcat(buf,"FIN");
		sep = 1;
	}	
	if (flags & 0x02) {
		if (sep) strcat(buf,",");
		strcat(buf,"SYN");
		sep = 1;
	}	
	if (flags & 0x04) {
		if (sep) strcat(buf,",");
		strcat(buf,"RST");
		sep = 1;
	}	
	if (flags & 0x08) {
		if (sep) strcat(buf,",");
		strcat(buf,"PSH");
		sep = 1;
	}	
	if (flags & 0x10) {
		if (sep) strcat(buf,",");
		strcat(buf,"ACK");
		sep = 1;
	}	
	if (flags & 0x20) {
		if (sep) strcat(buf,",");
		strcat(buf,"URG");
		sep = 1;
	}
}

static void WrtIpTablesOneRule(char * tablename, char * chainname,
		IpTablesRules *rule)
{
	unsigned char buf[1024], num[100];

	sprintf(buf,"iptables --table %s --append %s ",tablename, chainname);

	executeFlg |= EXE_FIREWALL;
	// Protocol :  -p [!] <tcp/udp/icmp/number>
	if (rule->protocol) {
		strcat(buf," -p ");
		if (rule->protocolInvert == kInverted) {
			strcat(buf," ! ");
		}
		switch (rule->protocol) {
			case kIcmp : strcat(buf,"icmp"); break;
			case kTcp  : strcat(buf,"tcp"); break;
			case kUdp  : strcat(buf,"udp"); break;
			case kNumeric : 
				sprintf(num,"%d",rule->protocolNumber);
				strcat(buf,num); break;
			default: break;
		}
	}

	// Source IP address : -s [!] address[/mask]
	if (rule->sourceIp[0]) {
		strcat(buf, " -s ");
		if (rule->sourceIpInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->sourceIp);
		if (rule->sourceIpMask[0]) {
			strcat(buf,"/");
			strcat(buf,rule->sourceIpMask);
		}
	}
	
	// Destination IP address : -d [!] address[/mask]
	if (rule->destinationIp[0]) {
		strcat(buf, " -d ");
		if (rule->destinationIpInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->destinationIp);
		if (rule->destinationIpMask[0]) {
			strcat(buf,"/");
			strcat(buf,rule->destinationIpMask);
		}
	}
	
	// Input interface : -i [!] name 
	if (rule->inInterface[0]) {
		strcat(buf, " -i ");
		if (rule->inInterfaceInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->inInterface);
	}
	
	// Output interface : -o [!] name 
	if (rule->outInterface[0]) {
		strcat(buf, " -o ");
		if (rule->outInterfaceInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->outInterface);
	}
	
	// Fragment : -f or ! -f
	switch (rule->fragment) {
		case kallPackets : 
			break;
		case konlyFragments :
			strcat(buf," -f ");
			break;
		case knoFragFirstFrag :
			strcat(buf," ! -f ");
      			break;			
	}	

	// jump == target : -j target
	if (rule->target[0]) {
		strcat(buf," -j ");
		strcat(buf,rule->target);
	}

	// tcp/udp extension-source port : --source-port [!] port[:port]
	if (rule->SourcePort[0]) {
		strcat(buf," --source-port ");
		if (rule->SourcePortInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->SourcePort);
		if (rule->LastSourcePort[0]) {
			strcat(buf,":");
			strcat(buf, rule->LastSourcePort);
		}
	}

	// tcp/udp extension-destination port : --destination-port [!] port[:port]
	if (rule->DestinationPort[0]) {
		strcat(buf," --destination-port ");
		if (rule->DestinationPortInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->DestinationPort);
		if (rule->LastDestinationPort[0]) {
			strcat(buf,":");
			strcat(buf, rule->LastDestinationPort);
		}
	}

	// tcp extension-flags : --tcp-flags [SYN,ACK,FIN,..] [SYN,ACK...]
	if (rule->TcpFlags) {
		strcat(buf," --tcp-flags ");
		if (rule->TcpFlagsInvert) {
			strcat(buf," ! ");
		}
		IpTablesExpandTcpFlags(rule->TcpFlags,buf);
		if (rule->TcpFlagsSet) {
			strcat(buf," ");
			IpTablesExpandTcpFlags(rule->TcpFlagsSet,buf);
		}
	}

	// ICMP extension : --icmp-type [!] numeric type
	if (rule->protocol == kIcmp) {
		if (rule->ICMPType[0]) {
			if (strcmp(rule->ICMPType, "all")) { 
				strcat(buf," --icmp-type ");
				if (rule->ICMPTypeInvert) {
					strcat(buf," ! ");
				}
				strcat(buf,rule->ICMPType);
			}
		}
	}
	
	// LOG options - target == LOG
	// --log-level level [--log-prefix prefix] [--log-tcp-sequence] ..
	if (!strcmp(rule->target,"LOG")) {
		sprintf(num," --log-level %d",rule->LogLevel);
		strcat(buf,num);
		if (rule->LogPrefix[0]) {
				strcat(buf," --log-prefix ");
				strcat(buf,rule->LogPrefix);
		}
		if (rule->LogTcpOptions & klogTcpSequence) 
			strcat(buf," --log-tcp-sequence ");
		if (rule->LogTcpOptions & klogTcpOptions)
			strcat(buf," --log-tcp-options ");
		if (rule->LogTcpOptions & klogIpOptions)
			strcat(buf," --log-ip-options ");
	}

	// Reject options : --reject-with
	if (rule->RejectWith[0]) {
		strcat(buf," --reject-with ");
		strcat(buf,rule->RejectWith);
	}	
			
#ifdef NATTABLE
	// SNAT options : --to-source <ipaddr>[-<ipaddr>][:port-port]
	// DNAT options : --to-destination <ipaddr>[-<ipaddr>][:port-port]
	if (rule->NatToIp[0]) {
		if (!strcmp(rule->target,"SNAT")) {
			strcat(buf," --to-source ");
		} else {
			strcat(buf," --to-destination ");
		}
		strcat(buf,rule->NatToIp);
		if (rule->NatToLastIp[0]) {
			strcat(buf,"-");
			strcat(buf,rule->NatToLastIp);
		}
		if ((rule->NatToPort[0]) && 
			(rule->NatToLastPort[0])) {
			sprintf(num,":%s-%s ",rule->NatToPort,rule->NatToLastPort);
			strcat(buf,num);
		}
	} else {
		// Masquerade or Redirect : --to-ports <port>[-<port>]
		if (rule->NatToPort[0]) {
			sprintf(num," --to-ports %s",rule->NatToPort);
			strcat(buf,num);
			if (rule->NatToLastPort[0]) {
				sprintf(num,"-%s",rule->NatToLastPort);
				strcat(buf,num);
			}
		}
	}
#endif
	
	sprintf(num," >%s 2>&1",WEB_TEMP_FILE);
	strcat(buf, num);
	system(buf);
}

static void WrtIpTablesRules(ChainInfo *chain, char *tablename)
{
	unsigned char buffer[250];
	int j;
	IpTablesRules *rule;

	// treatment to rules - delete all chain's rules
	sprintf(buffer,"iptables --table %s --flush %s>%s 2>&1",
				tablename,chain->name,WEB_TEMP_FILE);
	system(buffer);
	for (j=0,rule=chain->rules; 
			j < chain->numrules; j++, rule++) {
			WrtIpTablesOneRule(tablename, chain->name,rule);
	}
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
	system(buffer);
}

static Result RdWrtFilterChainRuleInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	ChainInfo *chain;
	int j;

	dolog("RdWrFilterChainRule rdWrtFlg=%d",rdWrtFlg);
	chain = (ChainInfo *)paramList->value;

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		for (j=0; j<paramList->collectionSize; j++, chain++) {
			WrtIpTablesRules(chain,"filter");
		}
	} else {
		for (j=0; j<paramList->collectionSize; j++, chain++) {
			RdIpTablesRules(chain,"filter");
		}
	}
	return (kCycSuccess);
}

static Result RdWrtNatChainRuleInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	ChainInfo *chain;
	int j;
	dolog("RdWrNatChainRule rdWrtFlg=%d",rdWrtFlg);

	chain = (ChainInfo *)paramList->value;
	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		for (j=0; j<paramList->collectionSize; j++, chain++) {
			WrtIpTablesRules(chain,"nat");
		}
	} else {
		for (j=0; j<paramList->collectionSize; j++, chain++) {
			RdIpTablesRules(chain,"nat");
		}
	}
	return (kCycSuccess);
}

//=======================================================================
// IP Chains Routines
//=======================================================================

//=============================================================================
// GetIpChainsNum : get the number of chains.
// table : system "ipchains --list > WEB_TEMP_FILE" 
// Chain <chain name>
// target .....
// <rules>
// Chain <chain name>
// target ....
// <rules:
//
//=============================================================================
#if LINUX_VERSION_CODE == KERNEL_VERSION(2,2,14)
static void GetIpChainsNum(CycCatKeyTable *pCkIndex, CycParam *paramList)
{
	unsigned char buffer[250];
	int chains=0;
	FILE *fp;

	sprintf(buffer,"ipchains --list > %s",pCkIndex->fileName);
	system(buffer);
	if ((fp = fopen(pCkIndex->fileName, "ro")) != NULL) {
		while (fgets(buffer, sizeof(buffer), fp)) {
			if (!strncmp(buffer, "Chain ",6)) {
				chains++;
				continue;
			}
		}
		fclose(fp);
	}
	sprintf(buffer,"rm -f %s",pCkIndex->fileName);
	system(buffer);
	dolog("GetIpChainsNum chains=%d ",chains);
	*(int *)paramList->value = chains;
}

static void RdIpChainsInfo(CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[250];
	unsigned char val1[50],val2[50],val3[50],val4[50];
	int num,next=0;
	ChainInfo *chain;

	// Read the Table information 
	sprintf(buffer,"ipchains --list --num -v > %s",WEB_TEMP_FILE);
	system(buffer);
	if ((fp = fopen(WEB_TEMP_FILE, "ro")) == NULL) {
		sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
		system(buffer);
		return ;	
	}
	
	chain = (ChainInfo *) paramList->value;
	num = 0;	

	while (fgets(buffer, sizeof(buffer), fp)) {
		if (sscanf(buffer,"Chain %s (policy %s: %s packets, %s bytes)",
			val1, val2, val3, val4)) {
			if (next) {
				chain->numrules = num;
				chain++;
			}
			strcpy(chain->name,val1);
			strcpy(chain->policy,val2);
			strcpy(chain->packets,val3);
			strcpy(chain->bytes, val4);
			next++;
			num = 0;
			continue;
		}
		if (!strncmp(buffer," pkts",5)) continue;
		num++;
	}
	fclose(fp);
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
	system(buffer);
}

static void WrtIpChainsInfo(CycParam *paramList)
{
	unsigned char buffer[250], param[100];
	int numchain, maxchains;
	ChainInfo *chain;

	chain = (ChainInfo *)paramList->value;
	//maxchains = paramList->collectionSize/sizeof(ChainInfo);	
	maxchains = paramList->collectionSize;	
	
	for (numchain=0; numchain < maxchains; numchain++,chain++) {
		memset(buffer, 0, sizeof(buffer));
		memset(param,0,sizeof(param));
		switch (chain->action) {
			case kDelete :
				sprintf(param,"--delete-chain %s ",chain->name);
				break;
			case kAdd :
				sprintf(param,"--new-chain %s",chain->name);
				break;
			case kEdit :
				sprintf(param,"--policy %s %s",chain->name,chain->policy);
				break;
		}
		sprintf(buffer,"ipchains %s >%s 2>&1", param,WEB_TEMP_FILE);
		system(buffer);
		executeFlg |= EXE_FIREWALL;
	}
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
}

static Result RdWrtIpChainsInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	dolog("RdWrChainsInfo rdWrtFlg=%d",rdWrtFlg);

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		WrtIpChainsInfo(paramList);
	} else {
		RdIpChainsInfo(paramList);
	}
	return (kCycSuccess);
}

static void RdIpChainsRules(CycParam *paramList)
{
	FILE *fp;
	unsigned char buffer[250];
	unsigned char val1[50],val2[50],val3[50],val4[50],val5[50];
	unsigned char val6[50],val7[50],val8[50],val9[50];
	unsigned char val10[50],val11[50],val12[50];
	unsigned char *aux,*aux1;
	int numrules, range, num1, num2;
	ChainInfo *chain;
	IpTablesRules *rule;

	chain = (ChainInfo *) paramList->value;
	
	// Read the Chain information 
	sprintf(buffer,"ipchains --list %s --num -v > %s",
				chain->name,WEB_TEMP_FILE);
	system(buffer);
	
	if ((fp = fopen(WEB_TEMP_FILE, "ro")) == NULL) {
		sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
		system(buffer);
		return ;	
	}
	
	rule = (IpTablesRules *) &chain->rules;
	numrules = 0;	

	while (fgets(buffer, sizeof(buffer), fp)) {
		if (!strncmp(buffer,"Chain",5) ||
			!strncmp(buffer," pkts",5)) {
			continue;	
		}
		
		memset((char *)rule,0,sizeof(IpTablesRules));
		memset(rule->SourcePort, 0, sizeof(rule->SourcePort));
		memset(rule->LastSourcePort, 0, sizeof(rule->LastSourcePort));
		memset(rule->DestinationPort, 0, sizeof(rule->DestinationPort));
		memset(rule->LastDestinationPort, 0, sizeof(rule->LastDestinationPort));
		memset(rule->NatToPort, 0, sizeof(rule->NatToPort));
		memset(rule->NatToLastPort, 0, sizeof(rule->NatToLastPort));

		// parse rule
		sscanf(buffer," %s %s %s %s %s %s %s %s %s %s %s -> %s",
			val1, // pkts
			val2, // bytes
			val3, // target
			val4, // prot
			val5, // opt = flag
			val6, // tosa
			val7, // tosx
			val8, // ifname
			val9, // source
			val10, // destination
			val11, // source port
			val12  // destination port
		      );

		strcpy(rule->packets,val1);
		strcpy(rule->bytes,val2);
		strcpy(rule->target,val3);
		
		if (val4[0] == '!') {
			rule->protocolInvert = kInverted;
			aux = &val4[1];
		} else {
			if (val4[0] != '*') {
				rule->protocolInvert = knotInverted;
				aux = val4;
			} else {
				aux = 0;
			}
		}
		
		if (!aux) {
			rule->protocol = 0;
			rule->protocolNumber = 0;
		} else { 
			if (!strcmp(aux,"all")) {
				rule->protocol = kAll;
			} else {
				if (!strcmp(aux,"tcp")) {
					rule->protocol = kTcp;
				} else {
					if (!strcmp(aux,"udp")) {
						rule->protocol = kUdp;
					} else {
						if (!strcmp(aux,"icmp")) {
							rule->protocol = kIcmp;
						} else {
							rule->protocol = kNumeric;
							rule->protocolNumber = atoi(aux);
						}
					}	
				}
			}
		}
		

		// TCP flags - SYN
		if (val5[1] == 'y') {
			rule->TcpFlags = rule->TcpFlagsSet = kTCPFlagsSyn;
			if (val5[0] == '!') {
				rule->TcpFlagsInvert = kInverted;
			}
		}
		
		// Fragment
		if (val5[3] != 'f') {
			rule->fragment = kallPackets;
		} else {
			rule->fragment = konlyFragments;
			if (val5[2] == '!') {
				rule->fragment = knoFragFirstFrag;
			}
		}

		// Interface
		if (val8[0] == '!') {
			rule->inInterfaceInvert = kInverted;
			if (val8[1] != '*') 
				strcpy(rule->inInterface,&val8[1]);
		} else {
			rule->inInterfaceInvert = knotInverted;
			if (val8[0] != '*') 
				strcpy(rule->inInterface,val8);
		}

		aux = strstr(val9,"/");
		if (aux) *aux++ = 0x00;
		if (val9[0] == '!') {
			rule->sourceIpInvert = kInverted;
			strcpy(rule->sourceIp,&val9[1]);
		} else {
			rule->sourceIpInvert = knotInverted;
			strcpy(rule->sourceIp,val9);
		}
		if (aux) {
			strcpy(rule->sourceIpMask,aux);
		} 
		
		aux = strstr(val10,"/");
		if (aux) *aux++ = 0x00;
		if (val10[0] == '!') {
			rule->destinationIpInvert = kInverted;
			strcpy(rule->destinationIp,&val10[1]);
		} else {
			rule->destinationIpInvert = knotInverted;
			strcpy(rule->destinationIp,val10);
		}
		if (aux) strcpy(rule->destinationIpMask,aux);
		

		if (rule->protocol == kIcmp) {
			// icmp type / code
			if (val11[0] == '!') { // invert
				rule->ICMPTypeInvert = kInverted;
				scanf(&val11[1],"%d",&num1);
			} else {	
				sscanf(val11,"%d",&num1);
			}
			if (val12[0] != '*') { // code 
				sscanf(val12,"%d",&num2);
				switch (num1) {
					case 3 :
						strcpy(rule->ICMPType,ICMPType3Code[num2]);
						break;
					case 5 :
						strcpy(rule->ICMPType,ICMPType5Code[num2]);
						break;
					case 11 :
						strcpy(rule->ICMPType,ICMPType11Code[num2]);
						break;
					case 12 :
						strcpy(rule->ICMPType,ICMPType12Code[num2]);
						break;
				}
			} else {
				strcpy(rule->ICMPType,ICMPTypeList[num1]);
			}	
		}
		
		// UDP or TCP : Source Port / Destination Port
		if ((rule->protocol == kTcp) || (rule->protocol == kUdp)) {
			if (val11[0] != '*') { // source port
				aux = val11;
				if (*aux == '!') { // invert
					rule->SourcePortInvert = kInverted;
					aux++;
				} 	
				aux1 = aux;
				while (*aux && isdigit(*aux)) aux++;
				if (*aux == ':') 
					range = 1;
				else
					range = 0;
				if (*aux) *aux++ = 0x00;
				strcpy(rule->SourcePort, aux1);
				if (range) {
					aux1 = aux;
					while (*aux && isdigit(*aux)) aux++;
					if (*aux) *aux++ = 0x00;
					strcpy(rule->LastSourcePort, aux1);
				}
			}
			
			if (val12[0] != '*') { // destination port
				aux = val12;
				if (*aux == '!') { // invert
					rule->DestinationPortInvert = kInverted;
					aux++;
				} 	
				aux1 = aux;
				while (*aux && isdigit(*aux)) aux++;
				if (*aux == ':')
				  	range = 1;
				else
					range =0;
				
				if (*aux) *aux++ = 0x00;
				strcpy(rule->DestinationPort, aux1);
				if (range) {
					aux1 = aux;
					while (*aux && isdigit(*aux)) aux++;
					if (*aux) *aux++ = 0x00;
					strcpy(rule->LastDestinationPort, aux1);
				}
			}
		}

		numrules++;
		rule++;
	}
	chain->numrules = numrules;
	fclose(fp);
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
	system(buffer);
}

static void WrtIpChainsRules(CycParam *paramList)
{
	unsigned char buffer[250];
	int j;
	ChainInfo *chain;
	IpTablesRules *rule;

	chain = (ChainInfo *)paramList->value;

	// treatment to rules - delete all chain's rules
	sprintf(buffer,"ipchains --flush %s>%s 2>&1",chain->name,WEB_TEMP_FILE);
	system(buffer);
	for (j=0,rule=(IpTablesRules *)&chain->rules; 
			j < chain->numrules; j++, rule++) {
		WrtIpChainsOneRule(chain->name,rule);
	}
	sprintf(buffer,"rm -f %s",WEB_TEMP_FILE);
	system(buffer);
}

static Result RdWrtIpChainsRuleInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	dolog("RdWrChainsRule rdWrtFlg=%d",rdWrtFlg);

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		WrtIpChainsRules(paramList);
	} else {
		RdIpChainsRules(paramList);
	}
	return (kCycSuccess);
}

static void WrtIpChainsOneRule(char * chainname, IpTablesRules *rule)
{
	unsigned char buf[1024], num[100];

	sprintf(buf,"ipchains --append %s ",chainname);

	executeFlg |= EXE_FIREWALL;

	// Protocol :  -p [!] <tcp/udp/icmp/number>
	if (rule->protocol) {
		strcat(buf," -p ");
		if (rule->protocolInvert == kInverted) {
			strcat(buf," ! ");
		}
		switch (rule->protocol) {
			case kIcmp : strcat(buf,"icmp");break;
			case kTcp : strcat(buf,"tcp");break;
			case kUdp : strcat(buf,"udp");break;
			case kNumeric : 
				sprintf(num,"%d",rule->protocolNumber);
				strcat(buf,num); break;
			default: break;
		}
	}

	// Source IP address : -s [!] address[/mask]
	if (rule->sourceIp[0]) {
		strcat(buf, " -s ");
		if (rule->sourceIpInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->sourceIp);
		if (rule->sourceIpMask[0]) {
			strcat(buf,"/");
			strcat(buf,rule->sourceIpMask);
		}
	}
	
	// Destination IP address : -d [!] address[/mask]
	if (rule->destinationIp[0]) {
		strcat(buf, " -d ");
		if (rule->destinationIpInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->destinationIp);
		if (rule->destinationIpMask[0]) {
			strcat(buf,"/");
			strcat(buf,rule->destinationIpMask);
		}
	}
	
	// Input interface : -i [!] name 
	if (rule->inInterface[0]) {
		strcat(buf, " -i ");
		if (rule->inInterfaceInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->inInterface);
	}
	
	// Fragment : -f or ! -f
	switch (rule->fragment) {
		case kallPackets : 
			break;
		case konlyFragments :
			strcat(buf," -f ");
			break;
		case knoFragFirstFrag :
			strcat(buf," ! -f ");
      			break;			
	}	

	// jump == target : -j target
	if (rule->target[0]) {
		strcat(buf," -j ");
		strcat(buf,rule->target);
	}

	// tcp/udp extension-source port : --source-port [!] port[:port]
	if (rule->SourcePort[0]) {
		strcat(buf," --source-port ");
		if (rule->SourcePortInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->SourcePort);
		if (rule->LastSourcePort[0]) {
			strcat(buf, rule->LastSourcePort);
		}
	}

	// tcp/udp extension-destination port : --destination-port [!] port[:port]
	if (rule->DestinationPort[0]) {
		strcat(buf," --destination-port ");
		if (rule->DestinationPortInvert) {
			strcat(buf," ! ");
		}
		strcat(buf, rule->DestinationPort);
		if (rule->LastDestinationPort[0]) {
			strcat(buf, rule->LastDestinationPort);
		}
	}

	// tcp extension-flags : --tcp-flags [SYN,ACK,FIN,..] [SYN,ACK...]
	if (rule->TcpFlags) {
		if (rule->TcpFlagsInvert) {
			strcat(buf," ! ");
		}
		strcat(buf," -y ");
				
	}

	// ICMP extension : --icmp-type [!] numeric type
	if (rule->ICMPType[0]) {
		strcat(buf," --icmp-type ");
		if (rule->ICMPTypeInvert) {
				strcat(buf," ! ");
		}
		strcat(buf,rule->ICMPType);
	}
	
	sprintf(num," >%s 2>&1",WEB_TEMP_FILE);
	strcat(buf, num);
	system(buf);
}
#endif

//========================================================================
// RdWrtMenuShInfo: read/write /bin/menush.cfg
//========================================================================
static Result RdWrtMenuShInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	FileBuffer *buf;
	FILE *fp;
	char *line, *shellValue;
	char temp[12]={0};
	int len, i, numOfMenuOptions = 0;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	MenuShInfo *mSh;
	MenuShOpt *opt;

	dolog("RdWrtMenuShInfo()");

	if (rdWrtFlg)
	{
		if ((fp = fopen(pCkIndex->fileName, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);	
			return (kFileWriteError);
		}
		mSh = (MenuShInfo *)paramList->value;
		fprintf(fp,"MENU_TITLE=\"%s\"\n", mSh->menuTitle);
		fprintf(fp,"MENU_NBR=%d\n", mSh->numOptions);
		opt = mSh->optInfo;
		for (i=0; i<mSh->numOptions; i++, opt++) {
			fprintf(fp, "MENU_OPT%d=\"%s%%%s\"\n", i+1, opt->title, opt->command);
		}
		fclose(fp);
		return (kCycSuccess);
	}
	else 
	{
		if ((buf = read_file(pCkIndex->fileName)) == NULL) {
				LogError(FILE_READ_ERROR, pCkIndex->fileName);	
				return(kFileReadError);
		}

		if ((paramList->key == kMenuShInfo || paramList->key == kMenuShTitle) 
			&& (line = search_var(buf, "MENU_TITLE", 0)) != NULL) 
		{
			mSh = (MenuShInfo *)paramList->value;
			get_value_from_config_line(line, buf, &shellValue, &len, 0);
			len = (len < kTitleLength) ? len : (kTitleLength -1);
			memcpy(mSh->menuTitle, shellValue, len);
			if (paramList->key == kMenuShTitle)
				goto exit_rot;
		}

		if ((line = search_var(buf, "MENU_NBR", 0)) != NULL) 
		{
			get_value_from_config_line(line, buf, &shellValue, &len, 0);
			strncpy(temp, shellValue, len);
			numOfMenuOptions = atoi(temp);
			dolog("Number of options: [%d]", numOfMenuOptions);
			if (pCkIndex->key == kNumMenuShOpt) {
				*(int *)paramList->value = numOfMenuOptions;			
				goto exit_rot;
			}
		}

		opt = mSh->optInfo;
		for (i=0; i<numOfMenuOptions; i++, opt++) {
			ParseMenuOpt(buf, &opt, i);
		}
	}

exit_rot:

	free(buf);
	return (kCycSuccess);
}

static void delete_line(char *line, FileBuffer *buf)
{
	char *s;
	for (s = line; s - buf->buf < buf->len && *s; s++) {
		if (*s == '\r' || *s == '\n') {
			s ++;
			if (*s == '\r' || *s == '\n') s ++;
			break;
		}
	}
	memmove(line, s, buf->len - (s - buf->buf));
	buf->len -= s - line;
}

//========================================================================
// RdWrtLdapInfo: read/write ldap configurations in /etc/ldap.conf
//========================================================================
static Result RdWrtLdapInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	FileBuffer *buf;
	char *line, *shellValue;
	char optLine[BUF_CUSHION1]={0};
	char temp[BUF_CUSHION1]={0};
	int flgIns, len;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	LdapInfo ldap = {{0}}, *pLdap;

	dolog("RdWrtLdapInfo()");

	if ((buf = read_file(pCkIndex->fileName)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	if (rdWrtFlg) {
		pLdap = (LdapInfo *)paramList->value;
	}

	if ((line = search_var(buf, "host", 0)) != NULL) 
	{	
		if (rdWrtFlg) {
			replace_Value(line, buf, pLdap->ldapServer, 1);
		} else {
			get_value_from_config_line(line, buf, &shellValue, &len, 2);
			len = (len < kDomainNameLength) ? len : (kDomainNameLength-1);
			strncpy(ldap.ldapServer, shellValue, len);
			dolog("Ldap Server: [%s]", ldap.ldapServer);
		}
	} else {
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			sprintf(temp, "host %s\n", pLdap->ldapServer);	
			insert_line(line, buf, temp, flgIns);
		}
	}

	if ((line = search_var(buf, "base", 0)) != NULL) 
	{	
		if (rdWrtFlg) {
			replace_Value(line, buf, pLdap->ldapBase, 1|4);
		} else {
			get_value_from_config_line(line, buf, &shellValue, &len, 2|4);
			len = (len < kLdapDomainNameLength) ? len : (kLdapDomainNameLength-1);
			strncpy(ldap.ldapBase, shellValue, len);
			dolog("Ldap Base: [%s]", ldap.ldapBase);
		}
	} else {
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			sprintf(temp, "base %s\n", pLdap->ldapBase);	
			insert_line(line, buf, temp, flgIns);
		}
	}

	line = search_var(buf, "uri ldaps:", 0);
	if (rdWrtFlg) {
		if (! pLdap->secure) {
			if (line) {
				delete_line(line, buf);
			}
		} else {
			sprintf(optLine, "ldaps://%s/", pLdap->ldapServer);
			if (line) {
				replace_Value(line, buf, optLine, 1);
			} else {
				line = buf->buf;
				sprintf(temp, "uri %s\n", optLine);
				insert_line(line, buf, temp, 2);
			}
		}
	} else {
		ldap.secure = kNo;
		if (line) {
			get_value_from_config_line(line, buf, &shellValue, 
				&len, 2);
			if (strstr(shellValue, ldap.ldapServer)) {
				ldap.secure = kYes;
			}
		}
	}


#if 1
	if ((line = search_var(buf, "binddn", 0)) != NULL) 
	{	
		if (rdWrtFlg) {
			replace_Value(line, buf, pLdap->ldapUser, 1|4);
		} else {
			get_value_from_config_line(line, buf, &shellValue, &len, 2|4);
			len = (len < kLdapDomainNameLength) ? len : (kLdapDomainNameLength-1);
			strncpy(ldap.ldapUser, shellValue, len);
			dolog("Ldap User: [%s]", ldap.ldapUser);
		}
	} else {
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			sprintf(temp, "binddn %s\n", pLdap->ldapUser);	
			insert_line(line, buf, temp, flgIns);
		}
	}
#else

	/* User name: it can be represented by Administrator.Users@cyclades.com,
	or simply Administrator.Users. In these cases, the binddn parameter 
	will be cn=Administrator,cn=Users,dc=cyclades,dc=com */
	line = search_var(buf, "binddn", 0);
	if (rdWrtFlg) {
		if (! *pLdap->ldapUser) {
			if (line != NULL) {
				delete_line(line, buf);
			}
		} else {
			*optLine = 0; 
			domain = 0;
			straux = strdup(pLdap->ldapUser);
			a = s = straux;
			while (*a) {
				while (*a && *a != '.' && *a != '@') a++;
				if (domain) {
					strcat(optLine, "dc=");
				} else {
					strcat(optLine, "cn=");
				}
				if (*a == '@') domain = 1;
				if (*a) *a++=0;
				strcat(optLine, s);
				s = a;
				if (*a) strcat(optLine, ",");
			}
			free(straux);
			if (! domain) {
				straux = strdup(pLdap->ldapBase);
				a = s = straux;
				strcat(optLine, ",");
				while (*a) {
					while (*a && *a != '.') a++;
					if (*a) *a++=0;
					strcat(optLine, "dc=");
					strcat(optLine, s);
					s = a;
					if (*a)	strcat(optLine, ",");
				}
				free(straux);
			}
			if (line != NULL) {
				replace_Value(line, buf, optLine, 1);
			} else {
				line = buf->buf;
				sprintf(temp, "binddn %s\n", optLine);
				insert_line(line, buf, temp, 2);
			}
		}
	} else {
		if (line != NULL) {
			get_value_from_config_line(line, buf, &shellValue, 
				&len, 2);
			strncpy(optLine, shellValue, len);
			a = s = optLine;
			domain = 0;
			while (*a) {
				s = strchr(a, '=');
				if (!s) break;
				if ((s - a) < 2) break;
				if (((*(s-2) & 0xdf) != 'C' || 
					(*(s-1) & 0xdf) != 'N') && 
					((*(s-2) & 0xdf) != 'D' || 
					(*(s-1) & 0xdf) != 'C')) {
					break;
				}
				if ((*(s-2) & 0xdf) == 'D' && domain == 0) {
					ldap.ldapUser[strlen(ldap.ldapUser) - 
						1] = '@';
					domain = 1;
				}
				a = ++s;
				while (*a && *a != ',') a++;
				if (*a) *a++ = 0;
				strcat(ldap.ldapUser, s);
				if (*a) strcat(ldap.ldapUser, ".");
			}
			dolog("Ldap User: [%s]", ldap.ldapUser);
		} else {
			*(ldap.ldapUser) = 0;
		}
	}
#endif
	/* LDAP password */
	line = search_var(buf, "bindpw", 0);
	if (rdWrtFlg) {
		if (! *pLdap->ldapPassword) {
			if (line != NULL) {
				delete_line(line, buf);
			}
		} else {
			if (line != NULL) {
	      			replace_Value(line, buf, pLdap->ldapPassword, 
					1);
			} else {
				line = buf->buf;
				flgIns=2;
				sprintf(temp, "bindpw %s\n", 
					pLdap->ldapPassword);	
				insert_line(line, buf, temp, flgIns);
			}

		}
	} else {
		if (line != NULL) {
			get_value_from_config_line(line, buf, &shellValue, 
				&len, 2);
			len = (len < kPasswordLength) ? len : (kPasswordLength-1);
			strncpy(ldap.ldapPassword, shellValue, len);
			dolog("Ldap Password: [%s]", ldap.ldapPassword);
		} else {
			*(ldap.ldapPassword) = 0;
		}
	}

	/* Login Attribute */
	line = search_var(buf, "pam_login_attribute", 0);
	if (rdWrtFlg) {
		if (! *pLdap->ldapLoginAttribute) {
			if (line != NULL) {
				delete_line(line, buf);
			}
		} else {
			if (line != NULL) {
	      			replace_Value(line, buf, 
					pLdap->ldapLoginAttribute, 1);
			} else {
				line = buf->buf;
				sprintf(temp, "pam_login_attribute %s\n", 
					pLdap->ldapLoginAttribute);
				insert_line(line, buf, temp, 2);
			}

		}
	} else {
		if (line != NULL) {
			get_value_from_config_line(line, buf, &shellValue, 
				&len, 2);
			len = (len < kDomainNameLength) ? len : (kDomainNameLength-1);
			strncpy(ldap.ldapLoginAttribute, shellValue, len);
			dolog("Ldap Login Attribute: [%s]", 
				ldap.ldapLoginAttribute);
		} else {
			*(ldap.ldapLoginAttribute) = 0;
		}
	}

	if (rdWrtFlg) {
		write_file(buf, pCkIndex->fileName);
#if defined(KVM) || defined(ONS)
		executeFlg |= EXE_SIGHUP_KVM;
#endif
	} else {
		memcpy(paramList->value, &ldap, sizeof(ldap));
	}
  free(buf);
  return(kCycSuccess);
}

//========================================================================
// RdWrtKrbInfo: read/write kerberos configurations in /etc/krb5.conf
//========================================================================
static Result RdWrtKrbInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	FileBuffer *buf;
  char *line, *line2, *line3, *shellValue, *dn=NULL, *ip=NULL, *s;
  char optLine[BUF_CUSHION1]={0};
	char temp[BUF_CUSHION1]={0};
  int flgIns, len;
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	KrbInfo krb = {{0}}, *pKrb;

	dolog("RdWrtKrbInfo()");

	if ((buf = read_file(pCkIndex->fileName)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	if (rdWrtFlg) {
		pKrb = (KrbInfo *)paramList->value;
	}

	if ((line = search_var(buf, "[libdefaults]", 0)) != NULL) 
	{	
		if ((line2 = search_var_within_section(line, buf, "default_realm", 0)) != NULL) {
			if (rdWrtFlg) {
				replace_Value(line2, buf, pKrb->krbDomainName, 0);
			} else {
				get_value_from_config_line(line2, buf, &shellValue, &len, 1);
				len = (len < kDomainNameLength) ? len : (kDomainNameLength-1);
				strncpy(krb.krbDomainName, shellValue, len);
				dn = krb.krbDomainName;
				//dolog("domain name 1: [%s]", krb.krbDomainName);
			}
		}
	} else { 
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			sprintf(temp, "[libdefaults]\n default_realm = %s\n\n", pKrb->krbDomainName);
			insert_line(line, buf, temp, flgIns);
			memset(temp, 0, sizeof(temp));
		}
	}

	if ((line = search_var(buf, "[realms]", 0)) != NULL) 
	{
		if (rdWrtFlg) {
      flgIns = 1;
			sprintf(optLine, " %s = {\n", pKrb->krbDomainName);
      replace_line(line, buf, optLine, 1, flgIns);
			if ((line2 = search_var_within_section(line, buf, pKrb->krbDomainName, 0)) != NULL) {
				if ((line3 = search_var_within_section(line2, buf, "default_domain", 0)) != NULL) {
					replace_Value(line3, buf, pKrb->krbDomainName, 0);
				}
			}
		} 
		if (!rdWrtFlg) {
			if (dn!=NULL && (line2 = search_var_within_section(line, buf, krb.krbDomainName, 0)) != NULL) {
				if ((line3 = search_var_within_section(line2, buf, "default_domain", 0)) != NULL) {
					get_value_from_config_line(line3, buf, &shellValue, &len, 1);
					len = (len < kDomainNameLength) ? len : (kDomainNameLength-1);
					strncpy(temp, shellValue, len);
					if (strcmp(temp, krb.krbDomainName)!=0) {
						memset(krb.krbDomainName,0, sizeof(krb.krbDomainName));
					}
					memset(temp, 0, sizeof(temp));
					//dolog("domain name 2: [%s]", krb.krbDomainName);
				}
			} else {
				memset(krb.krbDomainName,0, sizeof(krb.krbDomainName));
			}
		}

		if (line2!=NULL && (line3 = search_var_within_section(line2, buf, "kdc", 0)) != NULL) {
			if (rdWrtFlg) {
				sprintf(temp, "%s:88", pKrb->krbServer);
				replace_Value(line3, buf, temp, 0);
			} else {
				get_value_from_config_line(line3, buf, &shellValue, &len, 1);
				strncpy(temp, shellValue, len);
				s = strchr(temp, ':');
				if (*s) *s=0;
				len = strlen(temp);
				len = (len < kDomainNameLength) ? len : (kDomainNameLength-1);
				strcpy(krb.krbServer, temp);
				ip = krb.krbServer;
				dolog("krb.krbServer: [%s]", krb.krbServer);
			}
			memset(temp, 0, sizeof(temp));
		} 

		if (line2!=NULL && (line3 = search_var_within_section(line2, buf, "admin_server", 0)) != NULL) {
			if (rdWrtFlg) {
				sprintf(temp, "%s:749", pKrb->krbServer);
				replace_Value(line3, buf, temp, 0);
			} else {
				get_value_from_config_line(line3, buf, &shellValue, &len, 1);
				strncpy(temp, shellValue, len);
				s = strchr(temp, ':');
				if (*s) *s=0;
				if (ip!=NULL && (strcmp(temp, krb.krbServer)!=0)) { 
					memset(krb.krbServer,0, sizeof(krb.krbServer));
				}
				//dolog("Krb server 2: [%s]", krb.krbServer);
			}
			memset(temp, 0, sizeof(temp));
		}
	} else {
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			sprintf(temp, "[realms]\n %s = {\n  kdc = %s:88\n  admin_server = %s:749\n  default_domain = %s\n }\n\n", 
							pKrb->krbDomainName, pKrb->krbServer, pKrb->krbServer, pKrb->krbDomainName);
			insert_line(line, buf, temp, flgIns);
			memset(temp, 0, sizeof(temp));
		} else {
			memset(krb.krbDomainName, 0, sizeof(krb.krbDomainName));
		}
	}

	if ((line = search_var(buf, "[domain_realm]", 0)) != NULL) 
	{
		if (rdWrtFlg)
		{
      flgIns = 1;
			sprintf(optLine, " .%s = %s\n %s = %s\n", pKrb->krbDomainName, 
				pKrb->krbDomainName, pKrb->krbDomainName, pKrb->krbDomainName);   
      replace_line(line, buf, optLine, 2, flgIns);
		} else { 
			if (dn!=NULL && (line2 = search_var_within_section(line, buf, krb.krbDomainName, 0)) != NULL) {
				get_value_from_config_line(line2, buf, &shellValue, &len, 1);
				strncpy(temp, shellValue, len);
				if (strcmp(temp, krb.krbDomainName)!=0)
					memset(krb.krbDomainName,0, sizeof(krb.krbDomainName));
				memset(temp, 0, sizeof(temp));
				//dolog("domain name 3: [%s]", krb.krbDomainName);
			}
			if (dn!=NULL) 
				sprintf(optLine, ".%s", krb.krbDomainName);
			if (dn!=NULL && (line2 = search_var_within_section(line, buf, optLine, 0)) != NULL) {
				get_value_from_config_line(line2, buf, &shellValue, &len, 1);
				strncpy(temp, shellValue, len);
				if (strcmp(temp, krb.krbDomainName)!=0)
					memset(krb.krbDomainName,0, sizeof(krb.krbDomainName));
				memset(temp, 0, sizeof(temp));
				dolog("Krb DName4: [%s]", krb.krbDomainName);
			}
		}
	} else {
		if (rdWrtFlg) {
			line = buf->buf;
			flgIns=2;
			sprintf(temp, "[domain_realm]\n .%s = %s\n %s = %s\n\n", 
				pKrb->krbDomainName, pKrb->krbDomainName, pKrb->krbDomainName, pKrb->krbDomainName);
			insert_line(line, buf, temp, flgIns);
			memset(temp, 0, sizeof(temp));
		} else {
			memset(krb.krbDomainName, 0, sizeof(krb.krbDomainName));
		}
	}

	if (rdWrtFlg) {
		write_file(buf, pCkIndex->fileName);
#if defined(KVM) || defined(ONS)
		executeFlg |= EXE_SIGHUP_KVM;
#endif
	} else {
		memcpy(paramList->value, &krb, sizeof(krb));
	}
  free(buf);
  return(kCycSuccess);
}

//========================================================================
// WriteSyslogBufServerEntries: write syslog server for buffering 
// configurations into /etc/syslog-ng/syslog-ng.conf
//========================================================================
static void WriteSyslogBufServerEntries(FILE *fp, unsigned char *conf, 
				SyslogBufServerInfo *entries)
{
	unsigned char *inl, *s, *sl;
	SyslogBufServerInfo *info = entries;
	
	dolog("WriteSyslogBufServerEntries()");
	
	inl = s = conf;
	while (*s) {
		
		while (*s && isspace(*s)) s++;
		if (*s == 0x0A) { // if line feed
			s++;
			continue;
		}
		inl = s;
		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			fwrite(inl, (s-inl)+1,1,fp); //write out line
			if (*s) s++;
			continue;
		}
		while (*s && isspace(*s)) s++;
		
		sl = s;
		s = strstr(sl,"};");
		if (!s) break;
		*s++ = 0x00;

		if (!(strstr(sl,"destination dbufserver")) &&
		    !(strstr(sl,"filter fbufserver")) &&
			!(strstr(sl,"log { source(src_dev_log); filter(fbufserver); destination(dbufserver)"))){
			*(s-1) = 0x7d; // put "}" character
			while (*s && *s!='\n') s++;
			fwrite(inl, (s-inl)+1,1,fp);
		}
		if (*s) s++;  // s pointer to next register
	}

	// add new entry
	if (info->SyslogBufServer[0]) {
		fprintf(fp,"filter fbufserver { facility(local%d); };\n", info->dbFacilityNum);
		fprintf(fp,"destination dbufserver { udp(\"%s\" port(514)); };\n", info->SyslogBufServer);
		fprintf(fp,"log { source(src_dev_log); filter(fbufserver); destination(dbufserver); };\n");
	}
}

static void ReadSyslogBufServerEntries(unsigned char *conf, SyslogBufServerInfo *entries)
{
	int facilityNum;
	unsigned char *s, *sl, ServerName[kServerLength];
	SyslogBufServerInfo *info = entries;
	
	dolog("ReadSyslogBufServerEntries()");
	
	s=conf;
	while (*s) {
		while (*s && isspace(*s)) s++;

		if (*s == 0x0A) {  //line feed
			s++;
			continue;
		}

		if (*s == 0x23) { // # comments
			while (*s && *s!='\n') s++;
			if (*s) s++;
			continue;
		}
		
		while (*s && isspace(*s)) s++;
		
		sl = s; //beginning of line
		s = strstr(sl,"};"); //search for };
		if (!s) return;
		*s++ = 0x00; // end of one register or valid config line in syslog-ng.conf
		if (sscanf(sl, "destination dbufserver { udp(\"%s\"", ServerName)) {
			dolog("read Server[%s]", ServerName);
			//info->ServerId = ServerId;
			ServerName[strlen(ServerName)-1]=0x00;
			strcpy(info->SyslogBufServer,ServerName);
		}

		if (sscanf(sl,"filter fbufserver { facility(local%d)", &facilityNum)) { 
			// it is filter's notification
			dolog("filter - facilityNum = %d", facilityNum);
			info->dbFacilityNum = facilityNum;
		}
		while (*s && *s!='\n') s++;
		if (*s) s++;  // s pointer to next register
	}
}

//=============================================================================
// RdWrtSyslogBufServerEntry - Read/Write remote syslog buf server in 
// /etc/syslog-ng/syslog-ng.conf
//=============================================================================
static Result RdWrtSyslogBufServerEntry(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp;	// /etc/syslog-ng/syslog-ng.conf
	unsigned char *buf;

	dolog("RdWrtSyslogBufServerEntry");

	/* we will first read the file in a buffer */
	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		fp = fopen (pCkIndex->fileName, "w");
		WriteSyslogBufServerEntries(fp, buf,(SyslogBufServerInfo *)paramList->value);	
		fclose(fp);
		executeFlg |= EXE_DAEMON_SH;
	} else {  
		ReadSyslogBufServerEntries(buf, (SyslogBufServerInfo *)paramList->value);	
	}
	free(buf);
	return (kCycSuccess);	
}

//=============================================================================
// RdWrtSmbInfo - Read/Write smb Configuration in 
// /etc/tacplus.conf
//=============================================================================
static Result RdWrtSmbInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp = NULL;	
	SmbInfo *pSmb = (SmbInfo *)paramList->value;
	unsigned char *buf = NULL, *s, *line;
	int linenum = 0;
	

	dolog("RdWrtSmbInfo");

	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		dolog("error reading the file");
		return(kFileReadError);
	}
	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		dolog("%s[%d], domain=%s, server1=%s, server2=%s",
			__FUNCTION__, __LINE__, pSmb->domain, pSmb->server,
			pSmb->server2);
		fp = fopen (pCkIndex->fileName, "w");
		fprintf(fp,"%s\n",pSmb->domain);
		fprintf(fp,"%s\n",pSmb->server);
		fprintf(fp,"%s\n",pSmb->server2);
#if defined(KVM) || defined(ONS)
		executeFlg |= EXE_SIGHUP_KVM;
#endif
	} else {  
		memset(pSmb, 0, sizeof (SmbInfo));
		s = buf;
		while (*s) {
			linenum++;
			line = s;
			while (*s && (*s!='\n')) s++;
			if (*s) *s++ = 0;
			switch (linenum) {
				case 1:
					strcpy(pSmb->domain, line);
					break;
				case 2:
					strcpy(pSmb->server, line);
					break;
				case 3:
					strcpy(pSmb->server2, line);
					break;
				default:
					break;
			}
		}
	}
	if (fp) {
		fclose(fp);
	}
	if (buf) {
		free (buf);
	}
	return (kCycSuccess);
}
//=============================================================================
// RdWrtTacplusInfo - Read/Write Tacplus Configuration in 
// /etc/tacplus.conf
//=============================================================================
static Result RdWrtTacplusInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp = NULL;
	TacplusInfo *pTacplus = (TacplusInfo *)paramList->value;
	unsigned char *buf = NULL, *s, *line;
	
	dolog("RdWrtTacplusInfo");

	if ((buf = ReadFile(pCkIndex->fileName, rdWrtFlg)) == NULL) {
		LogError(FILE_READ_ERROR, pCkIndex->fileName);
		dolog("error reading the file");
		return(kFileReadError);
	}
	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		fp = fopen (pCkIndex->fileName, "w");
		s = buf;
		while (*s) {
			line = s;
			while (*s && (*s!='\n')) s++;
			if (*s) *s++ = 0;
			if (!strncmp(line, "authhost1=", 10)) {
				continue;
			}
			if (!strncmp(line, "authhost2=", 10)) {
				continue;
			}
			if (!strncmp(line, "accthost1=", 10)) {
				continue;
			}
			if (!strncmp(line, "accthost2=", 10)) {
				continue;
			}
			if (!strncmp(line, "secret=", 7)) {
				continue;
			}
			if (!strncmp(line, "service=", 8)) {
				continue;
			}
			if (!strncmp(line, "timeout=", 8)) {
				continue;
			}
			if (!strncmp(line, "retries=", 8)) {
				continue;
			}
			fprintf(fp,"%s\n",line);
		}
		if (pTacplus->authServer[0]) {
			fprintf(fp,"authhost1=%s\n",pTacplus->authServer);
		}
		if (pTacplus->auth2Server[0]) {
			fprintf(fp,"authhost2=%s\n",pTacplus->auth2Server);
		}
		if (pTacplus->accServer[0]) {
			fprintf(fp,"accthost1=%s\n",pTacplus->accServer);
		}
		if (pTacplus->acc2Server[0]) {
			fprintf(fp,"accthost2=%s\n",pTacplus->acc2Server);
		}
		if (pTacplus->secret[0]) {
			fprintf(fp,"secret=%s\n",pTacplus->secret);
		}

		(! pTacplus->raccess)?fprintf(fp,"service=ppp\n"):fprintf(fp,"service=raccess\n");

		if (pTacplus->timeout) {
			fprintf(fp,"timeout=%d\n",pTacplus->timeout);
		}
		if (pTacplus->retries) {
			fprintf(fp,"retries=%d\n",pTacplus->retries);
		}

#if defined(KVM) || defined(ONS)
		executeFlg |= EXE_SIGHUP_KVM;
#endif
	} else {  
		memset(pTacplus, 0, sizeof (TacplusInfo));
		s = buf;
		while (*s) {
			line = s;
			while (*s && (*s!='\n')) s++;
			if (*s) *s++ = 0;
			dolog("line = %s", line);
			if (!strncmp(line, "authhost1=", 10)) {
				strncpy(pTacplus->authServer, line+10, kHostNameLength-1);
				dolog("authServer = %s", pTacplus->authServer);		
			} else if (!strncmp(line, "authhost2=", 10)) {
				 strncpy(pTacplus->auth2Server, line+10, kHostNameLength-1);
				dolog("auth2Server = %s", pTacplus->auth2Server);		
			} else if (!strncmp(line, "accthost1=", 10)) {
				strncpy(pTacplus->accServer, line+10, kHostNameLength-1);
				dolog("accServer = %s", pTacplus->accServer);		
			} else if (!strncmp(line, "accthost2=", 10)) {
				strncpy(pTacplus->acc2Server, line+10, kHostNameLength-1);
				dolog("acc2Server = %s", pTacplus->acc2Server);		
			} else if (!strncmp(line, "secret=", 7)) {
				strncpy(pTacplus->secret, line+7, kPasswordLength-1);
				dolog("secret = %s", pTacplus->secret);		
			} else if (!strncmp(line, "service=", 8)) {
                                if(!strncmp(line+8,"raccess",7)) {
        				pTacplus->raccess=1;
	                                dolog("service = raccess\n");
				} else {
        				pTacplus->raccess=0;
     					dolog("service = ppp\n");
				}
			} else if (!strncmp(line, "timeout=", 8)) {
				pTacplus->timeout=atoi(line+8);
				dolog("timeout = %d", pTacplus->timeout);		
			} else if (!strncmp(line, "retries=", 8)) {
				pTacplus->retries=atoi(line+8);
				dolog("retries = %d", pTacplus->retries);		
			} else {
				continue;
			}
		}
	}
	fflush(stdout);
	if (fp) {
		fclose(fp);
	}

	if (buf) {
		free(buf);
	}
	return (kCycSuccess);	
}
//=============================================================================
// RdWrtRadiusInfo - Read/Write Radius Configuration in 
// /etc/raddb/server
//=============================================================================
static Result RdWrtRadiusInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pCkIndex = (CycCatKeyTable *)ptr;
	FILE *fp;	// /etc/portslave/pslave.conf
	RadiusInfo *pRadius = (RadiusInfo *)paramList->value;
	int timeout, retries;
	char server[kServerLength], srv_type[kServerLength], secret[kServerLength];
	char buf[1024], *p;
	

	dolog("RdWrtRadiusInfo");
#if 0
	/* we will first read the file in a buffer */

	if ((buf = read_file(pCkIndex->fileName)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pCkIndex->fileName);	
		return(kFileReadError);
	}
#endif

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) {
		if ((fp = fopen (pCkIndex->fileName, "w")) == NULL) {
			LogError(FILE_WRITE_ERROR, pCkIndex->fileName);
			return(kFileWriteError);
		}

		if (pRadius->authServer[0]) {
			fprintf(fp,"auth1 %s %s %d %d\n",pRadius->authServer,
				pRadius->secret[0] ? pRadius->secret : "secret",
				pRadius->timeout, pRadius->retries);
		}
		if (pRadius->auth2Server[0]) {
			fprintf(fp,"auth2 %s %s %d %d\n",pRadius->auth2Server,
                pRadius->secret[0] ? pRadius->secret : "secret",
                pRadius->timeout, pRadius->retries);
		}
		if (pRadius->accServer[0]) {
			fprintf(fp,"acct1 %s %s %d %d\n",pRadius->accServer,
                pRadius->secret[0] ? pRadius->secret : "secret",
                pRadius->timeout, pRadius->retries);
		}
		if (pRadius->acc2Server[0]) {
			fprintf(fp,"acct2 %s %s %d %d\n",pRadius->acc2Server,
                pRadius->secret[0] ? pRadius->secret : "secret",
                pRadius->timeout, pRadius->retries);
		}
#if 0
		if (pRadius->secret[0]) {
			fprintf(fp,"all.secret %s\n",pRadius->secret);
		}
		fprintf(fp,"all.radtimeout %d\n",pRadius->timeout);
		fprintf(fp,"all.radretries %d\n",pRadius->retries);
#endif

//		executeFlg |= EXE_SIGNAL_RAS; 
#if defined(KVM) || defined(ONS)
		executeFlg |= EXE_SIGHUP_KVM;
#endif
	} else {  
		timeout = 3;
		retries = 5;
    	if ((fp = fopen(pCkIndex->fileName, "r")) != NULL) {
			memset(pRadius, 0, sizeof (RadiusInfo));
        	while (!feof(fp) &&
            	(fgets (buf, sizeof(buf), fp) != NULL) &&
            	!ferror(fp)) {
            	p = buf;
				while (*p &&
       				((*p == ' ') || (*p == '\t') ||
        			(*p == '\r') || (*p == '\n'))) p++;
 
            	if ((!*p) || (*p == '#')) {
					continue;
				}	
				if (sscanf(p, "%s %s %s %d %d", srv_type, server,
						secret, &timeout, &retries) < 3) {
					dolog("error reading %s ", pCkIndex->fileName);
					continue;
				}
				if (secret[0]) {	
					strncpy(pRadius->secret, secret, kPasswordLength-1);
				}
				pRadius->timeout = timeout;
				pRadius->retries = retries;
				
				if (strncmp(srv_type, "auth1", 5) == 0) {
					strncpy(pRadius->authServer, server, kHostNameLength-1);
				} else if (strncmp(srv_type, "auth2", 5) == 0) {
					strncpy(pRadius->auth2Server, server, kHostNameLength-1);
				} else if (strncmp(srv_type, "acct1", 5) == 0) {
					strncpy(pRadius->accServer, server, kHostNameLength-1);
				} else if (strncmp(srv_type, "acct2", 5) == 0) {
					strncpy(pRadius->acc2Server, server, kHostNameLength-1);
				}
			}
		}
	}
	fclose(fp);
	return (kCycSuccess);	
}
static Result RemSpecPslaveParam(CycCatKeyTable *pkey)
{
	FILE * fp;
	unsigned char *buf, *pbl, *pel, cmd[250];
	int port;
	
	// Read the file pslave.conf and writes it to the buffer 
	if ((buf = ReadFile(pkey->fileName, 1)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pkey->fileName);	
		return(kFileReadError);
	}

	// Open the file to begin writing
	if ((fp = fopen(pkey->fileName, "w")) == NULL)
	{
		LogError(FILE_WRITE_ERROR, pkey->fileName);	
		free(buf);
		return (kFileWriteError);
	}
	
	pbl = buf;
	while (*pbl) {
		pel = pbl;
		while (*pel && (*pel != '\n')) pel++;
		if (*pel)  *pel++ = 0x00;
		if (sscanf(pbl,"s%d.%s ",&port,cmd) != 2) {
			fprintf(fp,"%s\n",pbl);
		} else { 
			if (!strcmp(cmd,"tty"))	{
				fprintf(fp,"%s\n",pbl);
			} else {
				while (*(pel-2) == '\\') {
					while (*pel && (*pel != '\n'))
						pel++;
					if (*pel) pel++;
				}
			}
		}
		pbl = pel;
	}
	fclose(fp);
	free(buf);
	return(kCycSuccess);
}

//====================================================================================
// WritePhysPortConf: write Physical Port configurations in /etc/portslave/pslave.conf
//====================================================================================
//[RK]Jan/18/06 - include OTP/LOCAL
static unsigned char *accessAuthName[] = 
{ "none", "local","remote", "radius","TacacsPlus","ldap","local/radius","radius/local","local/TacacsPlus","TacacsPlus/local","RadiusDownLocal","TacacsPlusDownLocal","ldapDownLocal","ldapDownLocal-radius","ldap/local","kerberos","kerberos/local","kerberosDownLocal","otp", "otp/local", "local", "local", "local", "local",};

static int accessAuthtypeList[] =
{ 0, 128, 16, 4096, 8192, 16384, 32769, 4097, 32770, 8193, 4098, 8194, 16386, 16387, 16385, 12288, 12289, 12290, 6, 7, 20480, 20481, 20842,32773,};

#define NumAccessAuthType	19	

static unsigned char *serialFlowName[] = {"none", "hard", "soft"};
static unsigned char *serialParityName[] = {"none", "odd", "even"};

static unsigned char *musName[] = {"no", "yes", "RW_session","","sniff_session"};
static unsigned char *musSnifModeName[] = {"out", "in", "i/o", "no"};
static unsigned char *musNotifUserName[] = {"off", "on"};

static unsigned char *dataBufModeName[] = {"cir", "lin"};

static unsigned char *generalProtocolName[] = 
	{"login", "rlogin", "telnet", "telnet_bidirect", "ssh", "ssh2", "slip",
	 "cslip", "ppp", 
	 "ppp_only", "socket_client", "socket_server", "socket_ssh", "raw_data",
	 "socket_server_ssh", "ipdu","modbus","billing"};
static unsigned char generalProtocolList[] =
	{ P_LOCAL, P_RLOGIN, P_TELNET, P_TELNET_BIDIRECT, P_SSH, P_SSH2, P_SLIP,
	P_CSLIP, P_PPP, P_PPP_ONLY, P_SOCKET_CLIENT, P_SOCKET_SERVER, P_SOCKET_SSH,
	P_SOCKET_SERVER_RAW, P_SOCKET_SERVER_SSH, P_IPDU, P_MODBUS, P_BILLING,};
#define NumGeneralProtocol	18	

static unsigned char *PhysParam [] =
	//[RK]Mar/22/05 - removed pmNumberOfOutlets
	{"protocol","alias", "pmsessions","pmusers", "pmtype", // general 
	//[RK]Sep/24/04 - Bug#2588 - DCD included.
         "speed","datasize","stopbits","parity","flow","dcd",	// serial
	 "users","authtype",				// access
	 "data_buffering","DB_mode","DB_timestamp","dont_show_DBmenu", // dataBuf
	 "syslog_buffering","syslog_sess",		// sysBuf
	 "multiple_sessions","sniff_mode","admin_users","multiuser_notif","escape_char", //mus
	 "pmkey","pmoutlet",	// powerMgm
	 "ipno","web_WinEMS","xml_monitor","translation","biometric","poll_interval","idletimeout",//CAS
	 "host","term",		//TS
	 "initchat","autoppp","pppopt",	//Dial In
	 "socket_port","sttyCmd","issue","break_interval","break_sequence",//other
	 "termsh","logintimeout", //bidirect CyBTS Bug 4663
	 "data_buffering_sess", // dataBuf [RK]Feb/16/05 
#ifdef IPMI
	"IPMIServer", "IPMIkey",	// IPMI
#endif

	};
#define kNumPhysParam	sizeof(PhysParam)/4

static void writePhysConf(FILE *fp, PhysPortsInfo *phys, PhysPortsInfo *all,int port)
{
	char pref[10];
	int type = 0;	// 1-CAS, 2-TS, 4-DialIn, 8-Ipdu
	int i;
	int local_type = 0;
	//char newipno[1024], *pip, *k;

	if (port) {
#ifdef ONS
		if (!lineconf[port-1].auxflg) {
			sprintf(pref,"s%d",port);
		} else {
			sprintf(pref,"a%d", port-AUX_OFFSET);
		}
#else
		sprintf(pref,"s%d",port);
#endif
	} else {
		sprintf(pref,"all");
	}

	switch (phys->general.protocol) {
		case P_LOCAL : case P_RLOGIN : case P_TELNET : case P_SSH : case P_SSH2 : case P_SOCKET_CLIENT : type |= 2; break; // TS
		case P_SLIP : case P_CSLIP : case P_PPP : case P_PPP_ONLY : type |= 4; break; // DialIn
		case P_SOCKET_SERVER : case P_SOCKET_SSH : case P_SOCKET_SERVER_RAW : case P_SOCKET_SERVER_SSH : type |= 1; break; // CAS
		case P_TELNET_BIDIRECT : type |= (1 | 2); break;
		default : type |= 1; break; // assume CAS
	}

	for (i=0; i < NumGeneralProtocol; i++) {
		if (phys->general.protocol == generalProtocolList[i]) 
			break;
	}

	if (port) {
		// general information
		if (all->general.protocol != phys->general.protocol) {
			fprintf(fp,"%s.protocol %s\n",pref,generalProtocolName[i]);
		}
		if (phys->general.alias[0]) {
			fprintf(fp,"%s.alias %s\n",pref,phys->general.alias);
		}
	} else {
		fprintf(fp,"%s.protocol %s\n",pref,generalProtocolName[i]);
	}
	
	if (phys->general.protocol == 105) { // IPDU
#ifdef OEM2
		fprintf(fp,"%s.pmtype bb\n",pref);
#elif OEM3
		fprintf(fp,"%s.pmtype APCPDU\n",pref);
#else
		fprintf(fp,"%s.pmtype cyclades\n",pref);
#endif
		if (phys->general.pmUserList[0]) {
			fprintf(fp,"%s.pmusers %s\n",pref,phys->general.pmUserList);
		}
		if (phys->general.pmsessions) {
			fprintf(fp,"%s.pmsessions ",pref);
			switch(phys->general.pmsessions) {
				case 1 : fprintf(fp,"ssh\n"); break;
				case 2 : fprintf(fp,"telnet\n");break;
				case 3 : fprintf(fp,"ssh_telnet\n");break;
			}
		} else {
			//[RK]Aug/02/04 - default values to IPDU port
			fprintf(fp,"%s.authtype none\n",pref);
		}
		//[RK]Aug/02/04 - default values to IPDU port
		fprintf(fp,"%s.speed 9600\n",pref);
		fprintf(fp,"%s.datasize 8\n",pref);
		fprintf(fp,"%s.stopbits 1\n",pref);
		fprintf(fp,"%s.parity none\n",pref);
		fprintf(fp,"%s.flow none\n",pref);
	}
	
	// access info
	if (!port || (port && (phys->access.action == kSpec))) {
		if (phys->access.users[0]) 
			fprintf(fp,"%s.users %s\n",pref, phys->access.users);
		for (i=0; i < NumAccessAuthType; i++) {
			if (phys->access.authtype == accessAuthtypeList[i]) 
				break;
		}
		if ((phys->access.authtype >= kPatNis) &&
			(phys->access.authtype <= kPatLocalNis)) {
				ReadWriteNisAuthType((int *)&phys->access.authtype, 1);
				ServiceActive(NIS_SHELL,"ENABLE",kYes,1);
				executeFlg |= EXE_DAEMON_SH;
		} else if (ServiceActive(NIS_SHELL,"ENABLE", kNo, 0)) {
			local_type = AUTH_LOCAL;
			ReadWriteNisAuthType((int *)&local_type, 1);
			ServiceActive(NIS_SHELL,"ENABLE",kNo, 1);
			executeFlg |= EXE_DAEMON_SH;
		}
				
		fprintf(fp,"%s.authtype %s\n",pref,accessAuthName[i]);
		if (phys->general.protocol == P_TELNET_BIDIRECT) {
			if (phys->access.termsh && phys->access.termsh[0])
				fprintf(fp, "%s.termsh %s\n", pref, phys->access.termsh);
			if (phys->access.lgtimeout >= 0) {
				fprintf(fp, "%s.logintimeout %d\n", pref, phys->access.lgtimeout);
			}
		}
	}
	
	// other info
	if (!port || (port && (phys->other.action == kSpec))) {
		if (phys->other.socketPort) {
			if (port) {
			        if (phys->other.socketPort != (all->other.socketPort+port-1)) {	
					fprintf(fp,"%s.socket_port %d\n",pref,phys->other.socketPort);
				}
			} else
				fprintf(fp,"all.socket_port %d+\n",phys->other.socketPort);
		}

		if (phys->other.stty[0]) 
			fprintf(fp,"%s.sttyCmd %s\n",pref,phys->other.stty);

		if (phys->other.loginBanner[0]) {
			fprintf(fp,"%s.issue %s\n",pref, phys->other.loginBanner);
		}

		if (phys->other.breakInterval) {
			if (port) {
				if (phys->other.breakInterval != all->other.breakInterval) {
					fprintf(fp,"%s.break_interval %d\n",pref, phys->other.breakInterval);
				}
			} else {
				fprintf(fp,"%s.break_interval %d\n",pref, phys->other.breakInterval);
			}
		}
		//[RK]Feb/25/05 - break sequence
		if (phys->other.breakSequence) {
			if (port) {
				if (phys->other.breakSequence != all->other.breakSequence) {
					fprintf(fp,"%s.break_sequence %s\n",pref, phys->other.breakSequence);
				}
			} else {
				fprintf(fp,"%s.break_sequence %s\n",pref, phys->other.breakSequence);
			}
		}
	}

	if (phys->general.protocol == 105) { // IPDU
		return;
	}

	// serial info
	if (!port || (port && (phys->serial.action == kSpec) && (phys->general.protocol != 105))) {
		fprintf(fp,"%s.speed %d\n",pref,phys->serial.baudRate);
		fprintf(fp,"%s.datasize %d\n",pref,phys->serial.dataSize);
		fprintf(fp,"%s.stopbits %d\n",pref,phys->serial.stopBits);
		fprintf(fp,"%s.parity %s\n",pref,serialParityName[phys->serial.parity-1]);
		fprintf(fp,"%s.flow %s\n",pref,serialFlowName[phys->serial.flowControl]);
		fprintf(fp,"%s.dcd %d\n",pref,phys->serial.dcdState);
	}
	
	if (type & 1) { // CAS
		// data buffering info
		if (!port || (port && (phys->dataBuf.action == kSpec))) {
			fprintf(fp,"%s.data_buffering %d\n",pref,phys->dataBuf.fileSize);
			if (phys->dataBuf.fileSize) {
				if (phys->dataBuf.destType == 0) { // DB local
					fprintf(fp,"%s.DB_mode %s\n",pref,dataBufModeName[phys->dataBuf.mode]);
				}
				fprintf(fp,"%s.DB_timestamp %d\n",pref,phys->dataBuf.timeStamp);
				fprintf(fp,"%s.dont_show_DBmenu %d\n",pref,phys->dataBuf.showMenu);
				//[RK]Feb/16/06
				fprintf(fp,"%s.data_buffering_sess %d\n",pref,phys->dataBuf.allTime);
			}
		}
	
		// syslog buffering info
		if (!port || (port && (phys->sysBuf.action == kSpec))) {
			if (phys->sysBuf.enable) {
				fprintf(fp,"%s.syslog_buffering %d\n",pref,phys->sysBuf.bufferSize);
				fprintf(fp,"%s.syslog_sess %d\n",pref,phys->sysBuf.allTime);
			}
		}
	
		// multiple users session info
		if (!port || (port && (phys->mus.action == kSpec))) {
			fprintf(fp,"%s.multiple_sessions %s\n",pref,musName[phys->mus.multSess]);
			fprintf(fp,"%s.sniff_mode %s\n",pref, musSnifModeName[phys->mus.sniffMode]);
			if (phys->mus.adminUsers[0]) 
				fprintf(fp,"%s.admin_users %s\n",pref, phys->mus.adminUsers);
			if (phys->mus.hotKey[0])
				fprintf(fp,"%s.escape_char %s\n",pref, phys->mus.hotKey);	
			fprintf(fp,"%s.multiuser_notif %s\n",pref,musNotifUserName[phys->mus.notifyUsers]);
		}

		// power management info
#ifdef IPMI
		if (!port || (port && (phys->powerMgm.action == kSpec) && phys->powerMgm.enableIPMI)) {
			if (phys->powerMgm.ipmiKey[0]) {
				fprintf(fp,"%s.IPMIkey %s\n", pref, phys->powerMgm.ipmiKey);
			} else {
				if (port && !all->powerMgm.ipmiKey[0]) 
					fprintf(fp,"%s.IPMIkey ^I\n", pref);
			}
			if (phys->powerMgm.ipmiDeviceId) {
				fprintf(fp,"%s.IPMIServer %d\n", pref, phys->powerMgm.ipmiDeviceId);
			}
		}
#endif
		if (!port || (port && (phys->powerMgm.action == kSpec) && phys->powerMgm.enable)) {
			if (phys->powerMgm.pmKey[0]) {
				fprintf(fp,"%s.pmkey %s\n", pref, phys->powerMgm.pmKey);
			} else {
				if (port && !all->powerMgm.pmKey[0]) 
					fprintf(fp,"%s.pmkey ^p\n", pref);
			}
			if (phys->powerMgm.numOutlets) {
				fprintf(fp,"%s.pmoutlet ", pref);
				for (i=0; i < phys->powerMgm.numOutlets ; i++) {
#ifdef ONS
					if (lineconf[phys->powerMgm.outlet[i].portNum-1].auxflg) {
						fprintf(fp," a%d.%d",
							phys->powerMgm.outlet[i].portNum-AUX_OFFSET,
							phys->powerMgm.outlet[i].outNum);
					} else {
						fprintf(fp," s%d.%d", phys->powerMgm.outlet[i].portNum,
							phys->powerMgm.outlet[i].outNum);
					}
#else
					fprintf(fp," %d.%d", phys->powerMgm.outlet[i].portNum,
						phys->powerMgm.outlet[i].outNum);
#endif
				}
				fprintf(fp,"\n");
			}
			if (phys->powerMgm.allUsers) {
				fprintf(fp,"%s.pmusers all\n",pref);
			}
		}
	
		// CAS info
		if (!port || (port && (phys->cas.action == kSpec))) {
			if (phys->cas.portIpAlias[0]) {
				if (!port) 
					fprintf(fp,"all.ipno %s+\n",phys->cas.portIpAlias);
				else 
					fprintf(fp,"%s.ipno %s\n",pref,phys->cas.portIpAlias);
			}
			if (phys->cas.winEms == kYes) {
				fprintf(fp,"%s.web_WinEMS yes\n",pref);
				fprintf(fp,"%s.xml_monitor 1\n",pref);
				fprintf(fp,"%s.translation xterm\n",pref);
			}
			if (phys->cas.authBio == kYes) {
				fprintf(fp,"%s.biometric 1\n",pref);
			}
			fprintf(fp,"%s.poll_interval %d\n",pref,phys->cas.tcpKeepAlive);
			fprintf(fp,"%s.idletimeout %d\n",pref,phys->cas.tcpIdleTmo);
		}
	}

	// TS info
	if ((type & 2) && // TS
	    (!port || (port && (phys->ts.action == kSpec)))) {
		if (phys->ts.host[0]) {
			fprintf(fp,"%s.host %s\n",pref,phys->ts.host);
		}
		if (phys->ts.terminalType[0]) {
			fprintf(fp,"%s.term %s\n",pref,phys->ts.terminalType);
		}
	}

	// Dial In info
	if (type & 4)  { // Dial In  //[RK]Feb/17/06
	    if (!port || (port && (phys->cas.action == kSpec))) {
		if (phys->cas.portIpAlias[0]) {
			if (!port) 
				fprintf(fp,"all.ipno %s+\n",phys->cas.portIpAlias);
			else 
				fprintf(fp,"%s.ipno %s\n",pref,phys->cas.portIpAlias);
		}
	    }
	    if (!port || (port && (phys->ts.action == kSpec))) {
		if (phys->ts.host[0]) {
			fprintf(fp,"%s.host %s\n",pref,phys->ts.host);
		}
	    }
	}

	if ((type & 4) && // Dial In
	    (!port || (port && (phys->dialIn.action == kSpec)))) {
		if (phys->dialIn.initChat[0]) {
			fprintf(fp,"%s.initchat %s\n",pref,phys->dialIn.initChat);
		}
		if (phys->dialIn.pppOpt[0]) {
			if (phys->general.protocol == P_PPP) {
				// set autoppp instead of pppopt
				fprintf(fp,"%s.autoppp %s\n",pref,phys->dialIn.pppOpt);
			} else
			fprintf(fp,"%s.pppopt %s\n",pref,phys->dialIn.pppOpt);
		}
	}
	
}

static Result WritePhysPortConf(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pkey = (CycCatKeyTable *)ptr;
	FILE * fp;
	unsigned char *buf, *pbl, *pel, cmd[250];
	PhysPortsInfo *phys;
	int allMod,allIns,confIns;
	int port,i;

	dolog("WritePhysPortConf()");

	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (!rdWrtFlg) {
		return(kFileReadError);
	}
	
	// Read the file pslave.conf and writes it to the buffer 
	if ((buf = ReadFile(pkey->fileName, 1)) == NULL) 
	{
		LogError(FILE_READ_ERROR, pkey->fileName);	
		return(kFileReadError);
	}

	// Open the file to begin writing
	if ((fp = fopen(pkey->fileName, "w")) == NULL)
	{
		LogError(FILE_WRITE_ERROR, pkey->fileName);	
		free(buf);
		return (kFileWriteError);
	}
	
	phys = (PhysPortsInfo *)paramList->value;
	allMod = (phys->action == kEdit)? 1 : 0;
	allIns = 0;
	
	if (phys->dataBuf.nfsFile[0]) {
		confIns = 1;
	} else {
		confIns = 0;
	}

	pbl = buf;
	while (*pbl) {
		pel = pbl;
		while (*pel) {
			while (*pel && (*pel != '\n')) pel++;
			if (*(pel-1) == '\\' && (*pel == '\n')) {
				pel++;
			} else {
				break;
			}
		}
		if (*pel)  *pel++ = 0x00;
		if ((pel - pbl) == 1) {
			pbl = pel;
			continue;
		}
		if ((pel - pbl) < 5) {
			fprintf(fp,"%s\n",pbl);
			pbl = pel;
			continue;
		}
		port = 0;
		if (*pbl == '#') {
			if (sscanf(pbl+1,"s%d.%s ",&port,cmd) == 2) {
				if (!strcmp(cmd,"tty")) {
					if (port <= MAX_DEV) {
						if ((phys+port)->general.enable == kYes) {
							fprintf(fp,"%s\n",pbl+1);
						} else {
							fprintf(fp,"%s\n",pbl);
						}
					} else {
						fprintf(fp,"%s\n",pbl);
					}	
				} else {
					fprintf(fp,"%s\n",pbl);
				}
			} else { 
				fprintf(fp,"%s\n",pbl);
			}
			pbl = pel;
			continue;
		}	
		if (sscanf(pbl,"conf.%s ",cmd) == 1) {
			if (!strcmp(cmd,"DB_facility")) {
				fprintf(fp,"conf.DB_facility %d\n",phys->sysBuf.facility);
			} else {
				if (!strcmp(cmd,"nfs_data_buffering")) {
					if (confIns) { 
						fprintf(fp,"conf.nfs_data_buffering %s\n",phys->dataBuf.nfsFile);
						confIns = 0;
					}
				} else {
					fprintf(fp,"%s\n",pbl);
				}
			}
			pbl = pel;
			continue;
		}
		if (confIns) {
			fprintf(fp,"conf.nfs_data_buffering %s\n",phys->dataBuf.nfsFile);
			confIns = 0;
		}
		
		if (sscanf(pbl,"all.%s ",cmd) != 1) {
			if (sscanf(pbl,"s%d.%s ",&port,cmd) != 2) {
				fprintf(fp,"%s\n",pbl);
				pbl = pel;
				continue;
			} else {
				if (allMod && !allIns) {
					writePhysConf(fp, phys,phys,0);
					allIns = 1;
				}
			}
		}
		
		if ((port > paramList->collectionSize) ||
		    ((phys+port)->action == kNone)) {
			fprintf(fp,"%s\n",pbl);
			pbl = pel;
			continue;
		}
		
		for (i=0; i < kNumPhysParam; i++) {
			if (!strcmp(PhysParam[i],cmd)) {
				break;
			}
		}

		if (i == kNumPhysParam) {	
			if (!strcmp(cmd,"tty"))	{
				if (port <= MAX_DEV) {
					if ((phys+port)->general.enable == kYes) {
						fprintf(fp,"%s\n",pbl);
					} else {
						fprintf(fp,"#%s\n",pbl);
					}
				} else {
					fprintf(fp,"%s\n",pbl);
				}
				
				pbl = pel;
				continue;
			} else {
				if (!port || (port && !allMod)) {
					fprintf(fp,"%s\n",pbl);
					pbl = pel;
					continue;
				}
			}
		} 
		pbl = pel;
	}
       //[LMT] Cybts BUG-4426
       if (allMod && !allIns) {
                writePhysConf(fp, phys,phys,0);
                allIns = 1;
        }
	
#ifdef ONS
	for (port=1; port < MAX_DEV; port++) {
#else
	for (port=1; port < paramList->collectionSize; port++) {
#endif
		if ((phys+port)->action == kEdit) {
			writePhysConf(fp, (phys+port),phys,port);
		}
	}
	
	fclose(fp);
	free(buf);
	executeFlg |= EXE_SIGNAL_RAS; 
	return(kCycSuccess);
}

// ==============================
// Power Management applications
// ==============================
static Result RdPmNumPorts (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int i,cont = 0;

	if (rdWrtFlg) return(kCannotSetRoField);

	for (i=0; i < MAX_DEV; i++) {
		if (cy_shm->PMD_pms[i]) cont++;
	}
	*((int*)paramList->value) = cont; 
	return(kCycSuccess);
}

static Result RdPmPortInfo (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int i;
	PmIpduPortInfo *info = (PmIpduPortInfo *) paramList->value;
	
	if (rdWrtFlg) return(kCannotSetRoField);

	for (i=0; i < MAX_DEV; i++) {
		if (cy_shm->PMD_pms[i]) {
			info->serialPort = i+1;
			info->numIpdu = cy_shm->PMD_pms[i];
			if (!cy_shm->PMD_outlets[i]) {
				info->numOutlets = 8; //[RK]Mar/22/05 - default value
			} else {
				info->numOutlets = cy_shm->PMD_outlets[i];
			}
			if (!lineconf[i].alias || !*lineconf[i].alias) {
#ifdef ONS
				if (lineconf[i].auxflg) {
					sprintf(info->name,"PowerMgm-a%d",i+1-AUX_OFFSET);
				} else {
					sprintf(info->name,"PowerMgm-s%d",i+1);
				}
#else
				sprintf(info->name,"PowerMgm-%d",i+1);
#endif
			} else {
				strcpy(info->name,lineconf[i].alias);
			}
			info++;
		}
	}
	return(kCycSuccess);
}

static Result RdPmOutletInfo (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	PmIpduOutletsInfo *info = (PmIpduOutletsInfo *)paramList->value;
	int serialP,nout;

	if (rdWrtFlg) return(kCannotSetRoField);

	serialP = info->serialPort - 1;

	if (cy_shm->PMD_pms[serialP]) {
	       if (info->outletNumber < cy_shm->PMD_outlets[serialP]){
			nout = 	cycPmOutletStatus(info->username,
					info->serialPort, info->outletNumber,
			 		info->outlet);
			info->outletNumber = nout;		
	       }
	}
//	if (nout == 0) {
//		return(kSystemError);
//	} 
	return(kCycSuccess);
}

static Result RdWrtPmIpduConf (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pkey = (CycCatKeyTable *)ptr;

	if (cy_shm->PMD_pms[gPmIpduPort-1]) {
		if (pkey->name == NULL) {
			return(kCycSuccess);
		}
		if (cycPmIpduConf(gPmIpduPort,pkey->name,(CycPmStOnOff *)paramList->value,rdWrtFlg) != true)
			return (kSystemError);
	}
	return(kCycSuccess);
}

static Result WrtPmIpduNumber (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	PmIpduUnitNumber *ipdu = (PmIpduUnitNumber *) paramList->value;
	int port = ipdu->serialPort - 1;

	if (cy_shm->PMD_pms[port] && (ipdu->ipduNumber <= cy_shm->PMD_pms[port])) {
		gPmIpduPort = ipdu->serialPort;
		gPmIpduUnitNumber = ipdu->ipduNumber;
	}

	return(kCycSuccess);
}

static Result RdPmIpduUnitInfo (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	PmIpduInfo *info = (PmIpduInfo *) paramList->value;

	if (rdWrtFlg) return(kCannotSetRoField);

	if (gPmIpduPort > 0) {
		if (cycPmIpduInfo(gPmIpduPort,gPmIpduUnitNumber,info) != true) {
			return(kSystemError);
		}
	}
	return(kCycSuccess);
}

static Result RdWrtPmIpduUnitAlarm (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	if (gPmIpduPort > 0) {
		if (cycPmIpduAlarm(gPmIpduPort,gPmIpduUnitNumber,(PmAlarmStr *)paramList->value,rdWrtFlg) != true) 
			return(kSystemError);
	}
	return(kCycSuccess);
}

static Result RdPmIpduUnit (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pkey = (CycCatKeyTable *)ptr;

	if (rdWrtFlg) return(kCannotSetRoField);

	if (gPmIpduPort > 0) {
		if (pkey->name == NULL) {
			return(kCycSuccess);
		}
		if (cycPmIpduStatus(gPmIpduPort,gPmIpduUnitNumber,pkey->name,
				(PmIpduUnitValues *)paramList->value) != true)
			return(kSystemError);
	}
	
	return(kCycSuccess);
}

static Result RdWrtPmIpduUserMgm (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	CycCatKeyTable *pkey = (CycCatKeyTable *)ptr;
	FILE * fp;
	PmIpduUserMgm *pmgm=(PmIpduUserMgm *) paramList->value;
	PmIpduUsers *puser;
	int nuser = 0,i;
	unsigned char *buf, *pbl, *pel, cmd[500];
	int port, done = FALSE;
	
#ifdef ONS
	int auxflg = 0, serial = 1;
	auxflg = lineconf[pmgm->serialPort - 1].auxflg;
#endif
	// Read the file pslave.conf and writes it to the buffer 
	if (rdWrtFlg) {
		if ((buf = ReadFile(pkey->fileName, 1)) == NULL) 
		{
			LogError(FILE_READ_ERROR, pkey->fileName);	
			return(kFileReadError);
		}

		// Open the file to begin writing
		if ((fp = fopen(pkey->fileName, "w")) == NULL)
		{
			LogError(FILE_WRITE_ERROR, pkey->fileName);	
			free(buf);
			return (kFileWriteError);
		}
		nuser = pmgm->numUsers;
	
		pbl = buf;
		while (*pbl) {
			pel = pbl;
			while (*pel && (*pel != '\n')) pel++;
			if (*pel)  *pel++ = 0x00;
#ifdef ONS
			if (sscanf(pbl,"s%d.%s ",&port,cmd) == 2) {
				serial = 1;
			} else if (sscanf(pbl,"a%d.%s ",&port,cmd) == 2) {
				serial = 0;
			} else {	
#else
			if (sscanf(pbl,"s%d.%s ",&port,cmd) != 2) {
#endif
				fprintf(fp,"%s\n",pbl);
				pbl = pel;
				continue;
			} 
#ifdef ONS
			if ((!auxflg && (!serial || (port != pmgm->serialPort))) ||
				(auxflg && (serial || (port != pmgm->serialPort-AUX_OFFSET))) ||
				 strcmp(cmd,"pmusers")) {
#else
			if ((port != pmgm->serialPort) || strcmp(cmd,"pmusers")) {
#endif
				fprintf(fp,"%s\n",pbl);
				pbl = pel;
				continue;
			}
#ifdef ONS
			fprintf(fp,"%1s%d.pmusers ", auxflg ? "a" : "s", port);
#else
			fprintf(fp,"s%d.pmusers ",port);
#endif
			for (i=0,puser=pmgm->user; i < nuser; i++,puser++) {
				if (puser->action != kDelete) 
					fprintf(fp," %s:%s;",puser->userName, 
							puser->outlets);
			}
			done = TRUE;
			fprintf(fp,"\n");
			executeFlg |= EXE_SIGNAL_RAS;
			pbl = pel;
		}
		if (!done) {
#ifdef ONS
			fprintf(fp,"%1s%d.pmusers ",auxflg ? "a" : "s",
				auxflg ? pmgm->serialPort-AUX_OFFSET : pmgm->serialPort);
#else
			fprintf(fp,"s%d.pmusers ",pmgm->serialPort);
#endif
			for (i=0,puser=pmgm->user; i < nuser; i++,puser++) {
				if (puser->action != kDelete) 
					fprintf(fp," %s:%s;",puser->userName, 
							puser->outlets);
			}
			fprintf(fp,"\n");
			executeFlg |= EXE_SIGNAL_RAS;
		}
		fclose(fp);
		free(buf);
		return (kCycSuccess);
	}
	// read users
	puser = pmgm->user;

	if (lineconf[pmgm->serialPort - 1].pmusers && *lineconf[pmgm->serialPort-1].pmusers) {
		//[RK]Jan/05/06 - Fixed problem with 128 users
		buf = malloc(strlen(lineconf[pmgm->serialPort - 1].pmusers)+1);
		
		strcpy(buf,lineconf[pmgm->serialPort - 1].pmusers);
		pbl = buf;
	} else {
		pmgm->numUsers = 0;
		return (kCycSuccess);
	}
	
	while (*pbl && (nuser < 128)) {
		pel = pbl;
		while (*pel && (*pel != ':')) pel++;
		if (*pel) *pel++= 0x00;
		strcpy(puser->userName,pbl);
		while (*pel && (*pel == ' ')) pel++;
		pbl = pel;
		while (*pel && (*pel != ';')) pel++;
		if (*pel) *pel++ = 0x00;
		while (*pel && (*pel == ' ')) pel++;
		strcpy(puser->outlets,pbl);
		puser->action = kAdd;
		puser++;
		nuser++;
		pbl = pel;
	}	
	free(buf); //[RK]Jan/05/06 - Fixed problem with 128 users
	pmgm->numUsers = nuser;
	return(kCycSuccess);
}

static Result RdPmFirmUpgradeVersion (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	FILE *fp;
	char version[20],*pe,*buf;
	char str[8];

	if (rdWrtFlg) return(kCannotSetRoField);

  	if ((fp = fopen ("/tmp/pmfirmware", "r")) == NULL) {
		*((char *)paramList->value) = 0x00;
		return(kCycSuccess);
	}

	fclose(fp);
	memset(version,0,20);
	system("what /tmp/pmfirmware > /tmp/webtemp");
	if ((buf = ReadFile("/tmp/webtemp", 0)) == NULL) {
		*(char*)paramList->value = 0x00;
		return (kCycSuccess);
	}
	
	str[0] = '@';
	str[1] = '(';
	str[2] = '#';
	str[3] = ')';
	str[4] = 'V';
	str[5] = ' ';
	str[6] = 0;
	pe = strstr(buf, str);
	if (pe == NULL) {
		*(char*)paramList->value = 0x00;
	} else {
		sscanf(pe,"%s%s ", str, version);
		strcpy((char*)paramList->value,version);		
	}
	free(buf);
	return(kCycSuccess);
}

#if defined(KVM) || defined(ONS)
static Result init_kvm_cascade ()
{
	int rc;

	kvm_cascade_global = kvm_cascade_new ();

	if (kvm_cascade_global == NULL) {
		return (kSystemError);
	}

	/**
	 * parse /etc/kvmd.slaves and then /etc/kvmd.conf
	 */
	rc = kvm_cascade_config_read (kvm_cascade_global, "/etc/kvmd.slaves");
	if (rc != KC_OK) {
		printf("error: %s\n", kvm_cascade_strerror(rc));

		/* FIXME: is there any place to put error messages returned by the cascading API? */
		kvm_cascade_free (kvm_cascade_global);
		kvm_cascade_global = NULL;
		return (kSystemError);
	}
	rc = kvm_ports_config_read (kvm_cascade_global, "/etc/kvmd.conf");
	if (rc != KC_OK) {
		printf("error: %s\n", kvm_cascade_strerror(rc));

		/* FIXME: is there any place to put error messages returned by the cascading API? */
		kvm_cascade_free (kvm_cascade_global);
		kvm_cascade_global = NULL;
		return (kSystemError);
	}

	return (kCycSuccess);
}

static Result init_kvm_auxport ()
{
	kvm_auxport_global = kvm_auxport_new ();

	if (kvm_auxport_global == NULL) {
		return (kSystemError);
	}

	return (kCycSuccess);
}

/**
 * makes all "\n" become "\r\n" - this is needed for HTML forms
 *
 * the string returned by this function needs to be free()'d later
 */
static char *htmlize_string (char *string)
{
	int i = 0;
	int j = 0;
	char new_string[4096];

	memset (new_string, 0, 4096);

	for (i = 0, j = 0;i < 4096 && string[i] != '\0'; i++, j++) {
		if (string[i] == '\n') {
			new_string[j] = '\r';
			j++;
		}
		new_string[j] = string[i];
	}

	return (strdup (new_string));
}

static Result kvm_auxport_read_write_config (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	char *new_string = NULL;
	KVMAuxPort *auxport = (KVMAuxPort *) paramList->value;
	kvm_auxport_result rc;
	Result result = kCycSuccess;
	char *kvm_auxport_config_file = "/etc/portslave/pslave.conf";
	int i;

	if (kvm_auxport_global == NULL) {
		result = init_kvm_auxport ();
		if (result != kCycSuccess) {
			return (result);
		}
	}

	if (rdWrtFlg == 0) { /* read configuration from config file */
		memset (auxport, 0, MAX_AUX * sizeof (KVMAuxPort));

		/**
		 * parse /etc/portslave/pslave.conf
		 */
		rc = kvm_auxport_config_read (kvm_auxport_global, kvm_auxport_config_file);
		if (rc != KAP_OK) {
			printf("error - %s\n", kvm_auxport_strerror (rc));
			kvm_auxport_free (kvm_auxport_global);
			kvm_auxport_global = NULL;
			return (kSystemError);
		}
        for (i = 0; i < MAX_AUX; i++) {
            auxport[i].idx = kvm_auxport_global[i].auxidx;
#ifdef ONS
	if(kvm_auxport_global[i].enable == 1)
		auxport[i].enable = kYes;
	else
		auxport[i].enable = kNo;
#endif
            /* protocol */
            switch (kvm_auxport_global[i].protocol) {
                case (KVM_AUXPORT_PROTOCOL_IPDU):
                    auxport[i].protocol = kKVMPProtoIPDU;
                    break;
                case (KVM_AUXPORT_PROTOCOL_PPP_ONLY):
                    auxport[i].protocol = kKVMPProtoPPPOnly;
                    break;
                case (KVM_AUXPORT_PROTOCOL_LOGIN):
                    auxport[i].protocol = kKVMPProtoLogin;
                    break;
                default:
                    return (kSystemError);
            }

            /* baudRate */
            switch (kvm_auxport_global[i].speed) {
                case (kPbr2400):
                    auxport[i].baudRate = kPbr2400;
                    break;
                case (kPbr4800):
                    auxport[i].baudRate = kPbr4800;
                    break;
                case (kPbr9600):
                    auxport[i].baudRate = kPbr9600;
                    break;
                case (kPbr14400):
                    auxport[i].baudRate = kPbr14400;
                    break;
                case (kPbr19200):
                    auxport[i].baudRate = kPbr19200;
                    break;
                case (kPbr28800):
                    auxport[i].baudRate = kPbr28800;
                    break;
                case (kPbr38400):
                    auxport[i].baudRate = kPbr38400;
                    break;
                case (kPbr57600):
                    auxport[i].baudRate = kPbr57600;
                    break;
                case (kPbr76800):
                    auxport[i].baudRate = kPbr76800;
                    break;
                case (kPbr115200):
                    auxport[i].baudRate = kPbr115200;
                    break;
                case (kPbr230400):
                    auxport[i].baudRate = kPbr230400;
                    break;
                case (kPbr460800):
                    auxport[i].baudRate = kPbr460800;
                    break;
                case (kPbr921600):
                    auxport[i].baudRate = kPbr921600;
                    break;
                default:
                    return (kSystemError);
            }

            /* dataSize */
            switch (kvm_auxport_global[i].datasize) {
                case (kPb5):
                    auxport[i].dataSize = kPb5;
                    break;
                case (kPb6):
                    auxport[i].dataSize = kPb6;
                    break;
                case (kPb7):
                    auxport[i].dataSize = kPb7;
                    break;
                case (kPb8):
                    auxport[i].dataSize = kPb8;
                    break;
                default:
                    return (kSystemError);
            }

            /* stopBits */
            switch (kvm_auxport_global[i].stopbits) {
                case (kPsb1):
                    auxport[i].stopBits = kPsb1;
                    break;
                case (kPb2):
                    auxport[i].stopBits = kPb2;
                    break;
                default:
                    return (kSystemError);
            }

            /* parity */
            switch (kvm_auxport_global[i].parity) {
                case (KVM_AUXPORT_PARITY_NONE):
                    auxport[i].parity = kPptNone;
                    break;
                case (KVM_AUXPORT_PARITY_ODD):
                    auxport[i].parity = kPptOdd;
                    break;
                case (KVM_AUXPORT_PARITY_EVEN):
                    auxport[i].parity = kPptEven;
                    break;
                default:
                    return (kSystemError);
            }

            /* flow */
            switch (kvm_auxport_global[i].flow) {
                case (KVM_AUXPORT_FLOW_NONE):
                    auxport[i].flowControl = kPftNone;
                    break;
                case (KVM_AUXPORT_FLOW_SOFT):
                    auxport[i].flowControl= kPftSoft;
                    break;
                case (KVM_AUXPORT_FLOW_HARD):
                    auxport[i].flowControl = kPftHard;
                    break;
                default:
                    return (kSystemError);
            }

            /* initChat */
            if (kvm_auxport_global[i].initchat != NULL) {
                new_string = htmlize_string (kvm_auxport_global[i].initchat);
                strncpy (auxport[i].initChat, new_string, kInitChatLength);
                free (new_string);
                new_string = NULL;
            }

            /* autoPPP */
            if (kvm_auxport_global[i].autoppp != NULL) {
                new_string = htmlize_string (kvm_auxport_global[i].autoppp);
                strncpy (auxport[i].autoPPP, new_string, kAutoPPPLength);
                free (new_string);
                new_string = NULL;
            }
        }
    } else { /* write new configuration into config file */
        for (i = 0; i < MAX_AUX; i++) {
            kvm_auxport_global[i].auxidx = auxport[i].idx;
#ifdef ONS 
	if(auxport[i].enable == kYes)
		kvm_auxport_global[i].enable = 1;

	else
		kvm_auxport_global[i].enable = 0;
#endif
            /* protocol */
            switch (auxport[i].protocol) {
                case (kKVMPProtoIPDU):
                    kvm_auxport_global[i].protocol = KVM_AUXPORT_PROTOCOL_IPDU;
                    break;
                case (kKVMPProtoPPPOnly):
                    kvm_auxport_global[i].protocol = KVM_AUXPORT_PROTOCOL_PPP_ONLY;
                    break;
                case (kKVMPProtoLogin):
                    kvm_auxport_global[i].protocol = KVM_AUXPORT_PROTOCOL_LOGIN;
                    break;
                default:
                    return (kSystemError);
            }

            /* baudRate */
            kvm_auxport_global[i].speed = auxport[i].baudRate;

            /* dataSize */
            kvm_auxport_global[i].datasize = auxport[i].dataSize;

            /* stopBits */
            kvm_auxport_global[i].stopbits = auxport[i].stopBits;

            /* parity */
            switch (auxport[i].parity) {
                case (kPptNone):
                    kvm_auxport_global[i].parity = KVM_AUXPORT_PARITY_NONE;
                    break;
                case (kPptOdd):
                    kvm_auxport_global[i].parity = KVM_AUXPORT_PARITY_ODD;
                    break;
                case (kPptEven):
                    kvm_auxport_global[i].parity = KVM_AUXPORT_PARITY_EVEN;
                    break;
                default:
                    return (kSystemError);
            }

            /* flowControl */
            switch (auxport[i].flowControl) {
                case (kPftNone):
                    kvm_auxport_global[i].flow = KVM_AUXPORT_FLOW_NONE;
                    break;
                case (kPftSoft):
                    kvm_auxport_global[i].flow = KVM_AUXPORT_FLOW_SOFT;
                    break;
                case (kPftHard):
                    kvm_auxport_global[i].flow = KVM_AUXPORT_FLOW_HARD;
                    break;
                default:
                    return (kSystemError);
            }

            /* initChat */
            if (kvm_auxport_global[i].initchat != NULL) {
                free (kvm_auxport_global[i].initchat);
            }
            if (strlen (auxport[i].initChat) > 0) {
                kvm_auxport_global[i].initchat = strdup (auxport[i].initChat);
            } else {
                kvm_auxport_global[i].initchat = NULL;
            }

            /* autoPPP */
            if (kvm_auxport_global[i].autoppp != NULL) {
                free (kvm_auxport_global[i].autoppp);
            }
            if (strlen (auxport[i].autoPPP) > 0) {
                kvm_auxport_global[i].autoppp = strdup (auxport[i].autoPPP);
            } else {
                kvm_auxport_global[i].autoppp = NULL;
            }

        }


		/**
		 * ok, we filled all fields with data from middleware,
		 * now we need to write the information to the config
		 * file
		 */
		rc = kvm_auxport_config_write (kvm_auxport_global, kvm_auxport_config_file);
		if (rc != KAP_OK) {
			kvm_auxport_free (kvm_auxport_global);
			kvm_auxport_global = NULL;
			return (kSystemError);
		}
		kvm_auxport_free (kvm_auxport_global);
		kvm_auxport_global = NULL;
		executeFlg |= EXE_SIGNAL_RAS; 
	}
	return (kCycSuccess);
}
static Result kvm_read_numofoutlet (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int *numoutlet = (int *) paramList->value;
	Result result = kCycSuccess;

	if (!numoutlet) {
		return (kSystemError);
	}
	*numoutlet = cy_shm->PMD_outlets[0];
	return result;
}
static Result kvm_cascade_read_numdevices (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int *numdevices = (int *) paramList->value;
	Result result = kCycSuccess;

	if (rdWrtFlg) {
		return (kCannotSetRoField);
	}

	if (kvm_cascade_global == NULL) {
		result = init_kvm_cascade ();
		if (result != kCycSuccess) {
			return (result);
		}
	}
dolog("kvm_numdevices = %d", kvm_cascade_global->numdevices);
	*numdevices = kvm_cascade_global->numdevices;

	return(kCycSuccess);
}

static Result kvm_cascade_read_write_config (void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int i = 0;
	int j = 0;
	int k = 0;
	int l = 0;
	KVMCascConfig *devices = (KVMCascConfig *) paramList->value;
	Result result;
	struct kvm_cascade_dev_t *kcd;
	struct kvm_cascade_dev_t *new_kcd;
	struct kvm_port_t *ports;

	if (kvm_cascade_global == NULL) {
		result = init_kvm_cascade ();
		if (result != kCycSuccess) {
			return (result);
		}
	}

	if (rdWrtFlg == 0) {
		/**
		 * user wants to read the configuration
		 */
		kcd = kvm_cascade_global->head;
		for (i = 0; i < paramList->collectionSize; i++) {
			if (kcd == NULL) {
				return (kSystemError);
			}

			devices[i].action = kNone;
			strncpy (devices[i].name, kcd->name, kCascNameLength);
			devices[i].numTerms = kcd->numports;
			if (kcd->type == KVM_CASCADE_NETWORK) {
				devices[i].connectionType = 1;
				strncpy (devices[i].hostName, kcd->hostname, kHostNameLength);
			} else {
				devices[i].connectionType = 0;
				if (kcd->parent != NULL) {
					strncpy (devices[i].device, kcd->parent, kCascNameLength);
				} else {
					strncpy (devices[i].device, "master", kCascNameLength);
				}
				devices[i].connectTerms[0] = kcd->user2;
				devices[i].connectTerms[1] = kcd->user1;
			}

			/**
			 * now copy terminal information
			 */
			ports = kcd->ports;
			for (j = 0; j < kcd->numports; j++) {
				devices[i].terms[j].action = kNone;
				if (ports[j].alias != NULL) {
					strncpy (devices[i].terms[j].alias, ports[j].alias, kHostNameLength);
				}
				if (ports[j].active != NULL) {
					if (strcmp (ports[j].active, "yes") == 0) {
						devices[i].terms[j].status = 1;
					} else if (strcmp (ports[j].active, "no") == 0) {
						devices[i].terms[j].status = 0;
					} else if (strcmp (ports[j].active, "cascade") == 0) {
						devices[i].terms[j].status = 2;
					}
				} else {
					devices[i].terms[j].status = 1;
				}
				if (ports[j].pmdevice1 != NULL) {
					strncpy (devices[i].terms[j].pmdevice[0], ports[j].pmdevice1, kCascNameLength);
				}
				if (ports[j].pmdevice2 != NULL) {
					strncpy (devices[i].terms[j].pmdevice[1], ports[j].pmdevice2, kCascNameLength);
				}
				if (ports[j].pmoutletstr != NULL)
				strncpy(devices[i].terms[j].pmoutletstr, ports[j].pmoutletstr, strlen(ports[j].pmoutletstr)<=kHostNameLength?strlen(ports[j].pmoutletstr):kHostNameLength);
				devices[i].terms[j].pmoutlet[0] = ports[j].pmoutlet1;
				devices[i].terms[j].pmoutlet[1] = ports[j].pmoutlet2;
#ifdef KVMTCPport
				devices[i].terms[j].tcpport = ports[j].tcpport;
#endif
				devices[i].terms[j].lclagc = ports[j].lclagc;
				devices[i].terms[j].lclbright = ports[j].lclbright;
				devices[i].terms[j].lclcontr = ports[j].lclcontr;
				devices[i].terms[j].remagc = ports[j].remagc;
				devices[i].terms[j].rembright = ports[j].rembright;
				devices[i].terms[j].remcontr = ports[j].remcontr;
				for (l = 0; l < 4; l ++) {
					devices[i].terms[j].ipbright[l] = ports[j].ipbright[l];
					devices[i].terms[j].ipcontr[l] = ports[j].ipcontr[l];
				}
			}
			
			kcd = kcd->next;
		}
	} else {
		/**
		 * user wants to write the configuration
		 */
		kcd = kvm_cascade_global->head;
		for (i = 0; i < paramList->collectionSize; i++) {
			if (devices[i].action == kDelete) {
				/*
				 * no reason to add this device to our list
				 */
				continue;
			}

			/* this variable holds the number of devices connected */
			k++;

			/**
			 * ok, so this device was added, or should be kept as it is,
			 * so add it to our list
			 */
			new_kcd = (struct kvm_cascade_dev_t *) calloc (1, sizeof (struct kvm_cascade_dev_t));
			new_kcd->name = strdup (devices[i].name);
			new_kcd->numports = devices[i].numTerms;
			if (devices[i].connectionType == 1) {
				new_kcd->type = KVM_CASCADE_NETWORK;
				new_kcd->hostname = strdup (devices[i].hostName);
			} else {
				new_kcd->type = KVM_CASCADE_PHYSICAL;
				if (strlen (devices[i].device) > 0) {
					if (strcmp (devices[i].device, "master") != 0) {
						new_kcd->parent = strdup (devices[i].device);
					}
				}
			}
			new_kcd->user2 = devices[i].connectTerms[0];
			new_kcd->user1 = devices[i].connectTerms[1];

			/**
			 * now configure the ports on this device
			 *
			 * IMPORTANT: we assume there is no mismatch on ports used
			 */
			new_kcd->ports = calloc (new_kcd->numports, sizeof (struct kvm_port_t));
			ports = new_kcd->ports;
			for (j = 0; j < new_kcd->numports; j++) {
				if (strlen (devices[i].terms[j].alias) > 0) {
					ports[j].alias = strdup (devices[i].terms[j].alias);
				}
				switch (devices[i].terms[j].status) {
					case (0): /* no */
						ports[j].active = strdup ("no");
						break;
					case (1): /* yes */
						ports[j].active = strdup ("yes");
						break;
					case (2): /* cascade */
						ports[j].active = strdup ("cascade");
						break;
					default: /* yes */
						ports[j].active = strdup ("yes");
				}
				if (strlen (devices[i].terms[j].pmdevice[0]) > 0) {
					ports[j].pmdevice1 = strdup (devices[i].terms[j].pmdevice[0]);
				}
				if (strlen (devices[i].terms[j].pmdevice[1]) > 0) {
					ports[j].pmdevice2 = strdup (devices[i].terms[j].pmdevice[1]);
				}
				if (devices[i].terms[j].pmoutletstr != NULL)
					ports[j].pmoutletstr = strdup(devices[i].terms[j].pmoutletstr);
				else
					ports[j].pmoutletstr = strdup("");
				ports[j].pmoutlet1 = devices[i].terms[j].pmoutlet[0];
				ports[j].pmoutlet2 = devices[i].terms[j].pmoutlet[1];
#ifdef KVMTCPport
				ports[j].tcpport = devices[i].terms[j].tcpport;
#endif
				ports[j].lclagc = devices[i].terms[j].lclagc;
				ports[j].lclbright = devices[i].terms[j].lclbright;
				ports[j].lclcontr = devices[i].terms[j].lclcontr;
				ports[j].remagc = devices[i].terms[j].remagc;
				ports[j].rembright = devices[i].terms[j].rembright;
				ports[j].remcontr = devices[i].terms[j].remcontr;
				for (l = 0; l < 4; l ++) {
					ports[j].ipbright[l] = devices[i].terms[j].ipbright[l];
					ports[j].ipcontr[l] = devices[i].terms[j].ipcontr[l];
				}
			}

			/* finally, add this device to our device list */
			if (strcmp (new_kcd->name, "master") != 0) {
				kcd->next = new_kcd;
				kcd = kcd->next;
			} else {
				kcd = new_kcd;
				kvm_cascade_global->head = kcd;
			}
		}

		kvm_cascade_global->numdevices = k;

		/**
		 * and finally, write /etc/kvmd.slaves
		 */
		k = kvm_cascade_config_write (kvm_cascade_global, "/etc/kvmd.slaves");
		if (k != KC_OK) {
			return (kSystemError);
		}
		/**
		 * and /etc/kvmd.conf
		 */
		k = kvm_ports_config_write (kvm_cascade_global, "/etc/kvmd.conf");
		if (k != KC_OK) {
			return (kSystemError);
		}
	/* 
     * [JY fix to bug3614], it would be sufficient to call daemon.sh, only if
     *		daemon.sh were called whenever config files changes.
     *		however, this is not the case. so signal hup to kvmd is needed.
     */
		executeFlg |= EXE_DAEMON_SH | EXE_SIGHUP_KVM;
	}

	kvm_cascade_free (kvm_cascade_global);
	kvm_cascade_global = NULL;

	return(kCycSuccess);
}
#endif /* KVM */

#ifdef IPMI 
//[RK]Dec/22/04 - IPMI config
static void * ParseIPMIDeviceEntry (unsigned char *s, CycParam *paramList, void *p)
{
	(*(int *)paramList->value)++;
	return NULL;
}

static void wrtIPMIDeviceInfo(IPMIDeviceInfo * pinfo,int num)
{
	FILE *fp;
	char line[256];
	int i;

	if (!(fp = fopen("/tmp/IPMIServer.conf","w"))) {
		return;
	}

	for (i=0; i < num; i++,pinfo++){
		if (pinfo->action != kDelete) {
			sprintf(line,"%d:%s:%s:%s:%s:%s:%s:\n",pinfo->deviceId,
				pinfo->serverIP,pinfo->authType,
				pinfo->userAccessLevel,
				pinfo->username,pinfo->password,pinfo->alias);
			fwrite(line,strlen(line),1,fp);
		}
	}
	fclose(fp);
	system("cp /tmp/IPMIServer.conf /etc/IPMIServer.conf;rm /tmp/IPMIServer.conf");
}

static void rdIPMIDeviceInfo(IPMIDeviceInfo * pinfo)
{
	FILE *fp;
	char line[129], *field[6], *str,*ptr;
	int i;

	if (!(fp = fopen(IPMI_CONF_FILE,"r"))) {
		return;
	}

	while (fgets(line,128,fp) != NULL) { 
		// deviceID:IPaddress:authtype:privilege:username:password:alias:
		str = line;
		line[128] = 0x00;
		ptr = strchr(str,':');
		if (!ptr) continue;

		*ptr = 0x00;

		pinfo->deviceId = atoi(str);
		str = ptr+1;

		for (i=0;i<6;i++) field[i] = 0;

		for (i=0; (ptr=strchr(str,':')) && (i < 6) ; i++) {
			*ptr = 0x00;
			field[i]= str;
			str = ptr+1;	
		}

		if (i < 5) continue;

		strcpy(pinfo->serverIP,field[0]);
		if (field[1][0] == 0x00) {
			strcpy(pinfo->authType,"none");
		} else {
			strcpy(pinfo->authType,field[1]);
		}
		if (field[2][0] == 0x00) {
			strcpy(pinfo->userAccessLevel,"user");
		} else {
			strcpy(pinfo->userAccessLevel,field[2]);
		}
		strcpy(pinfo->username,field[3]);
		strcpy(pinfo->password,field[4]);
		if (field[5] && (field[5][0] != 0x00)) {
			strcpy(pinfo->alias,field[5]);
		} else {
			sprintf(pinfo->alias,"%d",pinfo->deviceId);
		}
		pinfo++;
	}
	fclose(fp);
}

static Result RdWrtIPMIDeviceInfo (void *prt, CycParam *paramList, int rdWrtFlg)
{
	/* rdWrtFlg=1 -> write / rdWrtFlg=0 ->read */
	if (rdWrtFlg) { // write config
		wrtIPMIDeviceInfo((IPMIDeviceInfo *)paramList->value,paramList->collectionSize);
	} else {
		// read config
		rdIPMIDeviceInfo((IPMIDeviceInfo *)paramList->value);
	}

	return(kCycSuccess);
}

#endif // IPMI

char *CycGetRDPconnect(void)
{
#ifdef RDPenable
    return("enable");
#else
    return("disable");
#endif	//RDPenable
}

#ifdef RDPenable

static
int write_rdp_cfg(CycParam *ParamList)
{
	FILE *fptr, *fptr2;
	int rdp_numsrv = 0, rdppcfg=0, i;
	RDPDevConfig *rdpconf = ((RDPDevice *)(ParamList->value))->deviceList;
	char *rdppf = ((RDPDevice *)(ParamList->value))->rdppfile;

	if((fptr = fopen(KVMD_CONF".tmp", "w"))){

		if((fptr2 = fopen(KVMD_CONF, "r"))){
			char buf[256];
			char *p;

			while(fgets(buf, 255, fptr2)){
				p = buf;
				while(*p && isspace(*p)) p++; // skip spaces
				if (!strncmp(p, "conf.rdpport", 12) &&
					strlen(rdppf) < kRDPPortLength) {
					fprintf(fptr, "conf.rdpport %s\n", rdppf);
					rdppcfg = 1;
					continue;
				}
				if (!strncmp(p, "conf.", 5)) {
					fprintf(fptr, buf);
					continue;
				}
				if (*p == 's' || *p =='p') {
					if (rdppcfg == 0) {
						fprintf(fptr, "conf.rdpport %60s\n", rdppf);
						rdppcfg = 1;
					}
					fprintf(fptr, buf);
				}
			}
			fclose(fptr2);
		}
		if (rdppcfg == 0) {
			fprintf(fptr, "conf.rdpport %60s\n", rdppf);
			rdppcfg = 1;
		}

		for(i = 0; i < kMaxRDPServers; i++){
			if(!rdpconf[i].name[0]) continue; 

			fprintf(fptr, "r%d.alias %s\n", i+1, rdpconf[i].name);
			rdp_numsrv++;
			if(rdpconf[i].ipaddr[0])
				fprintf(fptr, "r%d.ipaddr %s\n", i+1, rdpconf[i].ipaddr);
			if(rdpconf[i].srvport[0])
				fprintf(fptr, "r%d.serverport %s\n", i+1, rdpconf[i].srvport);
			if(rdpconf[i].kvmport[0])
				fprintf(fptr, "r%d.kvmport %s\n", i+1, rdpconf[i].kvmport);
		}

		fclose(fptr);
		unlink(KVMD_CONF);
		rename(KVMD_CONF".tmp", KVMD_CONF);
		return rdp_numsrv;
	}
	return -1;
}

static
int read_rdp_cfg(CycParam *ParamList)
{
	FILE *fptr;
	int ix, rdp_numsrv = 0;
	RDPDevConfig *rdpconf = ((RDPDevice *)(ParamList->value))->deviceList;
	char *rdppf = ((RDPDevice *)(ParamList->value))->rdppfile;
	char *rdpp = ((RDPDevice *)(ParamList->value))->rdpport;

	memset(rdpconf, 0, sizeof(RDPDevConfig) * kMaxRDPServers);
	strcpy(rdppf, "3389+");
	strcpy(rdpp, "3389+");
	if((fptr = fopen(KVMD_CONF, "r"))){
		char key[256], value[256];
		char buf[256];
		char *p, *q;
		int n;
		char c, tmp[4];

		while(fgets(buf, 255, fptr)){
			p = buf;
			while(*p && isspace(*p)) p++; // skip spaces
			if(*p == '#' || !*p) continue; // skip comments and empty lines
			if(sscanf(p, "conf.rdpport %250s", value) == 1) {
				strncpy(rdppf, value, kRDPPortLength-1);
				strncpy(rdpp, value, kRDPPortLength-1);
				continue;
			}
			if(!strncmp(p, "conf.", 5)) continue;
			if(*p == 's' || *p == 'p') continue;

			c = *p;
			q = tmp;
			p++;
			while(*p && isdigit(*p) && q < tmp+3) *(q++) = *(p++);
			*q = 0;
			if(*p != '.'){ fclose(fptr); return -1;}
			n = atoi(tmp);
			p++;
			if(!*p) { fclose(fptr); return -1;}

			if(get_kvmd_keyval(p, key, value) < 0) { fclose(fptr); return -1;}

			if(c != 'r') continue;

			/* rdp server conf */
			if((n <= 0) || (n >= kMaxRDPServers)) {
				dolog("server #%d out of range.\n",n); 
				fclose(fptr); return -1;
			}

			for (ix = 0; ix < kMaxRDPServers; ix++) {
				if (rdpconf[ix].index == n) break;
			}
			if (ix >= kMaxRDPServers)
				ix = rdp_numsrv;

			if(!strcmp(key, "alias")) {
				strncpy(rdpconf[ix].name, value, kRDPGenLength-1);
				if (rdpconf[ix].index == 0) rdp_numsrv++;
				rdpconf[ix].index = n;
			}
			if(!strcmp(key, "ipaddr") && rdpconf[ix].name[0])
				strncpy(rdpconf[ix].ipaddr, value, kRDPGenLength-1);
			if(!strcmp(key, "serverport") && rdpconf[ix].name[0])
				strncpy(rdpconf[ix].srvport, value, kRDPGenLength-1);
			if(!strcmp(key, "kvmport") && rdpconf[ix].name[0])
				strncpy(rdpconf[ix].kvmport, value, kRDPGenLength-1);
		}
		fclose(fptr);
	}
	return (rdp_numsrv);
}

static Result RdWrtRDP(void *ptr, CycParam *ParamList, int rdWrtFlg)
{
	UInt32 *numdevices = &((RDPDevice *)(ParamList->value))->numDevices;
	UInt32 ndev;

	if(!rdWrtFlg){
		ndev = read_rdp_cfg(ParamList);
	}else{
		ndev = write_rdp_cfg(ParamList);
		system("killall -HUP kvmd");
	}
	if (ndev > 0) *numdevices = ndev;

	return kCycSuccess;
}

#endif	//RDPenable

/******************************************************************************************
 gets only the number of ports configured as multidevice (identified by the parameter
 pmoutlet inside the multioutlet_getlist() function
 *****************************************************************************************/
static Result GetNumMultiDev(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	int numdevices;

	numdevices = multioutlet_getlist(NULL);
	*((int *)paramList->value) = numdevices;

	return kCycSuccess;
}


/******************************************************************************************
 get some more information about each multioutlet device. Again, all is done inside 
 multioutlet_getlist()
 *****************************************************************************************/
static Result GetMultiDevInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{

	multioutlet_getlist((PmIpduMultiDevInfo *) paramList->value);

	return kCycSuccess;
}


/******************************************************************************************
 GetMultiDevOutletInfo() this function returns to the application, given a serial port
 configured as multidevice (there is the pmoutlet parameter) information about on/off
 status, lock status, interval, etc for each associated outlet
 *****************************************************************************************/
static Result GetMultiDevOutletInfo(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	PmIpduOutletsInfo *poi;
	PmOutletInfo *po;
	char pmoutlet[100]; //pmoutlet parameter for this serial port
	int nout=0,ret=0;

	//devicestable[i][j]
	//each devicestable[i] contains an array starting with the serial port and continuing
	//with outlet numbers
	//int devicestable[100][50]; WebApi.c:18055: warning: unused variable `devicestable'
	char sdoto[50][20];
	char sdoto2[50][2][20];
	int multidevice_serial,i;

	poi = (PmIpduOutletsInfo *) paramList -> value; 	

	//get the serial port from this structure 
	multidevice_serial = poi->serialPort;	
	
	//the serial port is for a multidevice, get the serial port for each device and outlets
	if(!multioutlet_getpmoutlet(multidevice_serial,pmoutlet)){ //get the pmoutlet parameter
		return kCycSuccess;
	}
	//get into sdoto an array of strings which each position coresponds to an serial.outlet
	//I mean, separate each "value" in pmoutlet parameter into individual positions
	memset(sdoto,0,1000);
	breaklist(pmoutlet,sdoto);	

	//now I break each pair serial.outlet into serparate values but still together
	//due to their positions in this array
	memset(sdoto2,0,2000);	
	breaklist2(sdoto,sdoto2);
	
	//issue a status command, get the result, fill the structures and return
        po = (poi->outlet);  //[GY]2005/Dec/05  BUG#5268
	for(i=0; sdoto2[i][0][0]; i++){
//      	po = (poi->outlet)+i;  [GY]2005/Dec/05  BUG#5268
		ret = cycPmOutletStatus(poi->username, //username passed by the application
				  get_serialPort(sdoto2[i][0]), //serial port
				  atoi(sdoto2[i][1]), //outlet number
				  po);//pointer to struct where data will be returned		
                if( ret > 0 ){  //[GY]2005/Dec/05  BUG#5268
		   po->serialPort = get_serialPort(sdoto2[i][0]) - 1;
		   multioutlet_getalias(po->serialPort, po->portName);
                }
		//nout will get the sum of values returned by cycPmOutletStatus, which is some sort
		//of counting, or -1 if at least one -1 is returned
		//this is due to this implementation be based on RdPmOutletInfo()
		if(nout != -1){
			if(ret == -1) nout = -1;
			else {
                           nout+=ret;
                           po = (poi->outlet) + nout;  //[GY]2005/Dec/05  BUG#5268
                        }  //[GY]2005/Dec/05  BUG#5268
		}
	}
	poi->outletNumber = nout;

	return kCycSuccess;
}

//========================================================================
// RdWrtOnlineHelp - Read/Write Online Help Config
//========================================================================
static Result RdWrtOnlineHelp(void *ptr, CycParam *paramList, int rdWrtFlg)
{
	unsigned char *path = ((OnlineHelpConf *)(paramList->value))->path;
	FILE *fp;
	int len;

	if(!rdWrtFlg) {
		fp = fopen(ONLINE_HELP_FILE, "r");
		if (fp == NULL) {
			LogError(FILE_READ_ERROR, ONLINE_HELP_FILE);
			return(kFileReadError);
		}
		memset(path, 0, kOnlineHelpPathLength);
		fread(path, 1, kOnlineHelpPathLength-1, fp);
		len = strlen(path);
		if (len && path[len-1] == '\n') path[len-1] = 0;
		fclose(fp);
	} else {
		fp = fopen(ONLINE_HELP_FILE, "w+");
		if (fp == NULL) {
			LogError(FILE_WRITE_ERROR, ONLINE_HELP_FILE);
			return(kFileWriteError);
		}
		fwrite(path, strlen(path), 1, fp);
		fwrite("\n", 1, 1, fp);
		fclose(fp);
	}
	return kCycSuccess;
}

